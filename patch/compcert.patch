diff -ruN lib/compcert-1.9/alist.v lib.patched/compcert-1.9/alist.v
--- lib/compcert-1.9/alist.v	1969-12-31 19:00:00.000000000 -0500
+++ lib.patched/compcert-1.9/alist.v	2014-08-30 00:29:06.159588829 -0400
@@ -0,0 +1,913 @@
+Require Import Metatheory.
+Section MoreDom.
+
+Variable X: Type.
+
+Lemma map_fst_dom : forall (E:list (atom*X))
+  (F:list (atom*X)) (H1: List.map fst E = List.map fst F),
+  dom E [=] dom F.
+Proof.
+  induction E as [|[] ?]; destruct F as [|[] ?]; simpl; 
+    intros; inversion H1; subst.
+    fsetdec.
+    apply IHE in H2. fsetdec. 
+Qed.
+
+Lemma uniq_map_fst : forall (E:list (atom*X))
+  (H1: uniq E) (F:list (atom*X)) (H2: List.map fst E = List.map fst F),
+  uniq F.
+Proof.
+  induction 1; destruct F as [|[] ?]; simpl; intros; auto.
+    congruence.
+
+    simpl_env.
+    inversion H2; subst.
+    constructor; auto.
+      apply map_fst_dom in H4. fsetdec.
+Qed.
+
+Lemma in_dom_cons_inv : forall a (v:X) l id0,
+  id0 `in` dom ((a,v)::l) ->
+  id0 = a \/ id0 `in` dom l.
+Proof.
+  intros.
+  simpl in H. fsetdec.
+Qed.
+
+Lemma in_dom_app_inv : forall id0 D1 D2,
+  id0 `in` D1 `union` D2 ->
+  id0 `in` D1 \/ id0 `in` D2.
+Proof.
+  intros.
+  fsetdec.
+Qed.
+
+Lemma in_dom_ext_right : forall i0 D1 D2,
+  i0 `in` D1 ->
+  i0 `in` D1 `union` D2.
+Proof. fsetdec. Qed.
+
+Lemma in_dom_ext_left : forall i0 D1 D2,
+  i0 `in` D1 ->
+  i0 `in` D2 `union` D1.
+Proof. fsetdec. Qed.
+
+Lemma dom_rev_eq: forall (l0:list (atom*X)), dom l0 [=] dom (rev l0).
+Proof.
+  induction l0 as [|[]]; simpl.
+    fsetdec.
+    simpl_env. fsetdec.    
+Qed.
+
+Lemma uniq_rev: forall (l0:list (atom*X)) (H:uniq l0), uniq (rev l0).
+Proof.
+  induction l0; simpl; intros; auto.
+    inversion H. subst.
+    simpl_env.
+    apply uniq_app_4; auto.
+    apply disjoint_sym_1.
+    apply disjoint_one_2.
+      rewrite <- dom_rev_eq. auto.
+Qed.
+
+Lemma In_InDom : forall id1 (v1:X) l1,
+  In (id1, v1) l1 -> id1 `in` dom l1.
+Proof.
+  induction l1 as [|[id2 v2]]; simpl; intros.
+    inversion H.
+
+    destruct H as [H | H].
+      inversion H. auto.
+      auto.
+Qed.
+
+End MoreDom.
+
+Section MoreAssocLists.
+
+Variable X: Type.
+Definition AssocList := list (atom*X).
+
+(* update if exists, add it otherwise *)
+Fixpoint updateAddAL (m:AssocList) (i:atom) (gv:X) : AssocList :=
+match m with
+| nil => (i, gv)::nil
+| (i', gv')::m' =>
+  if (eq_dec i i')
+  then (i', gv)::m'
+  else (i', gv')::updateAddAL m' i gv
+end.
+
+Definition updateAddALs (lc:AssocList) (kvs:list (atom*X)) :
+  AssocList :=
+fold_left  (fun lc0 kv => let '(k, v) := kv in updateAddAL lc0 k v) kvs lc.
+
+Lemma simpl_cons_updateAddALs : forall lc v k vks,
+  updateAddALs lc ((v,k)::vks) = updateAddALs (updateAddAL lc v k) vks.
+Proof. auto. Qed.
+
+(* update only if exists, do nothing otherwise *)
+Fixpoint updateAL (m:AssocList) (i:atom) (gv:X) : AssocList :=
+match m with
+| nil => nil
+| (i', gv')::m' =>
+  if (eq_dec i i')
+  then (i', gv)::m'
+  else (i', gv')::updateAL m' i gv
+end.
+
+Fixpoint lookupAL (m:AssocList) (i:atom) : option X :=
+match m with
+| nil => None
+| (i', gv')::m' =>
+  if (eq_dec i i')
+  then Some gv'
+  else lookupAL m' i
+end.
+
+Fixpoint deleteAL (m:AssocList) (i:atom) : AssocList :=
+match m with
+| nil => nil
+| (id0, gv0)::m' =>
+    if (i == id0) then deleteAL m' i else (id0, gv0)::deleteAL m' i
+end.
+
+Definition rollbackAL (locals : AssocList) (i:atom) (lc0 : AssocList)
+  : AssocList :=
+match (lookupAL lc0 i) with
+| Some gv0 => updateAL locals i gv0
+| None => deleteAL locals i
+end.
+
+Lemma updateAddAL_mono : forall l1 id0 e0 id1,
+  id1 `in` dom l1 ->
+  id1 `in` dom (updateAddAL l1 id0 e0).
+Proof.
+  induction l1; intros; simpl in *.
+    contradict H; fsetdec.
+
+    destruct a.
+    destruct (id0 == a); subst; simpl; auto.
+      assert (id1 = a \/ id1 `in` dom l1) as J.
+        fsetdec.
+      destruct J as [J | J]; subst; auto.
+Qed.
+
+Lemma lookupAL_updateAL_in : forall m id0 gv0,
+  id0 `in` dom m ->
+  lookupAL (updateAL m id0 gv0) id0 = Some gv0.
+Proof.
+  induction m; intros; simpl.
+    simpl in H. contradict H; auto.
+
+    destruct a.
+    destruct (@eq_dec atom (@EqDec_eq_of_EqDec atom EqDec_atom) id0 a);
+      subst; simpl.
+      destruct (@eq_dec atom (@EqDec_eq_of_EqDec atom EqDec_atom) a a);
+        subst; simpl; auto.
+        contradict n; auto.
+      destruct (@eq_dec atom (@EqDec_eq_of_EqDec atom EqDec_atom) id0 a);
+        subst; simpl; auto.
+        contradict n; auto.
+
+        assert (id0 = a \/ id0 `in` dom m) as J. simpl in H. fsetdec.
+        destruct J as [J | J]; subst.
+          contradict n; auto.
+          apply IHm with (gv0:=gv0) in J; auto.
+Qed.
+
+Lemma lookupAL_updateAddAL_eq : forall m id0 gv0,
+  lookupAL (updateAddAL m id0 gv0) id0 = Some gv0.
+Proof.
+  induction m; intros; simpl.
+    destruct (@eq_dec atom (@EqDec_eq_of_EqDec atom EqDec_atom) id0 id0); subst;
+      simpl; auto.
+      contradict n; auto.
+
+    destruct a.
+    destruct (@eq_dec atom (@EqDec_eq_of_EqDec atom EqDec_atom) id0 a);
+      subst; simpl.
+      destruct (@eq_dec atom (@EqDec_eq_of_EqDec atom EqDec_atom) a a);
+        subst; simpl; auto.
+        contradict n; auto.
+      destruct (@eq_dec atom (@EqDec_eq_of_EqDec atom EqDec_atom) id0 a);
+        subst; simpl; auto.
+        contradict n; auto.
+Qed.
+
+Lemma notin_lookupAL_None : forall m id0,
+  id0 `notin` dom m ->
+  lookupAL m id0 = None.
+Proof.
+  induction m; intros; simpl; auto.
+    destruct a.
+    simpl in H.
+    destruct (@eq_dec atom (@EqDec_eq_of_EqDec atom EqDec_atom) id0 a);
+      subst; simpl; auto.
+      contradict H; auto.
+Qed.
+
+Lemma lookupAL_updateAL_neq : forall m id0 id1 gv0,
+  id1 <> id0 ->
+  lookupAL m id1 = lookupAL (updateAL m id0 gv0) id1.
+Proof.
+  induction m; intros; simpl; auto.
+    destruct a.
+      destruct (@eq_dec atom (@EqDec_eq_of_EqDec atom EqDec_atom) id1 id0);
+        subst; simpl; auto.
+        contradict H; auto.
+        destruct (@eq_dec atom (@EqDec_eq_of_EqDec atom EqDec_atom) id1 a);
+          subst; simpl; auto.
+          destruct (@eq_dec atom (@EqDec_eq_of_EqDec atom EqDec_atom) id0 a);
+            subst; simpl; auto.
+            contradict H; auto.
+            destruct (@eq_dec atom (@EqDec_eq_of_EqDec atom EqDec_atom) a a);
+              subst; simpl; auto.
+              contradict n1; auto.
+          destruct (@eq_dec atom (@EqDec_eq_of_EqDec atom EqDec_atom) id0 a);
+            subst; simpl; auto.
+            destruct (@eq_dec atom (@EqDec_eq_of_EqDec atom EqDec_atom) id1 a);
+              subst; simpl; auto.
+              contradict n; auto.
+            destruct (@eq_dec atom (@EqDec_eq_of_EqDec atom EqDec_atom) id1 a);
+              subst; simpl; auto.
+              contradict n0; auto.
+Qed.
+
+Lemma lookupAL_updateAddAL_neq : forall m id0 id1 gv0,
+  id1 <> id0 ->
+  lookupAL m id1 = lookupAL (updateAddAL m id0 gv0) id1.
+Proof.
+  induction m; intros; simpl; auto.
+    destruct (@eq_dec atom (@EqDec_eq_of_EqDec atom EqDec_atom) id1 id0);
+      subst; auto.
+      contradict H; auto.
+
+    destruct a.
+      destruct (@eq_dec atom (@EqDec_eq_of_EqDec atom EqDec_atom) id1 id0);
+        subst; simpl; auto.
+        contradict H; auto.
+        destruct (@eq_dec atom (@EqDec_eq_of_EqDec atom EqDec_atom) id1 a);
+          subst; simpl; auto.
+          destruct (@eq_dec atom (@EqDec_eq_of_EqDec atom EqDec_atom) id0 a);
+            subst; simpl; auto.
+            contradict H; auto.
+            destruct (@eq_dec atom (@EqDec_eq_of_EqDec atom EqDec_atom) a a);
+              subst; simpl; auto.
+              contradict n1; auto.
+          destruct (@eq_dec atom (@EqDec_eq_of_EqDec atom EqDec_atom) id0 a);
+            subst; simpl; auto.
+            destruct (@eq_dec atom (@EqDec_eq_of_EqDec atom EqDec_atom) id1 a);
+              subst; simpl; auto.
+              contradict n; auto.
+            destruct (@eq_dec atom (@EqDec_eq_of_EqDec atom EqDec_atom) id1 a);
+              subst; simpl; auto.
+              contradict n0; auto.
+Qed.
+
+Lemma lookupAL_Some_indom : forall m id0 gv,
+  lookupAL m id0 = Some gv ->
+  id0 `in` dom m.
+Proof.
+  induction m; intros.
+    simpl in H. inversion H.
+
+    simpl in H. destruct a.
+    destruct (@eq_dec atom (@EqDec_eq_of_EqDec atom EqDec_atom) id0 a); subst;
+      simpl; auto.
+      apply IHm in H; auto.
+Qed.
+
+Lemma lookupAL_None_notindom : forall m id0,
+  lookupAL m id0 = None ->
+  id0 `notin` dom m.
+Proof.
+  induction m; intros.
+    auto.
+
+    simpl in H. destruct a.
+    destruct (@eq_dec atom (@EqDec_eq_of_EqDec atom EqDec_atom) id0 a); subst;
+      simpl; auto.
+      inversion H.
+Qed.
+
+Lemma lookupAL_updateAL_notin : forall m id1 id0 gv0,
+  id0 `notin` dom m ->
+  lookupAL (updateAL m id0 gv0) id1 = lookupAL m id1.
+Proof.
+  induction m; intros; simpl; auto.
+
+    destruct a.
+    destruct (@eq_dec atom (@EqDec_eq_of_EqDec atom EqDec_atom) id0 a); subst;
+      simpl.
+      simpl in H. contradict H; auto.
+
+      destruct (@eq_dec atom (@EqDec_eq_of_EqDec atom EqDec_atom) id1 a); subst;
+        simpl; auto.
+Qed.
+
+Lemma lookupAL_deleteAL_eq : forall m id0,
+  lookupAL (deleteAL m id0) id0 = None.
+Proof.
+  induction m; intros id0; simpl; auto.
+  destruct a.
+  destruct (@eq_dec atom (@EqDec_eq_of_EqDec atom EqDec_atom) id0 a);
+    subst; auto.
+
+    simpl.
+    destruct (@eq_dec atom (@EqDec_eq_of_EqDec atom EqDec_atom) id0 a);
+      subst; auto.
+      congruence.
+Qed.
+
+Lemma indom_lookupAL_Some : forall m id0,
+  id0 `in` dom m ->
+  exists gv0, lookupAL m id0 = Some gv0.
+Proof.
+  induction m; intros.
+    simpl in H.
+    contradict H; auto.
+
+    destruct a.
+    simpl in H.
+    assert (id0 = a \/ id0 `in` dom m) as J.
+      fsetdec.
+    destruct J as [EQ | J]; subst.
+      simpl.
+      exists x.
+      destruct (@eq_dec atom (@EqDec_eq_of_EqDec atom EqDec_atom) a a); auto.
+        contradict n; auto.
+
+      simpl.
+      destruct (@eq_dec atom (@EqDec_eq_of_EqDec atom EqDec_atom) id0 a); subst;
+        auto.
+        exists x. auto.
+Qed.
+
+Lemma updateAL_dom_eq : forall m id0 gv0,
+  dom m [=] dom (updateAL m id0 gv0).
+Proof.
+  induction m; intros; simpl.
+    fsetdec.
+
+    destruct a.
+    destruct (@eq_dec atom (@EqDec_eq_of_EqDec atom EqDec_atom) id0 a); subst.
+      simpl. fsetdec.
+      simpl. rewrite <- IHm; auto. fsetdec.
+Qed.
+
+Lemma updateAL_uniq : forall m id0 gv0,
+  uniq m ->
+  uniq (updateAL m id0 gv0).
+Proof.
+  intros m id0 gv0 Uniq.
+  induction Uniq; simpl; auto.
+  destruct (@eq_dec atom (@EqDec_eq_of_EqDec atom EqDec_atom) id0 x); subst;
+    auto.
+    simpl_env.
+    apply uniq_push; auto.
+      rewrite <- updateAL_dom_eq; auto.
+Qed.
+
+Lemma lookupAL_deleteAL_neq : forall m id0 id1,
+  id0 <> id1 ->
+  lookupAL (deleteAL m id0) id1 = lookupAL m id1.
+Proof.
+  induction m; intros id0 id1 id0_isnt_id1; simpl; auto.
+  destruct a.
+  destruct (@eq_dec atom (@EqDec_eq_of_EqDec atom EqDec_atom) id0 a); subst.
+    destruct (@eq_dec atom (@EqDec_eq_of_EqDec atom EqDec_atom) id1 a); subst;
+      auto.
+      contradict id0_isnt_id1; auto.
+    destruct (@eq_dec atom (@EqDec_eq_of_EqDec atom EqDec_atom) id1 a); subst;
+      simpl.
+      destruct (@eq_dec atom (@EqDec_eq_of_EqDec atom EqDec_atom) a a); subst;
+        auto.
+        contradict n0; auto.
+      destruct (@eq_dec atom (@EqDec_eq_of_EqDec atom EqDec_atom) id1 a); subst;
+        auto.
+        contradict n0; auto.
+Qed.
+
+Lemma deleteAL_dom_sub : forall m id0,
+  dom (deleteAL m id0) [<=] dom m.
+Proof.
+  induction m; intros; simpl.
+    fsetdec.
+
+    destruct a.
+    assert (J:=@IHm id0).
+    destruct (@eq_dec atom (@EqDec_eq_of_EqDec atom EqDec_atom) id0 a); simpl;
+      subst; fsetdec.
+Qed.
+
+Lemma deleteAL_uniq : forall m id0,
+  uniq m ->
+  uniq (deleteAL m id0).
+Proof.
+  intros m id0 Uniq.
+  induction Uniq; simpl; auto.
+  destruct (@eq_dec atom (@EqDec_eq_of_EqDec atom EqDec_atom) id0 x); subst;
+    auto.
+    simpl_env.
+    assert (J:=@deleteAL_dom_sub E id0).
+    apply uniq_push; auto.
+Qed.
+
+Lemma updateAddAL_dom_eq : forall sm id0 st0,
+  dom (updateAddAL sm id0 st0) [=] dom sm `union` {{id0}}.
+Proof.
+  induction sm; intros; simpl; try solve [fsetdec].
+    destruct a.
+    destruct (@eq_dec atom (@EqDec_eq_of_EqDec atom EqDec_atom) id0 a); simpl;
+      try solve [fsetdec].
+      assert (J:=@IHsm id0 st0). fsetdec.
+Qed.
+
+Lemma updateAddAL_uniq : forall sm id0 st0,
+  uniq sm ->
+  uniq (updateAddAL sm id0 st0).
+Proof.
+  induction sm; intros; simpl; auto.
+    destruct a.
+
+    destruct_uniq.
+    destruct (@eq_dec atom (@EqDec_eq_of_EqDec atom EqDec_atom) id0 a); subst;
+      try solve [solve_uniq].
+      apply IHsm with (id0:=id0)(st0:=st0) in H.
+      assert (J:=@updateAddAL_dom_eq sm id0 st0).
+      solve_uniq.
+Qed.
+
+Lemma updateAddAL_inversion : forall sm id0 st0 id1 st1,
+  uniq sm ->
+  binds id1 st1 (updateAddAL sm id0 st0) ->
+  (id0 <> id1 /\ binds id1 st1 sm) \/ (id0 = id1 /\ st0 = st1).
+Proof.
+  induction sm; intros id0 st0 id1 st1 Uniq Binds; simpl in Binds.
+    analyze_binds Binds.
+
+    destruct a.
+    inversion Uniq; subst.
+    destruct (@eq_dec atom (@EqDec_eq_of_EqDec atom EqDec_atom) id0 a); subst.
+      analyze_binds Binds.
+      left. split; auto.
+        apply binds_In in BindsTac.
+        fsetdec.
+
+      analyze_binds Binds.
+      apply IHsm in BindsTac; auto.
+        destruct BindsTac; auto.
+          destruct H; auto.
+Qed.
+
+Lemma updateAddAL_in_inversion : forall sm id0 st0 id1,
+  uniq sm ->
+  id1 `in` dom (updateAddAL sm id0 st0) ->
+  (id0 <> id1 /\ id1 `in` dom sm) \/ (id0 = id1).
+Proof.
+  induction sm; intros id0 st0 id1 Uniq Hin; simpl in Hin.
+    right. fsetdec.
+
+    destruct a.
+    inversion Uniq; subst.
+    destruct (@eq_dec atom (@EqDec_eq_of_EqDec atom EqDec_atom) id0 a); subst.
+      destruct (@in_dom_cons_inv _ _ _ _ _ Hin) as [EQ | id1_in_sm]; subst; auto.
+        left. split; fsetdec.
+
+      destruct (@in_dom_cons_inv _ _ _ _ _ Hin) as [EQ | id1_in_sm]; subst; simpl; auto.
+        apply IHsm in id1_in_sm; auto.
+        destruct id1_in_sm as [[id0_isnt_id1 id1_in_sm] | EQ]; auto.
+Qed.
+
+Lemma binds_updateAddAL_eq : forall sm id0 st0,
+  binds id0 st0 (updateAddAL sm id0 st0).
+Proof.
+  induction sm; intros id0 st0; simpl; auto.
+    destruct a.
+    destruct (@eq_dec atom (@EqDec_eq_of_EqDec atom EqDec_atom) id0 a); subst; auto.
+Qed.
+
+Lemma binds_updateAddAL_neq : forall sm id0 st0 id1 st1,
+  binds id1 st1 sm ->
+  id0 <> id1 ->
+  binds id1 st1 (updateAddAL sm id0 st0).
+Proof.
+  induction sm; intros id0 st0 id1 st1 Hbinds id0_neq_id1; simpl; auto.
+    destruct a.
+    simpl_env in Hbinds.
+    analyze_binds Hbinds.
+      destruct (@eq_dec atom (@EqDec_eq_of_EqDec atom EqDec_atom) id0 a); subst; auto.
+        contradict id0_neq_id1; auto.
+
+      destruct (@eq_dec atom (@EqDec_eq_of_EqDec atom EqDec_atom) id0 a); subst; auto.
+Qed.
+
+Lemma in_updateAddAL_eq : forall sm id0 st0,
+  id0 `in` dom (updateAddAL sm id0 st0).
+Proof.
+  induction sm; intros id0 st0; simpl; auto.
+    destruct a.
+    destruct (@eq_dec atom (@EqDec_eq_of_EqDec atom EqDec_atom) id0 a); subst; simpl; auto.
+Qed.
+
+Lemma in_updateAddAL_neq : forall sm id0 st0 id1,
+  id1 `in` dom sm ->
+  id0 <> id1 ->
+  id1 `in` dom (updateAddAL sm id0 st0).
+Proof.
+  induction sm; intros id0 st0 id1 Hbinds id0_neq_id1; simpl; auto.
+    destruct a.
+    apply in_dom_cons_inv in Hbinds.
+    destruct Hbinds; subst.
+      destruct (@eq_dec atom (@EqDec_eq_of_EqDec atom EqDec_atom) id0 a); subst; simpl; auto.
+      destruct (@eq_dec atom (@EqDec_eq_of_EqDec atom EqDec_atom) id0 a); subst; simpl; auto.
+Qed.
+
+Lemma mergeALs_inv : forall l2b l2b' B l0,
+  uniq (l2b++l2b') ->
+  lookupAL (l2b++l2b') l0 = Some B ->
+  lookupAL l2b l0 = Some B \/
+  lookupAL l2b' l0 = Some B.
+Proof.
+  intros.
+  induction l2b; auto.
+    destruct a. simpl in *.
+    inversion H; subst.
+    destruct (@eq_dec atom (@EqDec_eq_of_EqDec atom EqDec_atom) l0 a); subst; auto.
+Qed.
+
+Lemma mergeALs_app : forall l2b l2b' B l0,
+  uniq (l2b++l2b') ->
+  lookupAL l2b l0 = Some B \/ lookupAL l2b' l0 = Some B ->
+  lookupAL (l2b++l2b') l0 = Some B.
+Proof.
+  intros.
+  induction l2b; auto.
+    destruct H0 as [H0 | H0]; simpl_env; auto.
+    inversion H0.
+
+    destruct a. simpl in H.
+    inversion H; subst. clear H.
+    destruct H0 as [H0 | H0]; simpl in *.
+      destruct (@eq_dec atom (@EqDec_eq_of_EqDec atom EqDec_atom) l0 a);
+        subst; auto.
+      destruct (@eq_dec atom (@EqDec_eq_of_EqDec atom EqDec_atom) l0 a);
+        subst; auto.
+        apply lookupAL_Some_indom in H0.
+        contradict H0; auto.
+Qed.
+
+Lemma lookupAL_updateAL_Some_eq : forall lc id0 gv0 gv1,
+  lookupAL lc id0 = Some gv0 ->
+  lookupAL (updateAL lc id0 gv1) id0 = Some gv1.
+Proof.
+  intros lc id0 gv0 gv1 Hl.
+  destruct (AtomSetProperties.In_dec id0 (dom lc)).
+    rewrite lookupAL_updateAL_in; auto.
+
+    rewrite notin_lookupAL_None in Hl; auto.
+    inversion Hl.
+Qed.
+
+Lemma lookupAL_updateAL_None_eq : forall lc id0 gv1,
+  lookupAL lc id0 = None ->
+  lookupAL (updateAL lc id0 gv1) id0 = None.
+Proof.
+  intros lc id0 gv1 Hl.
+  destruct (AtomSetProperties.In_dec id0 (dom lc)).
+    apply indom_lookupAL_Some in i.
+    destruct i as [gv0 i].
+    rewrite i in Hl.
+    inversion Hl.
+
+    rewrite lookupAL_updateAL_notin; auto.
+Qed.
+
+Lemma lookupAL_updateAL_ident: forall id0 gv0 lc ,
+  lookupAL lc id0 = Some gv0 ->
+  updateAL lc id0 gv0 = lc.
+Proof.
+  induction lc; simpl; intros; auto.
+    destruct a.
+    destruct (@eq_dec atom (@EqDec_eq_of_EqDec atom EqDec_atom) id0 a);
+      subst; auto.
+      inversion H. subst. auto.
+
+      rewrite IHlc; auto.
+Qed.
+
+Lemma lookupAL_updateAddAL_ident: forall id0 gv0 lc ,
+  lookupAL lc id0 = Some gv0 ->
+  updateAddAL lc id0 gv0 = lc.
+Proof.
+  induction lc; simpl; intros; auto.
+    congruence.
+
+    destruct a.
+    destruct (@eq_dec atom (@EqDec_eq_of_EqDec atom EqDec_atom) id0 a);
+      subst; auto.
+      inversion H. subst. auto.
+
+      rewrite IHlc; auto.
+Qed.
+
+Lemma lookupAL_rollbackAL_neq : forall lc id0 lc0 id1,
+  id0 <> id1 ->
+  lookupAL lc id1 = lookupAL (rollbackAL lc id0 lc0) id1.
+Proof.
+  intros lc id0 lc0 id1 id0_isnt_id1.
+  unfold rollbackAL.
+  destruct (lookupAL lc0 id0).
+    eapply lookupAL_updateAL_neq; eauto.
+    rewrite lookupAL_deleteAL_neq; auto.
+Qed.
+
+Lemma lookupAL_rollbackAL_Some_eq : forall lc id0 lc0 gv0,
+  lookupAL lc id0 = Some gv0 ->
+  lookupAL (rollbackAL lc id0 lc0) id0 = lookupAL lc0 id0.
+Proof.
+  intros lc id0 lc0 gv0 HlookupAL.
+  unfold rollbackAL.
+  remember (lookupAL lc0 id0) as ogv0.
+  destruct ogv0.
+    rewrite Heqogv0.
+    erewrite lookupAL_updateAL_Some_eq with (gv0:=gv0); eauto.
+
+    rewrite lookupAL_deleteAL_eq; auto.
+Qed.
+
+Lemma lookupAL_rollbackAL_None_eq : forall lc id0 lc0,
+  lookupAL lc id0 = None ->
+  lookupAL (rollbackAL lc id0 lc0) id0 = None.
+Proof.
+  intros lc id0 lc0 HlookupAL.
+  unfold rollbackAL.
+  destruct (lookupAL lc0 id0).
+    erewrite lookupAL_updateAL_None_eq; eauto.
+    erewrite lookupAL_deleteAL_eq; eauto.
+Qed.
+
+Lemma rollbackAL_uniq : forall id0 lc0 lc,
+  uniq lc ->
+  uniq (rollbackAL lc id0 lc0).
+Proof.
+  intros id0 lc0 lc Huniqc.
+  unfold rollbackAL.
+  destruct (lookupAL lc0 id0).
+    apply updateAL_uniq; auto.
+    apply deleteAL_uniq; auto.
+Qed.
+
+Lemma lookupAL_rollbackAL_eq : forall lc id0 lc0 gv,
+  lookupAL lc id0 = Some gv ->
+  lookupAL (rollbackAL lc id0 lc0) id0 = lookupAL lc0 id0.
+Proof.
+  intros lc id0 lc0 gv HlookupAL.
+  unfold rollbackAL.
+  remember (lookupAL lc0 id0) as ogv0.
+  destruct ogv0.
+    apply lookupAL_Some_indom in HlookupAL.
+    rewrite lookupAL_updateAL_in; auto.
+
+    rewrite lookupAL_deleteAL_eq; auto.
+Qed.
+
+Definition eqAL lc1 lc2 :=
+  forall i, lookupAL lc1 i = lookupAL lc2 i.
+
+Lemma eqAL_refl : forall lc,
+  eqAL lc lc.
+Proof. unfold eqAL. auto. Qed.
+
+Lemma eqAL_sym : forall lc1 lc2,
+  eqAL lc1 lc2 ->
+  eqAL lc2 lc1.
+Proof. unfold eqAL. auto. Qed.
+
+Lemma eqAL_trans : forall lc1 lc2 lc3,
+  eqAL lc1 lc2 ->
+  eqAL lc2 lc3 ->
+  eqAL lc1 lc3.
+Proof.
+  unfold eqAL.
+  intros.
+  assert (J1:=@H i).
+  assert (J2:=@H0 i).
+  rewrite J1. auto.
+Qed.
+
+Lemma eqAL_indom_iff : forall lc1 lc1' id0,
+  eqAL lc1 lc1' ->
+  (id0 `in` dom lc1 <-> id0 `in` dom lc1').
+Proof.
+  intros lc1 lc1' id0 HeqAL.
+  split; intro J.
+    assert (J':=@HeqAL id0).
+    apply indom_lookupAL_Some in J; auto.
+    destruct J as [gv0 J].
+    rewrite J' in J.
+    apply lookupAL_Some_indom in J; auto.
+
+    assert (J':=@HeqAL id0).
+    apply indom_lookupAL_Some in J; auto.
+    destruct J as [gv0 J].
+    rewrite J in J'.
+    apply lookupAL_Some_indom in J'; auto.
+Qed.
+
+Lemma eqAL_indom_onlyif : forall lc1 lc1' id0,
+  eqAL lc1 lc1' ->
+  id0 `in` dom lc1 ->
+  id0 `in` dom lc1'.
+Proof.
+  intros.
+  apply eqAL_indom_iff with (id0:=id0) in H.
+  destruct H; auto.
+Qed.
+
+Lemma eqAL_indom_if : forall lc1 lc1' id0,
+  eqAL lc1 lc1' ->
+  id0 `in` dom lc1' ->
+  id0 `in` dom lc1.
+Proof.
+  intros.
+  apply eqAL_indom_iff with (id0:=id0) in H.
+  destruct H; auto.
+Qed.
+
+Lemma eqAL_notindom_iff : forall lc1 lc1' id0,
+  eqAL lc1 lc1' ->
+  (id0 `notin` dom lc1 <-> id0 `notin` dom lc1').
+Proof.
+  intros.
+  split; intro J.
+    apply notin_lookupAL_None in J.
+    rewrite H in J.
+    apply lookupAL_None_notindom in J; auto.
+
+    apply notin_lookupAL_None in J.
+    rewrite <- H in J.
+    apply lookupAL_None_notindom in J; auto.
+Qed.
+
+Lemma eqAL_notindom_onlyif : forall lc1 lc1' id0,
+  eqAL lc1 lc1' ->
+  id0 `notin` dom lc1 ->
+  id0 `notin` dom lc1'.
+Proof.
+  intros.
+  apply eqAL_notindom_iff with (id0:=id0) in H.
+  destruct H; auto.
+Qed.
+
+Lemma eqAL_notindom_if : forall lc1 lc1' id0,
+  eqAL lc1 lc1' ->
+  id0 `notin` dom lc1' ->
+  id0 `notin` dom lc1.
+Proof.
+  intros.
+  apply eqAL_notindom_iff with (id0:=id0) in H.
+  destruct H; auto.
+Qed.
+
+Lemma eqAL_updateAL : forall lc1 lc2 id0 gv0,
+  eqAL lc1 lc2 ->
+  eqAL (updateAL lc1 id0 gv0) (updateAL lc2 id0 gv0).
+Proof.
+  unfold eqAL.
+  intros.
+  assert (J:=H i) .
+  destruct (id0==i); subst.
+    destruct (@AtomSetProperties.In_dec i (dom lc1))
+      as [id0_in_lc1 | id0_notin_lc1].
+      rewrite lookupAL_updateAL_in; auto.
+      rewrite lookupAL_updateAL_in; auto.
+      eapply eqAL_indom_onlyif; eauto.
+
+      rewrite lookupAL_updateAL_notin; auto.
+      rewrite lookupAL_updateAL_notin; auto.
+      eapply eqAL_notindom_onlyif; eauto.
+
+    rewrite <- lookupAL_updateAL_neq; auto.
+    rewrite <- lookupAL_updateAL_neq; auto.
+Qed.
+
+Lemma eqAL_updateAddAL : forall lc1 lc2 id0 gv0,
+  eqAL lc1 lc2 ->
+  eqAL (updateAddAL lc1 id0 gv0) (updateAddAL lc2 id0 gv0).
+Proof.
+  unfold eqAL.
+  intros.
+  assert (J:=H i) .
+  destruct (id0==i); subst.
+    rewrite lookupAL_updateAddAL_eq; auto.
+    rewrite lookupAL_updateAddAL_eq; auto.
+
+    erewrite <- lookupAL_updateAddAL_neq; eauto.
+    erewrite <- lookupAL_updateAddAL_neq; eauto.
+Qed.
+
+Lemma lookupAL_trunc_head : forall i0 l2 l1,
+  i0 `notin` dom l1 ->
+  lookupAL (l1++l2) i0 = lookupAL l2 i0.
+Proof.
+  induction l1 as [|[]]; simpl; intros; auto.
+    destruct (i0 == a); subst.
+      fsetdec.
+      apply IHl1. fsetdec.
+Qed.
+
+Lemma lookupAL_trunc_tail : forall i0 l2 l1,
+  i0 `notin` dom l2 ->
+  lookupAL (l1++l2) i0 = lookupAL l1 i0.
+Proof.
+  induction l1 as [|[]]; simpl; intros.
+    apply notin_lookupAL_None; auto.
+
+    destruct (i0 == a); subst; auto.
+Qed.
+
+Lemma lookupAL_rev_eq : forall i0 l0 (Huniq: uniq l0),
+  lookupAL l0 i0 = lookupAL (rev l0) i0.
+Proof.
+  intros.
+  induction Huniq; auto.
+    simpl.
+    destruct (i0 == x); subst; simpl_env.
+      rewrite dom_rev_eq in H.
+      rewrite lookupAL_trunc_head; simpl; auto.
+      destruct (@eq_dec atom (EqDec_eq_of_EqDec atom EqDec_atom) x x); 
+        try congruence.
+       
+      rewrite lookupAL_trunc_tail; simpl; auto.
+Qed.
+
+Lemma lookupAL_weaken : forall i0 nm1 r nm2 
+  (Hlkup: lookupAL nm1 i0 = Some r),
+  uniq (nm2 ++ nm1) ->
+  lookupAL (nm2 ++ nm1) i0 = Some r.
+Proof.
+  induction nm2 as [|[]]; simpl; intros; auto.
+    destruct (i0 == a); subst.
+      inversion H. subst.
+      apply lookupAL_Some_indom in Hlkup.
+      contradict H4. simpl_env. fsetdec.
+
+      inversion H. subst.
+      apply IHnm2; auto.
+Qed.
+
+Lemma lookupAL_middle_inv: forall i0 a l0,
+  lookupAL l0 i0 = Some a ->
+  exists l1, exists l2, l0 = l1 ++ (i0,a) :: l2.
+Proof.
+  induction l0 as [|[i' gv']]; simpl; intros.
+    congruence.
+
+    destruct (i0 == i'); subst.
+      inversion H; subst. exists nil. exists l0. auto.
+
+      apply IHl0 in H.
+      destruct H as [l1 [l2 H]]; subst.
+      exists ((i', gv')::l1). exists l2. auto.
+Qed.
+
+Lemma lookupAL_middle_inv': forall l0 i0,
+  lookupAL l0 i0 <> None ->
+  exists a, exists l1 : list (atom * X), exists l2 : list (atom * X), 
+    l0 = l1 ++ (i0, a) :: l2.
+Proof.
+  intros.
+  remember (lookupAL l0 i0) as R.
+  destruct R; try congruence.
+  symmetry in HeqR. exists x.
+  apply lookupAL_middle_inv in HeqR; auto.
+Qed.
+
+Lemma In_lookupAL : forall id1 v1 l1,
+  uniq l1 -> In (id1, v1) l1 -> lookupAL l1 id1 = Some v1.
+Proof.
+  induction l1 as [|[id2 v2]]; simpl; intros.
+    match goal with | H: False |- _ => inversion H end.
+
+    destruct_uniq.
+    destruct H0 as [H0 | H0].
+      inversion H0.
+      destruct (id1 == id1); try congruence; auto.
+
+      destruct (id1 == id2); subst; auto.
+      apply In_InDom in H0. contradict H0; auto.      
+Qed.
+
+Lemma lookupAL_in : forall id1 v1 l1 (Hlkup: lookupAL l1 id1 = Some v1), 
+  In (id1, v1) l1.
+Proof.
+  intros.
+  apply lookupAL_middle_inv in Hlkup.
+  destruct Hlkup as [l2 [l3 EQ]]; subst.
+  apply in_or_app. simpl; auto.
+Qed.
+
+End MoreAssocLists.
+
diff -ruN lib/compcert-1.9/AST.v lib.patched/compcert-1.9/AST.v
--- lib/compcert-1.9/AST.v	2014-08-30 20:09:04.806089049 -0400
+++ lib.patched/compcert-1.9/AST.v	2014-08-30 00:29:06.156255495 -0400
@@ -74,23 +74,23 @@
   chunk of memory being accessed. *)
 
 Inductive memory_chunk : Type :=
-  | Mint8signed : memory_chunk     (**r 8-bit signed integer *)
-  | Mint8unsigned : memory_chunk   (**r 8-bit unsigned integer *)
-  | Mint16signed : memory_chunk    (**r 16-bit signed integer *)
-  | Mint16unsigned : memory_chunk  (**r 16-bit unsigned integer *)
-  | Mint32 : memory_chunk          (**r 32-bit integer, or pointer *)
-  | Mfloat32 : memory_chunk        (**r 32-bit single-precision float *)
-  | Mfloat64 : memory_chunk.       (**r 64-bit double-precision float *)
+  | Mint : nat -> memory_chunk  (**r integer or pointer *)
+  | Mfloat32 : memory_chunk     (**r 32-bit single-precision float *)
+  | Mfloat64 : memory_chunk.    (**r 64-bit double-precision float *)
+
+Definition memory_chunk_eq (c1 c2: memory_chunk) : bool :=
+match c1, c2 with
+| Mint n1, Mint n2 => beq_nat n1 n2
+| Mfloat32, Mfloat32 => true
+| Mfloat64, Mfloat64 => true
+| _, _ => false
+end.
 
 (** The type (integer/pointer or float) of a chunk. *)
 
 Definition type_of_chunk (c: memory_chunk) : typ :=
   match c with
-  | Mint8signed => Tint
-  | Mint8unsigned => Tint
-  | Mint16signed => Tint
-  | Mint16unsigned => Tint
-  | Mint32 => Tint
+  | Mint _ => Tint
   | Mfloat32 => Tfloat
   | Mfloat64 => Tfloat
   end.
@@ -98,13 +98,13 @@
 (** Initialization data for global variables. *)
 
 Inductive init_data: Type :=
-  | Init_int8: int -> init_data
-  | Init_int16: int -> init_data
-  | Init_int32: int -> init_data
+  | Init_int8: int32 -> init_data
+  | Init_int16: int32 -> init_data
+  | Init_int32: int32 -> init_data
   | Init_float32: float -> init_data
   | Init_float64: float -> init_data
   | Init_space: Z -> init_data
-  | Init_addrof: ident -> int -> init_data.  (**r address of symbol + offset *)
+  | Init_addrof: ident -> int32 -> init_data.  (**r address of symbol + offset *)
 
 (** Information attached to global variables. *)
 
@@ -397,84 +397,15 @@
 (** * External functions *)
 
 (** For most languages, the functions composing the program are either
-  internal functions, defined within the language, or external functions,
-  defined outside.  External functions include system calls but also
-  compiler built-in functions.  We define a type for external functions
-  and associated operations. *)
-
-Inductive external_function : Type :=
-  | EF_external (name: ident) (sg: signature)
-     (** A system call or library function.  Produces an event
-         in the trace. *)
-  | EF_builtin (name: ident) (sg: signature)
-     (** A compiler built-in function.  Behaves like an external, but
-         can be inlined by the compiler. *)
-  | EF_vload (chunk: memory_chunk)
-     (** A volatile read operation.  If the adress given as first argument
-         points within a volatile global variable, generate an
-         event and return the value found in this event.  Otherwise,
-         produce no event and behave like a regular memory load. *)
-  | EF_vstore (chunk: memory_chunk)
-     (** A volatile store operation.   If the adress given as first argument
-         points within a volatile global variable, generate an event.
-         Otherwise, produce no event and behave like a regular memory store. *)
-  | EF_malloc
-     (** Dynamic memory allocation.  Takes the requested size in bytes
-         as argument; returns a pointer to a fresh block of the given size.
-         Produces no observable event. *)
-  | EF_free
-     (** Dynamic memory deallocation.  Takes a pointer to a block
-         allocated by an [EF_malloc] external call and frees the
-         corresponding block.
-         Produces no observable event. *)
-  | EF_memcpy (sz: Z) (al: Z)
-     (** Block copy, of [sz] bytes, between addresses that are [al]-aligned. *)
-  | EF_annot (text: ident) (targs: list typ)
-     (** A programmer-supplied annotation.  Takes zero, one or several arguments,
-         produces an event carrying the text and the values of these arguments,
-         and returns no value. *)
-  | EF_annot_val (text:ident) (targ: typ).
-     (** Another form of annotation that takes one argument, produces
-         an event carrying the text and the value of this argument,
-         and returns the value of the argument. *)
-
-(** The type signature of an external function. *)
-
-Definition ef_sig (ef: external_function): signature :=
-  match ef with
-  | EF_external name sg => sg
-  | EF_builtin name sg => sg
-  | EF_vload chunk => mksignature (Tint :: nil) (Some (type_of_chunk chunk))
-  | EF_vstore chunk => mksignature (Tint :: type_of_chunk chunk :: nil) None
-  | EF_malloc => mksignature (Tint :: nil) (Some Tint)
-  | EF_free => mksignature (Tint :: nil) None
-  | EF_memcpy sz al => mksignature (Tint :: Tint :: nil) None
-  | EF_annot text targs => mksignature targs None
-  | EF_annot_val text targ => mksignature (targ :: nil) (Some targ)
-  end.
-
-(** Whether an external function should be inlined by the compiler. *)
-
-Definition ef_inline (ef: external_function) : bool :=
-  match ef with
-  | EF_external name sg => false
-  | EF_builtin name sg => true
-  | EF_vload chunk => true
-  | EF_vstore chunk => true
-  | EF_malloc => false
-  | EF_free => false
-  | EF_memcpy sz al => true
-  | EF_annot text targs => true
-  | EF_annot_val text targ => true
-  end.
-
-(** Whether an external function must reload its arguments. *)
-
-Definition ef_reloads (ef: external_function) : bool :=
-  match ef with
-  | EF_annot text targs => false
-  | _ => true
-  end.
+  internal functions, defined within the language, or external functions
+  (a.k.a. system calls) that emit an event when applied.  We define
+  a type for such functions and some generic transformation functions. *)
+
+Record external_function : Type := mkextfun {
+  ef_id: ident;
+  ef_sig: signature;
+  ef_inline: bool
+}.
 
 (** Function definitions are the union of internal and external functions. *)
 
diff -ruN lib/compcert-1.9/Coqlib.v lib.patched/compcert-1.9/Coqlib.v
--- lib/compcert-1.9/Coqlib.v	2014-08-30 20:09:04.806089049 -0400
+++ lib.patched/compcert-1.9/Coqlib.v	2014-08-30 00:29:06.156255495 -0400
@@ -18,10 +18,12 @@
     library. *)
 
 Require Export ZArith.
-Require Export Znumtheory.
+Require Import Znumtheory.
 Require Export List.
 Require Export Bool.
 Require Import Wf_nat.
+Require Import Psatz.
+Require Import CoqListFacts.
 
 (***
 
@@ -39,7 +41,7 @@
 Axiom proof_irrelevance:
   forall (P: Prop) (p1 p2: P), p1 = p2.
 ***)
-  
+
 (** * Useful tactics *)
 
 Ltac inv H := inversion H; clear H; subst.
@@ -106,6 +108,17 @@
  || refine (modusponens _ _ (x _ _) _)
  || refine (modusponens _ _ (x _) _).
 
+Ltac destruct_if :=
+match goal with
+| H: context [(if ?lk then _ else _)] |- _ =>
+   remember lk as R; destruct R; try inv H
+| H: context [if ?lk then _ else _] |- _ =>
+   remember lk as R; destruct R; try inv H
+| |- context [(if ?lk then _ else _)] =>
+   remember lk as R; destruct R; subst; auto
+| |- context [if ?lk then _ else _] => remember lk as R; destruct R; subst; auto
+end.
+
 (** * Definitions and theorems over the type [positive] *)
 
 Definition peq (x y: positive): {x = y} + {x <> y}.
@@ -130,7 +143,7 @@
   intros. case (peq x y); intros.
   elim H; auto.
   auto.
-Qed.  
+Qed.
 
 Definition Plt (x y: positive): Prop := Zlt (Zpos x) (Zpos y).
 
@@ -150,7 +163,7 @@
 Remark Psucc_Zsucc:
   forall (x: positive), Zpos (Psucc x) = Zsucc (Zpos x).
 Proof.
-  intros. rewrite Pplus_one_succ_r. 
+  intros. rewrite Pplus_one_succ_r.
   reflexivity.
 Qed.
 
@@ -171,7 +184,7 @@
 Lemma Plt_succ_inv:
   forall (x y: positive), Plt x (Psucc y) -> Plt x y \/ x = y.
 Proof.
-  intros x y. unfold Plt. rewrite Psucc_Zsucc. 
+  intros x y. unfold Plt. rewrite Psucc_Zsucc.
   intro. assert (A: (Zpos x < Zpos y)%Z \/ Zpos x = Zpos y). omega.
   elim A; intro. left; auto. right; injection H0; auto.
 Qed.
@@ -278,11 +291,11 @@
 Proof.
   intros.
   apply (well_founded_ind Plt_wf P).
-  intros. 
+  intros.
   case (peq x0 xH); intro.
   subst x0; auto.
   elim (Psucc_pred x0); intro. contradiction. rewrite <- H2.
-  apply H0. apply H1. apply Ppred_Plt. auto. 
+  apply H0. apply H1. apply Ppred_Plt. auto.
 Qed.
 
 End POSITIVE_ITERATION.
@@ -305,14 +318,14 @@
   intros. case (zeq x y); intros.
   elim H; auto.
   auto.
-Qed.  
+Qed.
 
 Open Scope Z_scope.
 
 Definition zlt: forall (x y: Z), {x < y} + {x >= y} := Z_lt_ge_dec.
 
 Lemma zlt_true:
-  forall (A: Type) (x y: Z) (a b: A), 
+  forall (A: Type) (x y: Z) (a b: A),
   x < y -> (if zlt x y then a else b) = a.
 Proof.
   intros. case (zlt x y); intros.
@@ -321,7 +334,7 @@
 Qed.
 
 Lemma zlt_false:
-  forall (A: Type) (x y: Z) (a b: A), 
+  forall (A: Type) (x y: Z) (a b: A),
   x >= y -> (if zlt x y then a else b) = b.
 Proof.
   intros. case (zlt x y); intros.
@@ -332,7 +345,7 @@
 Definition zle: forall (x y: Z), {x <= y} + {x > y} := Z_le_gt_dec.
 
 Lemma zle_true:
-  forall (A: Type) (x y: Z) (a b: A), 
+  forall (A: Type) (x y: Z) (a b: A),
   x <= y -> (if zle x y then a else b) = a.
 Proof.
   intros. case (zle x y); intros.
@@ -341,7 +354,7 @@
 Qed.
 
 Lemma zle_false:
-  forall (A: Type) (x y: Z) (a b: A), 
+  forall (A: Type) (x y: Z) (a b: A),
   x > y -> (if zle x y then a else b) = b.
 Proof.
   intros. case (zle x y); intros.
@@ -363,7 +376,7 @@
 Lemma two_power_nat_two_p:
   forall x, two_power_nat x = two_p (Z_of_nat x).
 Proof.
-  induction x. auto. 
+  induction x. auto.
   rewrite two_power_nat_S. rewrite inj_S. rewrite two_p_S. omega. omega.
 Qed.
 
@@ -371,7 +384,7 @@
   forall x y, 0 <= x <= y -> two_p x <= two_p y.
 Proof.
   intros.
-  replace (two_p x) with (two_p x * 1) by omega. 
+  replace (two_p x) with (two_p x * 1) by omega.
   replace y with (x + (y - x)) by omega.
   rewrite two_p_is_exp; try omega.
   apply Zmult_le_compat_l.
@@ -392,7 +405,7 @@
 Proof.
   intros x0 GT. pattern x0. apply natlike_ind.
   simpl. omega.
-  intros. rewrite two_p_S; auto. generalize (two_p_gt_ZERO x H). omega. 
+  intros. rewrite two_p_S; auto. generalize (two_p_gt_ZERO x H). omega.
   omega.
 Qed.
 
@@ -402,7 +415,7 @@
   intros. assert (x = 0 \/ x - 1 >= 0) by omega. destruct H0.
   subst. vm_compute. auto.
   replace (two_p x) with (2 * two_p (x - 1)).
-  generalize (two_p_strict _ H0). omega. 
+  generalize (two_p_strict _ H0). omega.
   rewrite <- two_p_S. decEq. omega. omega.
 Qed.
 
@@ -412,8 +425,8 @@
   forall x y, Zmin x y = if zlt x y then x else y.
 Proof.
   intros. case (zlt x y); unfold Zlt, Zge; intros.
-  unfold Zmin. rewrite z. auto.
-  unfold Zmin. caseEq (x ?= y); intro. 
+  unfold Zmin. rewrite l. auto.
+  unfold Zmin. caseEq (x ?= y); intro.
   apply Zcompare_Eq_eq. auto.
   contradiction.
   reflexivity.
@@ -424,7 +437,7 @@
 Proof.
   intros. case (zlt y x); unfold Zlt, Zge; intros.
   unfold Zmax. rewrite <- (Zcompare_antisym y x).
-  rewrite z. simpl. auto.
+  rewrite l. simpl. auto.
   unfold Zmax. rewrite <- (Zcompare_antisym y x).
   caseEq (y ?= x); intro; simpl.
   symmetry. apply Zcompare_Eq_eq. auto.
@@ -447,21 +460,21 @@
 Lemma Zdiv_small:
   forall x y, 0 <= x < y -> x / y = 0.
 Proof.
-  intros. assert (y > 0). omega. 
+  intros. assert (y > 0). omega.
   assert (forall a b,
     0 <= a < y ->
     0 <= y * b + a < y ->
     b = 0).
-  intros. 
+  intros.
   assert (b = 0 \/ b > 0 \/ (-b) > 0). omega.
   elim H3; intro.
   auto.
   elim H4; intro.
-  assert (y * b >= y * 1). apply Zmult_ge_compat_l. omega. omega. 
-  omegaContradiction. 
+  assert (y * b >= y * 1). apply Zmult_ge_compat_l. omega. omega.
+  omegaContradiction.
   assert (y * (-b) >= y * 1). apply Zmult_ge_compat_l. omega. omega.
   rewrite <- Zopp_mult_distr_r in H6. omegaContradiction.
-  apply H1 with (x mod y). 
+  apply H1 with (x mod y).
   apply Z_mod_lt. auto.
   rewrite <- Z_div_mod_eq. auto. auto.
 Qed.
@@ -470,7 +483,7 @@
   forall x y, 0 <= x < y -> x mod y = x.
 Proof.
   intros. assert (y > 0). omega.
-  generalize (Z_div_mod_eq x y H0). 
+  generalize (Z_div_mod_eq x y H0).
   rewrite (Zdiv_small x y H). omega.
 Qed.
 
@@ -478,7 +491,7 @@
   forall x y a b,
   x = a * y + b -> 0 <= b < y -> x mod y = b.
 Proof.
-  intros. subst x. rewrite Zplus_comm. 
+  intros. subst x. rewrite Zplus_comm.
   rewrite Z_mod_plus. apply Zmod_small. auto. omega.
 Qed.
 
@@ -499,12 +512,12 @@
   generalize (Z_div_mod_eq (a/b) c H0). generalize (Z_mod_lt (a/b) c H0). intros.
   set (q1 := a / b) in *. set (r1 := a mod b) in *.
   set (q2 := q1 / c) in *. set (r2 := q1 mod c) in *.
-  symmetry. apply Zdiv_unique with (r2 * b + r1). 
+  symmetry. apply Zdiv_unique with (r2 * b + r1).
   rewrite H2. rewrite H4. ring.
-  split. 
+  split.
   assert (0 <= r2 * b). apply Zmult_le_0_compat. omega. omega. omega.
   assert ((r2 + 1) * b <= c * b).
-  apply Zmult_le_compat_r. omega. omega. 
+  apply Zmult_le_compat_r. omega. omega.
   replace ((r2 + 1) * b) with (r2 * b + b) in H5 by ring.
   replace (c * b) with (b * c) in H5 by ring.
   omega.
@@ -526,17 +539,17 @@
   lo * b <= a < hi * b ->
   lo <= a/b < hi.
 Proof.
-  intros. 
+  intros.
   generalize (Z_div_mod_eq a b H1). generalize (Z_mod_lt a b H1). intros.
   set (q := a/b) in *. set (r := a mod b) in *.
   split.
   assert (lo < (q + 1)).
-  apply Zmult_lt_reg_r with b. omega.  
-  apply Zle_lt_trans with a. omega. 
+  apply Zmult_lt_reg_r with b. omega.
+  apply Zle_lt_trans with a. omega.
   replace ((q + 1) * b) with (b * q + b) by ring.
   omega.
   omega.
-  apply Zmult_lt_reg_r with b. omega. 
+  apply Zmult_lt_reg_r with b. omega.
   replace (q * b) with (b * q) by ring.
   omega.
 Qed.
@@ -549,7 +562,7 @@
   intros.
   assert (lo <= a / b < hi+1).
   apply Zdiv_interval_1. omega. omega. auto.
-  assert (lo * b <= lo * 1). apply Zmult_le_compat_l_neg. omega. omega. 
+  assert (lo * b <= lo * 1). apply Zmult_le_compat_l_neg. omega. omega.
   replace (lo * 1) with lo in H3 by ring.
   assert ((hi + 1) * 1 <= (hi + 1) * b). apply Zmult_le_compat_l. omega. omega.
   replace ((hi + 1) * 1) with (hi + 1) in H4 by ring.
@@ -562,19 +575,19 @@
   a > 0 -> b > 0 ->
   x mod (a * b) = ((x/b) mod a) * b + (x mod b).
 Proof.
-  intros. 
-  set (xb := x/b). 
+  intros.
+  set (xb := x/b).
   apply Zmod_unique with (xb/a).
   generalize (Z_div_mod_eq x b H0); fold xb; intro EQ1.
   generalize (Z_div_mod_eq xb a H); intro EQ2.
-  rewrite EQ2 in EQ1. 
+  rewrite EQ2 in EQ1.
   eapply trans_eq. eexact EQ1. ring.
-  generalize (Z_mod_lt x b H0). intro. 
+  generalize (Z_mod_lt x b H0). intro.
   generalize (Z_mod_lt xb a H). intro.
   assert (0 <= xb mod a * b <= a * b - b).
     split. apply Zmult_le_0_compat; omega.
     replace (a * b - b) with ((a - 1) * b) by ring.
-    apply Zmult_le_compat; omega. 
+    apply Zmult_le_compat; omega.
   omega.
 Qed.
 
@@ -583,17 +596,17 @@
 Lemma Zdivides_trans:
   forall x y z, (x | y) -> (y | z) -> (x | z).
 Proof.
-  intros. inv H. inv H0. exists (q0 * q). ring.
+  intros. inv H. inv H0. exists (x1 * x0). ring.
 Qed.
 
 Definition Zdivide_dec:
   forall (p q: Z), p > 0 -> { (p|q) } + { ~(p|q) }.
 Proof.
   intros. destruct (zeq (Zmod q p) 0).
-  left. exists (q / p). 
+  left. exists (q / p).
   transitivity (p * (q / p) + (q mod p)). apply Z_div_mod_eq; auto.
   transitivity (p * (q / p)). omega. ring.
-  right; red; intros. elim n. apply Z_div_exact_1; auto. 
+  right; red; intros. elim n. apply Z_div_exact_1; auto.
   inv H0. rewrite Z_div_mult; auto. ring.
 Qed.
 
@@ -606,13 +619,6 @@
   | Zneg p => O
   end.
 
-Lemma nat_of_Z_of_nat:
-  forall n, nat_of_Z (Z_of_nat n) = n.
-Proof.
-  intros. unfold Z_of_nat. destruct n. auto.
-  simpl. rewrite nat_of_P_o_P_of_succ_nat_eq_succ. auto.
-Qed.
-
 Lemma nat_of_Z_max:
   forall z, Z_of_nat (nat_of_Z z) = Zmax z 0.
 Proof.
@@ -637,11 +643,345 @@
   p >= 0 -> q >= 0 ->
   nat_of_Z (p + q) = (nat_of_Z p + nat_of_Z q)%nat.
 Proof.
-  intros. 
+  intros.
   apply inj_eq_rev. rewrite inj_plus.
   repeat rewrite nat_of_Z_eq; auto. omega.
 Qed.
 
+Lemma nat_of_Z_inj_ge : forall a b, (a >= b)%Z ->
+  (nat_of_Z a >= nat_of_Z b)%nat.
+Proof.
+  induction a; destruct b; intros; simpl;
+    try solve [auto | contradict H; auto | omega].
+  apply nat_compare_le.
+  rewrite <- nat_of_P_compare_morphism.
+
+  assert (p >= p0)%positive as J. auto with zarith.
+  unfold Pge in J.
+  remember ((p0 ?= p)%positive) as R.
+  destruct R; try solve [congruence].
+  symmetry in HeqR. apply Pos.compare_nle_iff in HeqR.
+  contradict HeqR.
+  apply Pos.compare_ge_iff in J. auto.
+Qed.
+
+Lemma nat_of_Z_inj_gt : forall a b, (a > b)%Z -> (b >= 0)%Z ->
+  (nat_of_Z a > nat_of_Z b)%nat.
+Proof.
+  induction a; destruct b; intros; simpl;
+    try solve [auto | contradict H; auto | omega].
+
+  assert (J:=@ZL4 p).
+  destruct J as [h J]. rewrite J. omega.
+
+  apply nat_compare_lt.
+  rewrite <- nat_of_P_compare_morphism.
+  assert (p > p0)%positive as J. auto with zarith.
+  unfold Pgt in J.
+  remember ((p ?= p0)%positive) as R.
+  destruct R; try solve [congruence].
+    symmetry in HeqR. apply ZC1 in HeqR. rewrite HeqR. congruence.
+
+  apply Zgt_compare in H. inversion H.
+Qed.
+
+Lemma S_eq_nat_of_P_o_P_of_succ_nat :
+  forall n, S n = nat_of_P (P_of_succ_nat n).
+Proof.
+  induction n; auto.
+    simpl. rewrite nat_of_P_succ_morphism. rewrite IHn. auto.
+Qed.
+
+Lemma Z_of_nat_eq:
+  forall (n:nat), nat_of_Z (Z_of_nat n) = n.
+Proof.
+  induction n; auto.
+    simpl. rewrite <- S_eq_nat_of_P_o_P_of_succ_nat; auto.
+Qed.
+
+Lemma Z_of_Sn_add_z__eq__Z_of_n_add_sz : forall n z,
+  Z_of_nat (S n) + z = Z_of_nat n + Zsucc z.
+Proof.
+  intros. rewrite inj_S. auto with zarith.
+Qed.
+
+Lemma O_lt_Z_of_S : forall n, 0 < Z_of_nat (S n).
+Proof.
+  intros. rewrite <- inj_0. apply inj_lt. omega.
+Qed.
+
+Lemma Z_of_S_gt_O : forall n, Z_of_nat (S n) > 0.
+Proof.
+  intros.
+  assert (J:=@O_lt_Z_of_S n).
+  auto with zarith.
+Qed.
+
+Lemma nat_of_Z_pos:
+  forall n, n > 0 -> (nat_of_Z n > O)%nat.
+Proof.
+  intros.
+  destruct n; unfold Zle; simpl; try omega.
+    assert (J:=@lt_O_nat_of_P p). auto.
+
+    assert (J:=@Zlt_neg_0 p).
+    contradict H; omega.
+Qed.
+
+Lemma nat_of_Z_inj : forall z1 z2,
+  z1 >= 0 ->
+  z2 >= 0 ->
+  nat_of_Z z1 = nat_of_Z z2 ->
+  z1 = z2.
+Proof.
+  induction z1; destruct z2; intros H H0 H1;
+  try solve [
+    auto |
+    assert (J:=@Zlt_neg_0 p); contradict H; omega |
+    assert (J:=@Zlt_neg_0 p0); contradict H0; omega |
+    simpl in H1;
+    assert (J:=@lt_O_nat_of_P p);
+    rewrite <- H1 in J; contradict J; omega
+    ].
+
+    simpl in H1.
+    apply nat_of_P_inj in H1.
+    subst. auto.
+Qed.
+
+Lemma Zpos_P_of_succ_nat_mono : forall m n,
+  (m <= n)%nat ->
+  Zpos (P_of_succ_nat m) <= Zpos (P_of_succ_nat n).
+Proof.
+  induction m; destruct n; simpl; intros; auto with zarith.
+    rewrite Zpos_succ_morphism. simpl.
+    rewrite Zpos_plus_distr.
+    assert (Zpos (P_of_succ_nat n) > 0) as F.
+      auto with zarith.
+    auto with zarith.
+
+    rewrite Zpos_succ_morphism.
+    rewrite Zpos_succ_morphism.
+    unfold Zsucc.
+    assert (Zpos (P_of_succ_nat m) <= Zpos (P_of_succ_nat n)) as J.
+      apply IHm; auto with zarith.
+    auto with zarith.
+Qed.
+
+(** * zdiv zmod *)
+
+Lemma mod_prop1 : forall wz,
+  Z_of_nat (S wz) mod 8 >= 0.
+Proof.
+  intro wz.
+  destruct (Z_mod_lt (Z_of_nat (S wz)) 8);
+    auto with zarith.
+Qed.
+
+Lemma zdiv_zmod_prop1 : forall a1 a2 b,
+  b <> 0 ->
+  a1 / b = a2 / b ->
+  a1 mod b = a2 mod b ->
+  a1 = a2.
+Proof.
+  intros.
+  rewrite (@Z_div_mod_eq_full a1 b H).
+  rewrite (@Z_div_mod_eq_full a2 b H).
+  rewrite H0. rewrite H1.
+  auto.
+Qed.
+
+(** * ZRdiv *)
+
+Definition ZRdiv (a b:Z) : Z :=
+  if zeq (a mod b) 0
+  then a / b
+  else a / b + 1.
+
+Lemma ZRdiv_prop1 : forall a b, b >0 -> b * (ZRdiv a b) >= a.
+Proof.
+  intros. unfold ZRdiv.
+  destruct (zeq (a mod b) 0).
+    rewrite <- Z_div_exact_full_2; auto with zarith.
+
+    rewrite Zmult_plus_distr_r.
+    rewrite (Zmult_comm b 1) .
+    rewrite Zmult_1_l.
+    assert (J:=@Z_mod_lt a b H).
+    assert (J':=@Z_div_mod_eq_full a b).
+    auto with zarith.
+Qed.
+
+Lemma ZRdiv_prop2 : forall a b, a >=0 -> b > 0 -> ZRdiv a b >= 0.
+Proof.
+  intros.
+  unfold ZRdiv.
+  destruct (zeq (a mod b) 0).
+    apply Z_div_ge0; auto.
+    assert (J:=@Z_div_ge0 a b H0 H). auto with zarith.
+Qed.
+
+Lemma Zpos_Zneg_Zmul : forall a b, a > 0 -> b < 0 -> a * b < 0.
+Proof.
+  intros a b Ha Hb.
+  destruct a as [|a|a]; try discriminate.
+  destruct b as [|b|b]; try discriminate.
+  trivial.
+Qed.
+
+Lemma Z_of_nat_ge_0 : forall n, Z_of_nat n >= 0.
+Proof.
+  induction n.
+    simpl. auto with zarith.
+    assert (J:=@Z_of_S_gt_O n). auto with zarith.
+Qed.
+
+Lemma two_power_nat_le_zero : forall n, two_power_nat n >= 0.
+Proof.
+  induction n; simpl.
+    unfold two_power_nat. unfold shift_nat. simpl. auto with zarith.
+    rewrite two_power_nat_S. auto with zarith.
+Qed.
+
+Lemma roundup_is_correct : forall a b, b >0 -> (a + b) / b * b >= a.
+Proof.
+  intros.
+  assert (b<>0). auto with zarith.
+  assert (J:=@Z_div_mod_eq_full (a+b) b H0).
+  assert (b * ((a + b) / b) = a + b - (a + b) mod b) as EQ.
+    auto with zarith.
+  assert (b * ((a + b) / b) = (a + b) / b * b) as EQ'.
+    auto with zarith.
+  rewrite <- EQ'.
+  rewrite EQ.
+  assert (J1:=@Z_mod_lt a b H).
+  assert (J2:=@Z_mod_plus_full a 1 b).
+  rewrite Zmult_1_l in J2.
+  rewrite J2.
+  clear - J1.
+  auto with zarith.
+Qed.
+
+Lemma ZRdiv_prop3 : forall a b, a > 0 -> b > 0 -> ZRdiv a b > 0.
+Proof.
+  intros.
+  unfold ZRdiv.
+  assert (J:=@Z_div_mod_eq a b H0).
+  destruct (zeq (a mod b) 0).
+    rewrite e in J.
+    ring_simplify in J.
+    destruct (a / b).
+      ring_simplify in J.
+      subst. contradict H; auto with zarith.
+
+      auto with zarith.
+      rewrite J in H.
+      assert (Zneg p <0) as Hneg. unfold Zlt. simpl. auto.
+      assert (b * Zneg p < 0) as J'.
+        eapply Zpos_Zneg_Zmul; eauto.
+      contradict J'; auto with zarith.
+
+    assert (a / b >= 0) as J'.
+      eapply Z_div_ge0; eauto with zarith.
+    auto with zarith.
+Qed.
+
+Lemma ZRdiv_prop4 : forall wz,
+  ZRdiv (Z_of_nat (S wz)) 8 >= 0.
+Proof.
+  intro.
+  apply ZRdiv_prop2; try solve [auto with zarith | apply Z_of_S_gt_O].
+Qed.
+
+Lemma ZRdiv_prop5 : forall wz,
+  ZRdiv (Z_of_nat (S wz)) 8 > 0.
+Proof.
+  intro.
+  apply ZRdiv_prop3;try solve [auto with zarith].
+    apply Z_of_S_gt_O.
+Qed.
+
+Lemma ZRdiv_prop6 : forall wz,
+  (nat_of_Z (ZRdiv (Z_of_nat (S wz)) 8) > 0)%nat.
+Proof.
+  intro.
+  apply nat_of_Z_pos.
+  apply ZRdiv_prop5.
+Qed.
+
+Lemma ZRdiv_prop7 : forall z1 z2 (A : z1 <= z2) (C: z1 > 0),
+   (if zeq (z1 mod 8) 0 then z1 / 8 else z1 / 8 + 1) <=
+   (if zeq (z2 mod 8) 0 then z2 / 8 else z2 / 8 + 1).
+Proof.
+  intros.
+  assert (z1 / 8 <= z2 / 8) as B.
+    apply Z_div_le; auto with zarith.
+  destruct (zeq (z1 mod 8) 0).
+    destruct (zeq (z2 mod 8) 0); auto with zarith.
+    destruct (zeq (z2 mod 8) 0); auto with zarith.
+      assert (z1 = 8*(z1/8) + (z1 mod 8)) as Z1.
+        apply Z_div_mod_eq; auto with zarith.
+      assert (z2 = 8*(z2/8) + (z2 mod 8)) as Z2.
+        apply Z_div_mod_eq; auto with zarith.
+      rewrite e in Z2.
+      assert (0 <= z1 mod 8 < 8) as D.
+        apply Z_mod_lt; auto with zarith.
+      destruct (Z_le_dec (z1 / 8 + 1) (z2 / 8)); auto.
+        contradict A.
+        rewrite Z1. rewrite Z2.
+        clear Z1 Z2 e. auto with zarith.
+Qed.
+
+Lemma ZRdiv_prop8 : forall (a c:nat),
+  nat_of_Z (ZRdiv (Z_of_nat (a * 8 * c)) 8) = (a * c)%nat.
+Proof.
+  intros.
+  assert (a * 8 * c = a * c * 8)%nat as J5.
+    rewrite mult_assoc_reverse.
+    assert (8*c = c*8)%nat as EQ. apply mult_comm; auto.
+    rewrite EQ. rewrite mult_assoc. auto.
+  rewrite J5. clear J5.
+  unfold ZRdiv. rewrite inj_mult. rewrite Z_mod_mult. simpl.
+  rewrite Z_div_mult_full; try solve [auto with zarith].
+  rewrite Z_of_nat_eq; auto.
+Qed.
+
+Lemma ZRdiv_prop9 : forall sz1 R4,
+  nat_of_Z (ZRdiv (Z_of_nat (sz1 + R4 * 8)) 8) =
+    (nat_of_Z (ZRdiv (Z_of_nat sz1) 8) + R4)%nat.
+Proof.
+  intros.
+  unfold ZRdiv. rewrite inj_plus. rewrite inj_mult. simpl.
+  rewrite Z_mod_plus; try solve [omega].
+  rewrite Z_div_plus; try solve [omega].
+  assert (Z_of_nat sz1 / 8 >= 0) as G1.
+    apply Z_div_ge0; auto using Z_of_nat_ge_0 with zarith.
+  assert (Z_of_nat R4 >= 0) as G2.
+    apply Z_of_nat_ge_0.
+  destruct (zeq (Z_of_nat sz1 mod 8) 0).
+    rewrite nat_of_Z_plus; auto.
+      rewrite Z_of_nat_eq; auto.
+
+    rewrite nat_of_Z_plus; try solve [omega].
+    rewrite nat_of_Z_plus; try solve [omega].
+    rewrite nat_of_Z_plus; try solve [omega].
+    rewrite Z_of_nat_eq; try solve [omega].
+Qed.
+
+Lemma zrdiv_zmod_prop1 : forall a1 a2 b,
+  b <> 0 ->
+  ZRdiv a1 b = ZRdiv a2 b ->
+  a1 mod b = a2 mod b ->
+  a1 = a2.
+Proof.
+  intros.
+  unfold ZRdiv in H0.
+  rewrite H1 in H0.
+  destruct (zeq (a2 mod b) 0).
+    eapply zdiv_zmod_prop1; eauto.
+    apply zdiv_zmod_prop1 with (b:=b); auto.
+      eauto with zarith.
+Qed.
 
 (** Alignment: [align n amount] returns the smallest multiple of [amount]
   greater than or equal to [n]. *)
@@ -651,9 +991,9 @@
 
 Lemma align_le: forall x y, y > 0 -> x <= align x y.
 Proof.
-  intros. unfold align. 
+  intros. unfold align.
   generalize (Z_div_mod_eq (x + y - 1) y H). intro.
-  replace ((x + y - 1) / y * y) 
+  replace ((x + y - 1) / y * y)
      with ((x + y - 1) - (x + y - 1) mod y).
   generalize (Z_mod_lt (x + y - 1) y H). omega.
   rewrite Zmult_comm. omega.
@@ -661,7 +1001,7 @@
 
 Lemma align_divides: forall x y, y > 0 -> (y | align x y).
 Proof.
-  intros. unfold align. apply Zdivide_factor_l. 
+  intros. unfold align. apply Zdivide_factor_l.
 Qed.
 
 (** * Definitions and theorems on the data types [option], [sum] and [list] *)
@@ -734,14 +1074,14 @@
   list_length_z (hd :: tl) = list_length_z tl + 1.
 Proof.
   intros. unfold list_length_z. simpl.
-  rewrite (list_length_z_aux_shift tl 1 0). omega. 
+  rewrite (list_length_z_aux_shift tl 1 0). omega.
 Qed.
 
 Lemma list_length_z_pos:
   forall (A: Type) (l: list A),
   list_length_z l >= 0.
 Proof.
-  induction l; simpl. unfold list_length_z; simpl. omega. 
+  induction l; simpl. unfold list_length_z; simpl. omega.
   rewrite list_length_z_cons. omega.
 Qed.
 
@@ -750,7 +1090,7 @@
   list_length_z (map f l) = list_length_z l.
 Proof.
   induction l. reflexivity. simpl. repeat rewrite list_length_z_cons. congruence.
-Qed. 
+Qed.
 
 (** Extract the n-th element of a list, as [List.nth_error] does,
     but the index [n] is of type [Z]. *)
@@ -765,7 +1105,7 @@
   forall (A: Type) (l: list A) n x,
   list_nth_z l n = Some x -> In x l.
 Proof.
-  induction l; simpl; intros. 
+  induction l; simpl; intros.
   congruence.
   destruct (zeq n 0). left; congruence. right; eauto.
 Qed.
@@ -787,9 +1127,120 @@
   discriminate.
   rewrite list_length_z_cons. destruct (zeq n 0).
   generalize (list_length_z_pos l); omega.
-  exploit IHl; eauto. unfold Zpred. omega. 
+  exploit IHl; eauto. unfold Zpred. omega.
 Qed.
 
+Section MoreMove. (* copied from dtree.v *)
+
+Variable A: Type.
+Hypothesis Hdec: forall x y : A, {x = y} + {x <> y}.
+
+Lemma remove_length: forall (a: A) (l1: list A),
+  (length (List.remove Hdec a l1) <= length l1)%nat.
+Proof.
+  induction l1; simpl; intros.
+    omega.
+    destruct (Hdec a a0); subst; simpl; omega.
+Qed.
+
+Lemma remove_in_length: forall (a: A) (l1: list A),
+  In a l1 -> (length (List.remove Hdec a l1) < length l1)%nat.
+Proof.
+  induction l1; simpl; intros.
+    inv H.
+
+    destruct H as [H | H]; subst.
+      destruct (Hdec a a); try congruence.
+      assert (J:=@remove_length a l1). omega.
+
+      destruct (Hdec a a0); subst.
+        assert (J:=@remove_length a0 l1). omega.
+        assert (J:=@IHl1 H). simpl. omega.
+Qed.
+
+Lemma remove_neq_in: forall (a b:A) (l1: list A),
+  a <> b ->
+  In a l1 ->
+  In a (List.remove Hdec b l1).
+Proof.
+  induction l1; simpl; intros; auto.
+    destruct H0 as [H0 | H0]; subst.
+      destruct (Hdec b a); subst; simpl; auto.
+        congruence.
+      destruct (Hdec b a0); subst; simpl; auto.
+Qed.
+
+Lemma remove_notin_incl: forall (a : A) (l2 l1 : list A)
+  (Hinc : incl l1 l2) (Hnotin : ~ In a l1),
+  incl l1 (List.remove Hdec a l2).
+Proof.
+  intros. intros x Hin.
+  destruct (Hdec x a); subst.
+    congruence.
+    apply remove_neq_in; auto.
+Qed.
+
+Lemma remove_neq_in': forall (a b:A) (l1: list A),
+  In a (List.remove Hdec b l1) ->
+  In a l1 /\ a <> b.
+Proof.
+  induction l1; simpl; intros; auto.
+    destruct (Hdec b a0); subst; simpl.
+      apply IHl1 in H.
+      destruct H as [H1 H2].
+      split; auto.
+
+      simpl in H.
+      destruct H as [H | H]; subst; auto.
+      apply IHl1 in H.
+      destruct H as [H1 H2].
+      split; auto.
+Qed.
+
+Lemma NoDup_remove: forall x ls2 (Hunip: NoDup ls2),
+  NoDup (List.remove Hdec x ls2).
+Proof.
+  induction 1; simpl.
+    constructor.
+
+    destruct_if.
+      constructor; auto.
+        intro J. apply H.
+        apply remove_neq_in' in J.
+        tauto.
+Qed.
+
+Lemma NoDup_incl_inj_length: forall B f
+  (ls1:list B) (Hnp1: NoDup ls1) (ls2:list A) 
+  (Hincl: forall a1, In a1 ls1 -> exists b1, In b1 ls2 /\ f b1 = Some a1),
+  (length ls1 <= length ls2)%nat.
+Proof.
+  induction 1 as [|a1 ls1]; simpl; intros.
+    omega.
+
+    assert (a1 = a1 \/ In a1 ls1) as Hina1. auto.
+    assert (J:=Hina1).
+    apply Hincl in J.
+    destruct J as [b1 [Hinb1 Hget1]].
+    assert (forall a1, In a1 ls1 -> 
+              exists b1', In b1' (List.remove Hdec b1 ls2) /\ f b1' = Some a1) 
+           as Hinc.
+      intros a2 Hina2'.
+      assert (a1 = a2 \/ In a2 ls1) as Hina2. auto.
+      apply Hincl in Hina2; auto.
+      destruct Hina2 as [b1' [J1 J2]].
+      exists b1'.
+      split; auto.
+        apply remove_neq_in; auto.
+          intro EQ. subst. 
+          rewrite Hget1 in J2. inv J2. auto.
+    apply IHHnp1 in Hinc; auto.
+      apply remove_in_length in Hinb1.
+      omega. 
+Qed.
+
+End MoreMove.
+
 (** Properties of [List.incl] (list inclusion). *)
 
 Lemma incl_cons_inv:
@@ -820,9 +1271,58 @@
   forall (A: Type) (x: A) (l1 l2: list A),
   incl l1 l2 -> incl (x::l1) (x::l2).
 Proof.
-  intros; red; simpl; intros. intuition. 
+  intros; red; simpl; intros. intuition.
 Qed.
 
+Section InclDec.
+
+Variable A:Type.
+Variable Hdec: forall (x y: A), {x = y} + {x <> y}.
+
+Definition incl_dec_prop (n:nat) :=
+  forall (l1 l2:list A), length l1 = n -> {incl l1 l2} + {~ incl l1 l2}.
+
+Lemma incl_dec_aux : forall n, incl_dec_prop n.
+Proof.
+  intro n.
+  apply lt_wf_rec. clear n.
+  intros n H.
+  unfold incl_dec_prop in *.
+  destruct l1; intros l2 Hlength.
+    left. intros x J. inversion J.
+
+    simpl in *.
+    assert (((length (List.remove Hdec a l1)) < n)%nat) as LT.
+      assert (J:=@remove_length A Hdec a l1).
+      omega.
+    destruct (@H (length (List.remove Hdec a l1)) LT
+                (List.remove Hdec a l1) l2) as [J1 | J1]; auto.
+      destruct(@in_dec _ Hdec a l2) as [J2 | J2].
+        left. intros x J. simpl in J.
+        destruct J as [J | J]; subst; auto.
+        destruct (Hdec x a); subst; auto.
+        apply J1.
+        apply remove_neq_in; auto.
+
+        right. intros G. apply J2. apply G; simpl; auto.
+
+      destruct(@in_dec _ Hdec a l2) as [J2 | J2].
+        right. intros G. apply J1. intros x J3. apply G. simpl.
+        destruct (Hdec x a); subst; auto.
+          right. eapply remove_neq_in'; eauto.
+
+        right. intro J. apply J2. apply J. simpl; auto.
+Qed.
+
+Lemma incl_dec : forall (l1 l2:list A), {incl l1 l2} + {~ incl l1 l2}.
+Proof.
+  intros l1.
+  assert (J:=@incl_dec_aux (length l1)).
+  unfold incl_dec_prop in J. eauto.
+Qed.
+
+End InclDec.
+
 (** Properties of [List.map] (mapping a function over a list). *)
 
 Lemma list_map_exten:
@@ -873,9 +1373,9 @@
 Proof.
   induction l; simpl; intros.
   contradiction.
-  elim H; intro. 
+  elim H; intro.
   exists a; intuition auto.
-  generalize (IHl y H0). intros [x [EQ IN]]. 
+  generalize (IHl y H0). intros [x [EQ IN]].
   exists x; tauto.
 Qed.
 
@@ -894,8 +1394,8 @@
 Proof.
   induction m1; simpl; intros.
   exists (@nil A); exists l; auto.
-  destruct l; simpl in H; inv H. 
-  exploit IHm1; eauto. intros [l1 [l2 [P [Q R]]]]. subst l. 
+  destruct l; simpl in H; inv H.
+  exploit IHm1; eauto. intros [l1 [l2 [P [Q R]]]]. subst l.
   exists (a0 :: l1); exists l2; intuition. simpl; congruence.
 Qed.
 
@@ -920,7 +1420,7 @@
   intros. apply in_or_app; simpl. elim (in_app_or _ _ _ H); intro; auto.
 Qed.
 
-(** [list_disjoint l1 l2] holds iff [l1] and [l2] have no elements 
+(** [list_disjoint l1 l2] holds iff [l1] and [l2] have no elements
   in common. *)
 
 Definition list_disjoint (A: Type) (l1 l2: list A) : Prop :=
@@ -930,21 +1430,21 @@
   forall (A: Type) (a: A) (l1 l2: list A),
   list_disjoint (a :: l1) l2 -> list_disjoint l1 l2.
 Proof.
-  unfold list_disjoint; simpl; intros. apply H; tauto. 
+  unfold list_disjoint; simpl; intros. apply H; tauto.
 Qed.
 
 Lemma list_disjoint_cons_right:
   forall (A: Type) (a: A) (l1 l2: list A),
   list_disjoint l1 (a :: l2) -> list_disjoint l1 l2.
 Proof.
-  unfold list_disjoint; simpl; intros. apply H; tauto. 
+  unfold list_disjoint; simpl; intros. apply H; tauto.
 Qed.
 
 Lemma list_disjoint_notin:
   forall (A: Type) (l1 l2: list A) (a: A),
   list_disjoint l1 l2 -> In a l1 -> ~(In a l2).
 Proof.
-  unfold list_disjoint; intros; red; intros. 
+  unfold list_disjoint; intros; red; intros.
   apply H with a a; auto.
 Qed.
 
@@ -952,7 +1452,7 @@
   forall (A: Type) (l1 l2: list A),
   list_disjoint l1 l2 -> list_disjoint l2 l1.
 Proof.
-  unfold list_disjoint; intros. 
+  unfold list_disjoint; intros.
   apply sym_not_equal. apply H; auto.
 Qed.
 
@@ -963,9 +1463,9 @@
   induction l1; intros.
   left; red; intros. elim H.
   case (In_dec eqA_dec a l2); intro.
-  right; red; intro. apply (H a a); auto with coqlib. 
+  right; red; intro. apply (H a a); auto with coqlib.
   case (IHl1 l2); intro.
-  left; red; intros. elim H; intro. 
+  left; red; intros. elim H; intro.
     red; intro; subst a y. contradiction.
     apply l; auto.
   right; red; intros. elim n0. eapply list_disjoint_cons_left; eauto.
@@ -976,6 +1476,15 @@
 Definition list_equiv (A : Type) (l1 l2: list A) : Prop :=
   forall x, In x l1 <-> In x l2.
 
+Lemma list_equiv_nil: forall A (l1:list A) (Heq: list_equiv nil l1), l1 = nil.
+Proof.
+  intros.
+  destruct l1 as [|x l1]; auto.
+  destruct (Heq x) as [_ J1].
+  assert (In x (x::l1)) as J. auto with datatypes v62.
+  apply J1 in J. inv J.
+Qed.
+
 (** [list_norepet l] holds iff the list [l] contains no repetitions,
   i.e. no element occurs twice. *)
 
@@ -992,9 +1501,9 @@
 Proof.
   induction l.
   left; constructor.
-  destruct IHl. 
+  destruct IHl.
   case (In_dec eqA_dec a l); intro.
-  right. red; intro. inversion H. contradiction. 
+  right. red; intro. inversion H. contradiction.
   left. constructor; auto.
   right. red; intro. inversion H. contradiction.
 Defined.
@@ -1010,7 +1519,7 @@
   constructor.
   red; intro. generalize (list_in_map_inv f _ _ H2).
   intros [x [EQ IN]]. generalize EQ. change (f hd <> f x).
-  apply H1. tauto. tauto. 
+  apply H1. tauto. tauto.
   red; intro; subst x. contradiction.
   apply IHlist_norepet. intros. apply H1. tauto. tauto. auto.
 Qed.
@@ -1020,20 +1529,20 @@
   list_norepet (a ++ b) -> list_norepet (b ++ a).
 Proof.
   intro A.
-  assert (forall (x: A) (b: list A) (a: list A), 
-           list_norepet (a ++ b) -> ~(In x a) -> ~(In x b) -> 
+  assert (forall (x: A) (b: list A) (a: list A),
+           list_norepet (a ++ b) -> ~(In x a) -> ~(In x b) ->
            list_norepet (a ++ x :: b)).
     induction a; simpl; intros.
     constructor; auto.
     inversion H. constructor. red; intro.
     elim (in_app_or _ _ _ H6); intro.
     elim H4. apply in_or_app. tauto.
-    elim H7; intro. subst a. elim H0. left. auto. 
+    elim H7; intro. subst a. elim H0. left. auto.
     elim H4. apply in_or_app. tauto.
     auto.
   induction a; simpl; intros.
   rewrite <- app_nil_end. auto.
-  inversion H0. apply H. auto. 
+  inversion H0. apply H. auto.
   red; intro; elim H3. apply in_or_app. tauto.
   red; intro; elim H3. apply in_or_app. tauto.
 Qed.
@@ -1048,10 +1557,10 @@
   tauto.
   inversion H; subst. rewrite IHl1 in H3. rewrite in_app in H2.
   intuition.
-  constructor; auto. red; intros. elim H2; intro. congruence. auto. 
-  destruct H as [B [C D]]. inversion B; subst. 
-  constructor. rewrite in_app. intuition. elim (D a a); auto. apply in_eq. 
-  rewrite IHl1. intuition. red; intros. apply D; auto. apply in_cons; auto. 
+  constructor; auto. red; intros. elim H2; intro. congruence. auto.
+  destruct H as [B [C D]]. inversion B; subst.
+  constructor. rewrite in_app. intuition. elim (D a a); auto. apply in_eq.
+  rewrite IHl1. intuition. red; intros. apply D; auto. apply in_cons; auto.
 Qed.
 
 Lemma list_norepet_append:
@@ -1076,6 +1585,84 @@
   generalize list_norepet_app; firstorder.
 Qed.
 
+Require Import Program.Tactics.
+
+Ltac destruct_in H :=
+match type of H with
+| In _ (_::nil) => simpl in H; destruct H as [H | H]; subst; try tauto
+| In _ (_::_) => simpl in H; destruct H as [H | H]; subst; try tauto
+| In _ (_++_) => apply in_app_or in H; destruct H as [H | H]
+end.
+
+Lemma norepet_equiv__length_eq: forall A (l1:list A)
+  (Huniq1: list_norepet l1) (l2:list A) (Huniq2: list_norepet l2)
+  (Heq: list_equiv l1 l2),
+  (length l1 = length l2)%nat.
+Proof.
+  induction 1; simpl; intros.
+    apply list_equiv_nil in Heq. subst. auto.
+
+    destruct (Heq hd) as [J1 _].
+    assert (In hd (hd::tl)) as J2. auto with datatypes v62.
+    apply J1 in J2.
+    apply in_split in J2.
+    destruct_conjs; subst.
+    rewrite app_length. simpl.
+    rewrite IHHuniq1 with (l2:=J2++H0).
+      rewrite app_length.
+      omega.
+
+      apply list_norepet_append_commut in Huniq2.
+      rewrite <- app_comm_cons in Huniq2.
+      apply list_norepet_append_commut.
+      inv Huniq2; auto.
+
+      apply list_norepet_append_commut in Huniq2.
+      rewrite <- app_comm_cons in Huniq2.
+      destruct_conjs.
+      intro x.
+      destruct (Heq x) as [J1' J2'].
+      split; intro J.
+        assert (Hin: In x (hd::tl)). auto with datatypes v62.
+        apply J1' in Hin.
+        destruct_in Hin; auto with datatypes v62.
+        destruct_in Hin; auto with datatypes v62.
+
+        assert (Hin: In x (J2 ++ hd :: H0)). 
+          destruct_in J; auto with datatypes v62.
+        apply J2' in Hin.
+        destruct_in Hin; auto with datatypes v62.
+        inv Huniq2.
+        elimtype False. apply H3.
+        destruct_in J; auto with datatypes v62.
+Qed.
+
+Lemma norepet_equiv__length_cons_eq: forall A l1 l2 (a:A)
+  (Huniq1: list_norepet l1) (Huniq2: list_norepet l2)
+  (Hnotin: ~ In a l1) (Heq: list_equiv l2 (a::l1)),
+  (length l2 = length l1 + 1)%nat.
+Proof.
+  intros.
+  apply norepet_equiv__length_eq in Heq; auto.
+    simpl in *. omega.
+    constructor; auto.
+Qed.
+
+Lemma incl__length_le: forall A (eq_dec : forall x y : A, {x = y}+{x <> y})
+  (l1:list A) (Huniq: list_norepet l1) (l2:list A) (Hinc: incl l1 l2), 
+  (length l1 <= length l2)%nat.
+Proof.
+  induction 2 as [|hd tl Hnotin Huniq IH]; simpl; intros.
+    auto with datatypes v62.
+
+    assert (incl tl (List.remove eq_dec hd l2)) as Hinc'.
+      apply remove_notin_incl; eauto with datatypes v62.
+    apply IH in Hinc'.
+    assert (length (List.remove eq_dec hd l2) < length l2)%nat as Hle.
+      apply remove_in_length; auto with datatypes v62.
+    omega.
+Qed.
+
 (** [is_tail l1 l2] holds iff [l2] is of the form [l ++ l1] for some [l]. *)
 
 Inductive is_tail (A: Type): list A -> list A -> Prop :=
@@ -1084,6 +1671,48 @@
   | is_tail_cons:
       forall i c1 c2, is_tail c1 c2 -> is_tail c1 (i :: c2).
 
+Lemma is_tail_nil: forall A (l1:list A), is_tail nil l1.
+Proof.
+  induction l1; constructor; auto.
+Qed.
+
+Lemma is_tail_Forall: forall A (l1 l2:list A) P (Hp2: Forall P l2)
+  (Htail: is_tail l1 l2), Forall P l1.
+Proof.
+  induction 2; auto.
+    inv Hp2. auto.
+Qed.
+
+Lemma is_tail_sorted: forall l1 l2 (Hsort: Sorted.Sorted Plt l2)
+  (Histl: is_tail l1 l2), Sorted.Sorted Plt l1.
+Proof.
+  intros.
+  induction Histl; auto.
+    inv Hsort. auto.
+Qed.
+
+Lemma Forall_HdRel: forall A P (x:A) l1 (Hlt : Forall (P x) l1),
+  Sorted.HdRel P x l1.
+Proof.
+  induction 1; simpl; auto.
+Qed.
+
+Lemma Forall_is_tail_HdRel: forall A P (x:A) l1 l2 (Hlt : Forall (P x) l2)
+  (Histl : is_tail l1 l2), Sorted.HdRel P x l1.
+Proof.
+  intros.
+  induction Histl; auto using Forall_HdRel.
+    inv Hlt. auto.
+Qed.
+
+Lemma is_tail_cons_sorted: forall x l1 l2 (Hsort: Sorted.Sorted Plt (x::l2)) 
+  (Hlt : Forall (Plt x) l2) (Histl: is_tail l1 l2), Sorted.Sorted Plt (x :: l1).
+Proof.
+  intros.
+  inv Hsort.
+  constructor; eauto using is_tail_sorted, Forall_is_tail_HdRel.
+Qed.
+
 Lemma is_tail_in:
   forall (A: Type) (i: A) c1 c2, is_tail (i :: c1) c2 -> In i c2.
 Proof.
@@ -1096,7 +1725,7 @@
   forall (A: Type) (i: A) c1 c2, is_tail (i :: c1) c2 -> is_tail c1 c2.
 Proof.
   induction c2; intros; inversion H.
-  constructor. constructor. constructor. auto. 
+  constructor. constructor. constructor. auto.
 Qed.
 
 Hint Resolve is_tail_refl is_tail_cons is_tail_in is_tail_cons_left: coqlib.
@@ -1134,17 +1763,10 @@
 
 Lemma list_forall2_app:
   forall a2 b2 a1 b1,
-  list_forall2 a1 b1 -> list_forall2 a2 b2 -> 
+  list_forall2 a1 b1 -> list_forall2 a2 b2 ->
   list_forall2 (a1 ++ a2) (b1 ++ b2).
 Proof.
-  induction 1; intros; simpl. auto. constructor; auto. 
-Qed.
-
-Lemma list_forall2_length:
-  forall l1 l2,
-  list_forall2 l1 l2 -> length l1 = length l2.
-Proof.
-  induction 1; simpl; congruence.
+  induction 1; intros; simpl. auto. constructor; auto.
 Qed.
 
 End FORALL2.
@@ -1158,10 +1780,131 @@
 Proof.
   induction 1; intros.
   constructor.
-  constructor. auto with coqlib. apply IHlist_forall2; auto. 
+  constructor. auto with coqlib. apply IHlist_forall2; auto.
   intros. auto with coqlib.
 Qed.
 
+Lemma list_forall2_length_eq:
+  forall (A B: Type) (P1: A -> B -> Prop) (l1: list A) (l2: list B),
+  list_forall2 P1 l1 l2 -> length l1 = length l2.
+Proof.
+  induction 1; intros; auto.
+    simpl. congruence.
+Qed.
+
+(** [list_forall3 P [x1 ... xN] [y1 ... yM] [z1 ... zL]] holds iff [N = M = L] 
+  and [P xi yi zi] holds for all [i]. *)
+
+Section FORALL3.
+
+Variable A: Type.
+Variable B: Type.
+Variable C: Type.
+Variable R: A -> B -> C -> Prop.
+
+Inductive Forall3: list A -> list B -> list C -> Prop :=
+ | Forall3_nil : Forall3 nil nil nil
+ | Forall3_cons : forall x y z l l' l'',
+    R x y z -> Forall3 l l' l'' -> Forall3 (x::l) (y::l') (z::l'').
+Hint Constructors Forall3.
+
+Theorem Forall3_refl : Forall3 nil nil nil.
+Proof. auto. Qed.
+
+Theorem Forall3_app_inv_l : forall l1 l2 l' l'',
+  Forall3 (l1 ++ l2) l' l'' ->
+  exists l1', exists l2', exists l1'', exists l2'', 
+    Forall3 l1 l1' l1'' /\ Forall3 l2 l2' l2'' /\ 
+    l' = l1' ++ l2' /\ l'' = l1'' ++ l2''.
+Proof.
+  intros.
+  remember (l1 ++ l2) as l.
+  generalize dependent l1.
+  generalize dependent l2.
+  induction H; intros.
+    symmetry in Heql. apply app_eq_nil in Heql.
+    destruct Heql; subst.
+    exists nil. exists nil. exists nil. exists nil.
+    auto.
+
+    apply cons_eq_app in Heql.
+    destruct Heql as [[eq [J1 J2]] | [J1 J2]]; subst.
+      edestruct IHForall3 as [a [b [c [d [J1 [J2 [J3 J4]]]]]]]; subst; eauto.
+      exists (y::a). exists b. exists (z::c). exists d.
+      rewrite app_comm_cons. simpl. auto.
+
+      destruct (@IHForall3 l nil) as [a [b [c [d [J1 [J2 [J3 J4]]]]]]]; 
+        subst; auto.
+      exists nil. exists (y::a++b). exists nil. exists (z::c++d).
+      auto.
+Qed.
+
+Theorem Forall3_app_inv_m : forall l l1' l2' l'',
+  Forall3 l (l1' ++ l2') l'' ->
+  exists l1, exists l2, exists l1'', exists l2'', 
+    Forall3 l1 l1' l1'' /\ Forall3 l2 l2' l2'' /\ 
+    l = l1 ++ l2 /\ l'' = l1'' ++ l2''.
+Proof.
+  intros.
+  remember (l1' ++ l2') as l'.
+  generalize dependent l1'.
+  generalize dependent l2'.
+  induction H; intros.
+    symmetry in Heql'. apply app_eq_nil in Heql'.
+    destruct Heql'; subst.
+    exists nil. exists nil. exists nil. exists nil.
+    auto.
+
+    apply cons_eq_app in Heql'.
+    destruct Heql' as [[eq [J1 J2]] | [J1 J2]]; subst.
+      edestruct IHForall3 as [a [b [c [d [J1 [J2 [J3 J4]]]]]]]; subst; eauto.
+      exists (x::a). exists b. exists (z::c). exists d.
+      rewrite app_comm_cons. simpl. auto.
+
+      destruct (@IHForall3 l' nil) as [a [b [c [d [J1 [J2 [J3 J4]]]]]]]; 
+        subst; auto.
+      exists nil. exists (x::a++b). exists nil. exists (z::c++d).
+      auto.
+Qed.
+
+Theorem Forall3_app_inv_r : forall l l' l1'' l2'',
+  Forall3 l l' (l1'' ++ l2'') ->
+  exists l1, exists l2, exists l1', exists l2', 
+    Forall3 l1 l1' l1'' /\ Forall3 l2 l2' l2'' /\ 
+    l = l1 ++ l2 /\ l' = l1' ++ l2'.
+Proof.
+  intros.
+  remember (l1'' ++ l2'') as l''.
+  generalize dependent l1''.
+  generalize dependent l2''.
+  induction H; intros.
+    symmetry in Heql''. apply app_eq_nil in Heql''.
+    destruct Heql''; subst.
+    exists nil. exists nil. exists nil. exists nil.
+    auto.
+
+    apply cons_eq_app in Heql''.
+    destruct Heql'' as [[eq [J1 J2]] | [J1 J2]]; subst.
+      edestruct IHForall3 as [a [b [c [d [J1 [J2 [J3 J4]]]]]]]; subst; eauto.
+      exists (x::a). exists b. exists (y::c). exists d.
+      rewrite app_comm_cons. simpl. auto.
+
+      destruct (@IHForall3 l'' nil) as [a [b [c [d [J1 [J2 [J3 J4]]]]]]]; 
+        subst; auto.
+      exists nil. exists (x::a++b). exists nil. exists (y::c++d).
+      auto.
+Qed.
+
+Theorem Forall3_app : forall l1 l2 l1' l2' l1'' l2'',
+  Forall3 l1 l1' l1'' -> Forall3 l2 l2' l2'' -> 
+  Forall3 (l1 ++ l2) (l1' ++ l2') (l1'' ++ l2'').
+Proof.
+  induction 1; intros; auto.
+    repeat rewrite <- app_comm_cons. simpl. auto.
+Qed.
+
+End FORALL3.
+
 (** Dropping the first N elements of a list. *)
 
 Fixpoint list_drop (A: Type) (n: nat) (x: list A) {struct n} : list A :=
@@ -1173,7 +1916,7 @@
 Lemma list_drop_incl:
   forall (A: Type) (x: A) n (l: list A), In x (list_drop n l) -> In x l.
 Proof.
-  induction n; simpl; intros. auto. 
+  induction n; simpl; intros. auto.
   destruct l; auto with coqlib.
 Qed.
 
@@ -1186,9 +1929,9 @@
 
 Lemma list_map_drop:
   forall (A B: Type) (f: A -> B) n (l: list A),
-  list_drop n (map f l) = map f (list_drop n l).
+  list_drop n (List.map f l) = List.map f (list_drop n l).
 Proof.
-  induction n; simpl; intros. auto. 
+  induction n; simpl; intros. auto.
   destruct l; simpl; auto.
 Qed.
 
@@ -1212,6 +1955,13 @@
   induction n; simpl; intros. elim H. destruct H; auto.
 Qed.
 
+(** List misc *)
+Lemma list_with_last_neq_nil: forall (X : Type) (x1 : X) (ls2 : list X),
+  ls2 ++ x1 :: nil  <> nil.
+Proof.
+  induction ls2; simpl; try congruence.
+Qed.
+
 (** * Definitions and theorems over boolean types *)
 
 Definition proj_sumbool (P Q: Prop) (a: {P} + {Q}) : bool :=
@@ -1230,7 +1980,7 @@
 Lemma proj_sumbool_is_true:
   forall (P: Prop) (a: {P}+{~P}), P -> proj_sumbool a = true.
 Proof.
-  intros. unfold proj_sumbool. destruct a. auto. contradiction. 
+  intros. unfold proj_sumbool. destruct a. auto. contradiction.
 Qed.
 
 Section DECIDABLE_EQUALITY.
@@ -1258,7 +2008,7 @@
   (if dec_eq x y then ifso else ifnot) =
   (if dec_eq y x then ifso else ifnot).
 Proof.
-  intros. destruct (dec_eq x y). 
+  intros. destruct (dec_eq x y).
   subst y. rewrite dec_eq_true. auto.
   rewrite dec_eq_false; auto.
 Qed.
@@ -1285,46 +2035,1526 @@
 
 End DECIDABLE_PREDICATE.
 
-(** * Well-founded orderings *)
+(***********************************************************************)
 
-Require Import Relations.
+Section Sublist.
 
-(** A non-dependent version of lexicographic ordering. *)
+Variables X : Type.
 
-Section LEX_ORDER.
+Inductive sublist : list X -> list X -> Prop :=
+| sl_nil : forall (l : list X), sublist nil l
+| sl_cons : forall (l1 l2 : list X) (x : X),
+  sublist l1 l2 -> sublist (x :: l1) (x :: l2)
+| sl_cons_r : forall (l1 l2 : list X) (x : X),
+  sublist l1 l2 -> sublist l1 (x :: l2).
 
-Variable A: Type.
-Variable B: Type.
-Variable ordA: A -> A -> Prop.
-Variable ordB: B -> B -> Prop.
+Theorem sublist_refl : forall l : list X, sublist l l.
+Proof.
+  intros l. induction l as [|x l]. apply sl_nil.
+  apply sl_cons. trivial.
+Qed.
+
+Hint Resolve sublist_refl.
+
+Theorem sublist_app_r : forall (l1 l2 l2' : list X),
+  sublist l1 l2 -> sublist l1 (l2' ++ l2).
+Proof.
+  intros l1 l2 l2' H. induction l2' as [|x l2'];
+  [|apply sl_cons_r]; trivial.
+Qed.
 
-Inductive lex_ord: A*B -> A*B -> Prop :=
-  | lex_ord_left: forall a1 b1 a2 b2,
-      ordA a1 a2 -> lex_ord (a1,b1) (a2,b2)
-  | lex_ord_right: forall a b1 b2,
-      ordB b1 b2 -> lex_ord (a,b1) (a,b2).
-
-Lemma wf_lex_ord: 
-  well_founded ordA -> well_founded ordB -> well_founded lex_ord.
-Proof.
-  intros Awf Bwf.
-  assert (forall a, Acc ordA a -> forall b, Acc ordB b -> Acc lex_ord (a, b)).
-    induction 1. induction 1. constructor; intros. inv H3.
-    apply H0. auto. apply Bwf.
-    apply H2; auto. 
-  red; intros. destruct a as [a b]. apply H; auto.
-Qed.
-
-Lemma transitive_lex_ord:
-  transitive _ ordA -> transitive _ ordB -> transitive _ lex_ord.
-Proof.
-  intros trA trB; red; intros. 
-  inv H; inv H0. 
-  left; eapply trA; eauto.
-  left; auto.
-  left; auto.
-  right; eapply trB; eauto.
+Theorem sublist_cons_weaken : forall (l1 l2 : list X) (x : X),
+  sublist (x :: l1) l2 -> sublist l1 l2.
+Proof.
+  intros l1 l2 x H.
+  remember (x :: l1) as l1'.
+  induction H as [|l1' l2' x' H|l1' l2' x' H]. discriminate.
+  apply sl_cons_r. inversion Heql1'. subst. trivial.
+  apply sl_cons_r. apply IHH. trivial.
+Qed.
+
+Theorem sublist_app : forall (l1 l1' l2 l2' : list X),
+  sublist l1 l2 -> sublist l1' l2' ->
+  sublist (l1 ++ l1') (l2 ++ l2').
+Proof.
+  intros l1 l1' l2 l2' H1 H2. induction H1 as [l2|l1 l2 x H1|l1 l2 x H1];
+  [apply sublist_app_r|apply sl_cons|apply sl_cons_r]; trivial.
+Qed.
+
+Theorem sublist_In : forall (l1 l2 : list X),
+  sublist l1 l2 -> forall x : X, In x l1 -> In x l2.
+Proof.
+  intros l1 l2 Hl1l2.
+  induction Hl1l2 as [|l1 l2 x Hl1l2|l1 l2 x Hl1l2].
+  intros x contra. inversion contra.
+  intros y H. inversion H; [left | right; apply IHHl1l2]; trivial.
+  intros y H. right. apply IHHl1l2. trivial.
 Qed.
 
-End LEX_ORDER.
+Theorem NoDup_sublist : forall (l1 l2 : list X),
+  NoDup l1 -> sublist l2 l1 -> NoDup l2.
+Proof.
+  intros l1 l2 Hl1 Hl1l2.
+  generalize dependent l2. induction Hl1 as [|x l1 Hxl1]; intros l2 Hl1l2.
+  inversion Hl1l2. constructor.
+  destruct l2 as [|y l2]. apply NoDup_nil.
+  inversion Hl1l2 as [|l1' l2' x' Hsub|l1' l2' x' Hsub]; subst.
+    apply NoDup_cons. contradict Hxl1. apply sublist_In with l2; trivial.
+    apply IHHl1. trivial.
+  apply IHHl1. trivial.
+Qed.
+
+Theorem filter_sublist : forall (test : X -> bool) (l : list X),
+  sublist (filter test l) l.
+Proof.
+  intros test l. induction l as [|x l]. apply sl_nil.
+  simpl. destruct (test x). apply sl_cons. trivial.
+  apply sl_cons_r. trivial.
+Qed.
+
+Require Import Coq.Program.Equality.
+
+Theorem sublist_split : forall (l1 l2: list X) l12'
+  (H: sublist (l1++l2) l12'), 
+  exists l1', exists l2', 
+    l12' = l1' ++ l2' /\ sublist l1 l1' /\ sublist l2 l2'.
+Proof.
+  intros.
+  dependent induction H; simpl; intros.
+    symmetry in x. apply app_eq_nil in x; destruct x; subst.
+    exists nil. exists l. repeat (split; try solve [constructor | auto]).
+
+    destruct l1 as [|x1 l1]; simpl in x; inv x.
+      exists nil. exists (x0::l0).
+      repeat (split; try solve [constructor; auto | auto]).
+
+      destruct (IHsublist l2 l1) as [l1' [l2' [EQ [Hsub1 Hsub2]]]]; subst; auto.
+      exists (x1::l1'). exists l2'.
+      repeat (split; try solve [constructor; auto | auto]).
+
+    destruct IHsublist as [l1' [l2' [EQ [Hsub1 Hsub2]]]]; subst; auto.
+    exists (x::l1'). exists l2'.
+    repeat (split; try solve [constructor; auto | auto]).
+Qed.
+ 
+Theorem sublist_cons_inv : forall a1 (l2: list X) l12'
+  (H: sublist (a1::l2) l12'), 
+  exists l1', exists l2', 
+    l12' = l1' ++ l2' /\ sublist (a1::nil) l1' /\ sublist l2 l2'.
+Proof.
+  intros. apply sublist_split. simpl. auto.
+Qed.
+
+Theorem sublist_cons : forall a1 (l1' l2' l2: list X)
+  (H1: sublist (a1::nil) l1') (H2: sublist l2 l2'),
+  sublist (a1::l2) (l1' ++ l2').
+Proof.
+  intros. apply sublist_app with (l1:=a1::nil)(l2:=l1') in H2; auto. 
+Qed.
+
+Theorem sublist_trans : forall (l1 l2: list X)
+  (H12: sublist l1 l2) l3 (H23: sublist l2 l3), sublist l1 l3.
+Proof.
+  induction 1; simpl; intros; try constructor.
+    apply sublist_cons_inv in H23.
+    destruct H23 as [l1' [l2' [EQ [H1' H2']]]]; subst.
+    apply sublist_cons; auto.
+
+    apply sublist_cons_weaken in H23. auto.
+Qed.
+
+Lemma sublist_Forall: forall (l1 l2:list X) P (Hp2: Forall P l2)
+  (Htail: sublist l1 l2), Forall P l1.
+Proof.
+  induction 2; try solve [auto | inv Hp2; auto].
+Qed.
+
+Lemma sublist_StronglySorted: forall R l1 l2 (Hsort: Sorted.StronglySorted R l2)
+  (Histl: sublist l1 l2), Sorted.StronglySorted R l1.
+Proof.
+  intros.
+  induction Histl.
+    constructor.
+
+    inv Hsort. 
+    constructor; eauto using sublist_Forall.
+
+    inv Hsort. auto.
+Qed.
+
+Lemma sublist_sorted: forall R (Htrans: Relations_1.Transitive R) l1 l2 
+  (Hsort: Sorted.Sorted R l2)
+  (Histl: sublist l1 l2), Sorted.Sorted R l1.
+Proof.
+  intros.
+  apply Sorted.Sorted_StronglySorted in Hsort; auto.
+  apply Sorted.StronglySorted_Sorted.
+  eapply sublist_StronglySorted; eauto.
+Qed.
+
+Lemma sublist_cons_sorted: forall x l1 l2 R (Htrans: Relations_1.Transitive R) 
+  (Hsort: Sorted.Sorted R (x::l2)) (Hlt : Forall (R x) l2) 
+  (Histl: sublist l1 l2), 
+  Sorted.Sorted R (x :: l1).
+Proof.
+  intros.
+  inv Hsort.
+  constructor; eauto using sublist_sorted, Forall_HdRel, sublist_Forall. 
+Qed.
+
+Lemma sublist_cons': forall x l1 l2 (H : sublist l1 l2),
+  sublist (x :: l1) (x :: l2).
+Proof.
+  intros.
+  apply sublist_app with (l1:=x::nil) (l2:=x::nil) in H; auto. 
+Qed.
+
+Lemma sublist_append_false: forall (ls1 ls2:list X)
+  (Hsub: sublist (ls2 ++ ls1) ls1) (Hneq: ls2 <> nil), False.
+Proof.
+  intros.
+  dependent induction Hsub.
+    destruct ls2; inv x; auto.
+     
+    destruct ls2; try congruence.
+    inv x. 
+    apply IHHsub with (ls3:=ls2++x1::nil).
+      rewrite <- app_assoc. simpl. auto.
+      apply list_with_last_neq_nil.
+
+    apply IHHsub with (ls3:=ls2++x::nil).
+      rewrite <- app_assoc. simpl. auto.
+      apply list_with_last_neq_nil.
+Qed.
+
+Lemma sublist_cons_false: forall (a:X) (ls1:list X)
+  (Hsub: sublist (a :: ls1) ls1), False.
+Proof.
+  intros.
+  change (a::ls1) with ((a::nil)++ls1) in Hsub; auto.
+  apply sublist_append_false in Hsub; auto.
+    intro J. inv J.
+Qed.
+
+Variable Hdec: forall (x y:X), {x = y} + {x <> y}.
+
+Lemma sublist__eq_or_exact: forall (l1 l2:list X) (Htail: sublist l1 l2)
+  (Hnodup: NoDup l2),
+  l1 = l2 \/ (exists a, In a l2 /\ ~ In a l1).
+Proof.
+  induction 1; intros.
+    destruct l; auto.
+      right. exists x; simpl; auto.
+
+    inv Hnodup.
+    destruct IHHtail as [IHHtail | [a [J1 J2]]]; subst; auto.
+      right. exists a. simpl.
+      split; auto.
+        intro J.
+        destruct J as [J | J]; subst; auto.
+
+    inv Hnodup. 
+    destruct IHHtail as [IHHtail | [a [J1 J2]]]; subst; auto.
+      right. exists x. simpl. split; auto.
+
+      right. exists a. simpl. 
+      split; auto.
+Qed.
+
+Lemma sublist_length: forall (l1 l2:list X) (Htail: sublist l1 l2), 
+  (length l1 <= length l2)%nat.
+Proof.
+  induction 1; simpl; try omega.
+Qed.
+
+Lemma sublist_antisymm: forall (l1 l2:list X) (Htail: sublist l1 l2)
+  (Htail': sublist l2 l1), l1 = l2.
+Proof.
+  induction 1; simpl; intros.
+    inv Htail'; auto.
+
+    inv Htail'; auto.
+      rewrite IHHtail; auto.
+
+      apply sublist_length in Htail.
+      apply sublist_length in H1. simpl in *.
+      contradict Htail. omega.
+
+    apply sublist_length in Htail.
+    apply sublist_length in Htail'. simpl in *.
+    contradict Htail. omega.
+Qed.
+
+Lemma sublist_remove: forall a 
+  (l1 l2:list X) (Htail: sublist l1 l2)
+  (Hnotin: ~ In a l1), 
+  sublist l1 (List.remove Hdec a l2).
+Proof.
+  induction 1; simpl; intros.
+    constructor.
+
+    destruct_if.
+      contradict Hnotin; auto.
+      constructor; auto.
+
+    destruct_if.
+      constructor; auto.
+Qed.
+
+Lemma exact_sublist_length: forall (l1 l2:list X) (Htail: sublist l1 l2)
+  (Hex: exists a, In a l2 /\ ~ In a l1), 
+  (length l1 < length l2)%nat.
+Proof.
+  induction 1; simpl; intros.
+    destruct Hex as [a [J1 J2]].
+    destruct l; simpl; try solve [omega | tauto].
+
+    destruct Hex as [a [[J1 | J1] J2]]; subst.
+      contradict J2; auto.
+      eapply sublist_remove in Htail; eauto.
+      apply sublist_length in Htail.
+      apply remove_in_length with (Hdec:=Hdec) in J1; auto.
+      omega.
+
+    apply sublist_length in Htail. omega.
+Qed.
+
+End Sublist.
+
+Implicit Arguments sublist [[X]].
+
+Hint Resolve sublist_refl sublist_trans sublist_app sublist_cons_weaken
+             sublist_app_r sublist_Forall sublist_cons sublist_cons' sublist_In 
+             : sublist.
+
+Theorem sublist_map : forall (X Y : Type) (f : X -> Y) (l1 l2 : list X),
+  sublist l1 l2 -> sublist (List.map f l1) (List.map f l2).
+Proof.
+  intros X Y f l1 l2 H. induction H as [|l1 l2 x H|l1 l2 x H];
+  [apply sl_nil|apply sl_cons|apply sl_cons_r]; trivial.
+Qed.
+
+Require Import ListSet.
+
+(*********** NoDup *************)
+
+Section NoDup_More.
+
+Lemma Plt_StronglySorted_NoDup: forall sds (Hsrt: Sorted.StronglySorted Plt sds), 
+  NoDup sds.
+Proof.
+  induction 1.
+    constructor.
+
+    constructor; auto.
+      intro Hin.
+      eapply Forall_forall in Hin; eauto.
+      inv Hin. rewrite Pos.compare_refl in H1. inversion H1. 
+Qed.
+
+Variable A:Type.
+Variable Hdec: forall x y : A, {x = y} + {x <> y}.
+
+Lemma NoDup_remove_notin_length: forall
+  a ls2 (Hndp2 : NoDup ls2) (Hin : ~ In a ls2),
+  (length (List.remove Hdec a ls2)) = length ls2.
+Proof.
+  induction 1; simpl; intros; auto.
+    destruct_if.
+      contradict Hin. simpl. constructor. reflexivity.
+
+      simpl. 
+      rewrite IHHndp2; auto.
+Qed.
+
+Lemma NoDup_remove_in_length: forall a ls2 (Hndp2 : NoDup ls2)
+  (Hin : In a ls2),
+  S (length (List.remove Hdec a ls2)) = length ls2.
+Proof.
+  induction 1; simpl; intros.
+    inv Hin.
+
+    destruct_if.
+      rewrite NoDup_remove_notin_length; auto.
+      simpl. rewrite IHHndp2; auto.
+        inv Hin; auto.
+          congruence.
+Qed.
+  
+(* go to *)
+Lemma NoDup_incl_length: forall (ls1:list A) (Hnp1: NoDup ls1) ls2
+  (Hnp2: NoDup ls2) (Hincl: incl ls1 ls2),
+  (length ls1 <= length ls2)%nat.
+Proof.
+  induction 1 as [|a1 ls1]; simpl; intros.
+    omega.
+
+    assert (incl ls1 (List.remove Hdec a1 ls2)) as Hinc.
+      apply remove_notin_incl; auto.
+        eauto with datatypes v62.
+    apply IHHnp1 in Hinc; auto.
+      assert (In a1 ls2) as Hin. 
+        eauto with datatypes v62.
+      apply remove_in_length with (Hdec:=Hdec) in Hin.
+      omega. 
+
+      apply NoDup_remove; auto.
+Qed.
+
+Lemma NoDup_exact_incl_length: forall (ls1:list A) (Hnp1: NoDup ls1) ls2
+  (Hnp2: NoDup ls2) 
+  (Hincl: incl ls1 ls2) (Hex: exists a, In a ls2 /\ ~ In a ls1),
+  (length ls1 < length ls2)%nat.
+Proof.
+  intros.
+  destruct Hex as [a [Hin Hnotin]].
+  assert (incl ls1 (List.remove Hdec a ls2)) as Hinc.
+    apply remove_notin_incl; auto.
+  apply NoDup_incl_length in Hinc; auto.
+    apply NoDup_remove_in_length in Hin; auto.
+    omega.
+
+    apply NoDup_remove; auto.
+Qed.
+
+End NoDup_More.
+
+(*********** Redundancy *************)
+
+Section RemoveRedundant.
+
+Variable A:Type.
+Variable Hdec: forall x y : A, {x = y} + {x <> y}.
+
+Fixpoint remove_redundant (input: list A) : list A :=
+match input with
+| a :: ((b :: _) as input') =>
+    if (Hdec a b) then remove_redundant input'
+    else a :: remove_redundant input'
+| _ => input
+end.
+
+Lemma remove_redundant_safe: forall l0 input,
+  In l0 (remove_redundant input) <-> In l0 input.
+Proof.
+  induction input as [|a input]; simpl.
+    split; auto.
+
+    destruct input as [|a0 input].
+      simpl. split; auto.
+
+      destruct IHinput as [J1 J2].
+      destruct (Hdec a a0); subst.
+        split; intros.
+          apply J1 in H.
+            simpl in H. simpl.
+            destruct H; auto.
+
+          apply J2.
+            simpl in H. simpl.
+            destruct H as [H | [H | H]]; auto.
+
+        split; intros.
+          Local Opaque remove_redundant.
+          simpl in H.
+          destruct H as [H | H]; auto.
+
+          simpl.
+          destruct H as [H | H]; auto.
+          Transparent remove_redundant.
+Qed.
+
+Lemma remove_redundant_HdRel: forall R a input,
+  Sorted.HdRel R a input ->
+  Sorted.HdRel R a (remove_redundant input).
+Proof.
+  induction input as [|a1 input]; simpl; intros; auto.
+    destruct input as [|a2 input]; auto.
+      inv H.
+      destruct (Hdec a1 a2); subst.
+        apply IHinput. apply Sorted.HdRel_cons; auto.
+        apply Sorted.HdRel_cons; auto.
+Qed.
+
+Lemma remove_redundant_In: forall a input,
+  In a (remove_redundant input) -> In a input.
+Proof.
+  intros. eapply remove_redundant_safe; eauto.
+Qed.
+
+Lemma remove_redundant_sorted: forall R input,
+  Sorted.Sorted R input -> Sorted.Sorted R (remove_redundant input).
+Proof.
+  induction input as [|a1 input]; intros; simpl; auto.
+    destruct input as [|a2 input]; auto.
+      inv H.
+      apply IHinput in H2.
+      destruct (Hdec a1 a2); subst; auto.
+        apply Sorted.Sorted_cons; auto.
+          apply remove_redundant_HdRel; auto.
+Qed.
+
+Lemma remove_redundant_NoDup: forall (R:A -> A -> Prop) input
+  (P0:forall a b c,
+        In a input ->
+        In b input ->
+        In c input -> a <> b -> R a b -> R b c -> a <> c),
+  Sorted.StronglySorted R input ->
+  NoDup (remove_redundant input).
+Proof.
+  induction input as [|a1 input]; intros; simpl.
+    constructor.
+    destruct input as [|a2 input].
+      constructor; auto.
+        constructor.
+
+      inv H.
+      assert (H2':=H2).
+      apply IHinput in H2.
+        destruct (Hdec a1 a2); subst; auto.
+          apply NoDup_cons; auto.
+          intro J.
+          apply remove_redundant_In in J.
+          simpl in J.
+          destruct J as [J | J]; subst.
+            congruence.
+
+            eapply Forall_forall with (x:=a2) in H3; simpl; eauto.
+            inv H2'.
+            eapply Forall_forall with (x:=a1) in H4; eauto.
+            apply P0 with (c:=a1) in H3; simpl; auto.
+
+        intros. apply P0 with (b:=b); simpl; auto.
+Qed.
+
+Lemma remove_redundant_NoDup': forall R input
+  (P0:forall a, In a input -> ~ R a a),
+  Sorted.StronglySorted R input ->
+  NoDup (remove_redundant input).
+Proof.
+  induction input as [|a1 input]; intros; simpl.
+    constructor.
+    destruct input as [|a2 input].
+      constructor; auto.
+        constructor.
+
+      inv H.
+      apply IHinput in H2.
+        destruct (Hdec a1 a2); subst; auto.
+          apply NoDup_cons; auto.
+          intro J.
+          apply remove_redundant_In in J.
+          eapply Forall_forall in H3; eauto.
+          revert H3. apply P0. simpl. auto.
+        intros. apply P0. simpl. simpl in H.
+        destruct H; auto.
+Qed.
+
+End RemoveRedundant.
+
+Section RemoveRedundancy.
+
+Variable A:Type.
+Variable Hdec: forall x y : A, {x = y} + {x <> y}.
+
+Fixpoint remove_redundancy (acc:list A) (vs:list A) : list A :=
+match vs with
+| nil => acc
+| v::vs' => 
+    if (in_dec Hdec v acc) then remove_redundancy acc vs'
+    else remove_redundancy (v::acc) vs'
+end.
+
+Lemma remove_redundancy_spec_aux: forall vs acc re
+  (Hred: re = remove_redundancy acc vs) 
+  (Hnodup: NoDup acc),
+  (forall v0, (In v0 vs \/ In v0 acc) <-> In v0 re) /\
+  NoDup re.
+Proof.
+  intros.
+  generalize dependent acc.
+  generalize dependent re.
+  induction vs as [|v vs]; simpl; intros; subst.
+    tauto.
+
+    destruct_if.
+      assert (J:=Hnodup).
+      eapply IHvs in J; eauto.
+      destruct J as [J1 J2].
+      symmetry in HeqR.
+      split; auto.
+        intro v0.
+        split; intro J.
+          apply J1. 
+          destruct J as [J | J]; auto.
+          destruct J as [J | J]; subst; auto.
+
+          apply J1 in J. tauto.
+
+      assert (NoDup (v::acc)) as Hnodup'.
+        constructor; auto.
+      assert (J:=Hnodup').
+      eapply IHvs with (acc:=v::acc) in J; eauto.
+      destruct J as [J1 J2].
+      split; auto.
+        intro v0.
+        split; intro J.
+          apply J1. simpl. tauto.
+
+          apply J1 in J. simpl in J. tauto.
+Qed.
+
+Lemma remove_redundancy_spec: forall vs vs'
+  (Hred: vs' = remove_redundancy nil vs),
+  (forall v0, In v0 vs <-> In v0 vs') /\
+  NoDup vs'.
+Proof.
+  intros.
+  apply remove_redundancy_spec_aux in Hred; simpl; try solve [constructor].
+  destruct Hred as [J1 J2].
+  split; auto.
+    intros v0.  
+    destruct (J1 v0) as [J3 J4].
+    split; auto.
+      intro J.
+      apply J4 in J. destruct J; auto. inv H.
+Qed.
+
+Lemma remove_redundancy_in: forall vs,
+  (forall v0, In v0 vs <-> In v0 (remove_redundancy nil vs)).
+Proof.
+  intros.
+  assert (remove_redundancy nil vs = remove_redundancy nil vs) as EQ.
+    auto.
+  apply remove_redundancy_spec in EQ. destruct EQ; auto.
+Qed.
+
+Lemma remove_redundancy_NoDup: forall vs, NoDup (remove_redundancy nil vs).
+Proof.
+  intros.
+  assert (remove_redundancy nil vs = remove_redundancy nil vs) as EQ.
+    auto.
+  apply remove_redundancy_spec in EQ. destruct EQ; auto.
+Qed.
+
+(* The elemens in ATree, and remove_redundancy in mem2reg is similar to this,
+   how to merge them? *)
+End RemoveRedundancy.
+
+Implicit Arguments remove_redundancy [A].
+
+(***********************************************************************)
+
+Module AtomSet. Section AtomSet.
+
+  Variable A:Type.
+  Variable Hdec: forall x y : A, {x = y} + {x <> y}.
+
+  Definition set_eq (l1 l2:list A) := incl l1 l2 /\ incl l2 l1.
+
+  Lemma set_eq_dec : forall (l1 l2:set A),
+    {set_eq l1 l2} + {~ set_eq l1 l2}.
+  Proof.
+    intros l1 l2.
+    destruct (incl_dec Hdec l1 l2) as [J | J].
+      destruct (incl_dec Hdec l2 l1) as [J' | J'].
+        left. split; auto.
+        right. intro G. destruct G as [G1 G2]. auto.
+      destruct (incl_dec Hdec l2 l1) as [J' | J'].
+        right. intro G. destruct G as [G1 G2]. auto.
+        right. intro G. destruct G as [G1 G2]. auto.
+  Qed.
+
+  Lemma set_eq_app : forall x1 x2 y1 y2,
+    set_eq x1 y1 -> set_eq x2 y2 -> set_eq (x1++x2) (y1++y2).
+  Proof.
+    intros x1 x2 y1 y2 [Hinc11 Hinc12] [Hinc21 Hinc22].
+    split.
+      apply incl_app.
+        apply incl_appl; auto.
+        apply incl_appr; auto.
+      apply incl_app.
+        apply incl_appl; auto.
+        apply incl_appr; auto.
+  Qed.
+
+  Lemma set_eq_swap : forall x1 x2,
+    set_eq (x1++x2) (x2++x1).
+  Proof.
+    intros x1 x2.
+    split.
+      apply incl_app.
+        apply incl_appr; auto using incl_refl.
+        apply incl_appl; auto using incl_refl.
+      apply incl_app.
+        apply incl_appr; auto using incl_refl.
+        apply incl_appl; auto using incl_refl.
+  Qed.
+
+  Lemma set_eq__rewrite_env : forall x1 x2 x3 y1 y2 y3,
+    set_eq ((x1 ++ x2) ++ x3) ((y1 ++ y2) ++ y3) ->
+    set_eq (x1 ++ x2 ++ x3) (y1 ++ y2 ++ y3).
+  Proof.
+    intros.
+    repeat rewrite <- app_assoc in H. auto.
+  Qed.
+
+  Lemma set_eq_refl : forall x, set_eq x x.
+    split; apply incl_refl.
+  Qed.
+
+  Lemma set_eq_sym: forall x y, set_eq x y -> set_eq y x.
+  Proof.
+    intros x y J.
+    destruct J as [J1 J2]. split; auto.
+  Qed.
+
+  Lemma set_eq_trans: forall x y z,
+    set_eq x y -> set_eq y z -> set_eq x z.
+  Proof.
+    intros x y z J1 J2.
+    destruct J1 as [J11 J12].
+    destruct J2 as [J21 J22].
+    split; eapply incl_tran; eauto.
+  Qed.
+
+  Lemma incl_empty_inv : forall x,
+    incl x (empty_set _) -> x = empty_set A.
+  Proof.
+    destruct x; intro J; auto.
+      assert (J1:=J a).
+      contradict J1; simpl; auto.
+  Qed.
+
+  Lemma set_eq_empty_inv : forall x,
+    set_eq x (empty_set _) -> x = empty_set _.
+  Proof.
+    destruct x; intro J; auto.
+      destruct J as [J1 J2].
+      assert (J:=J1 a).
+      contradict J; simpl; auto.
+  Qed.
+
+  Lemma incl_set_eq_left : forall x1 x2 y,
+    set_eq x1 x2 -> incl x1 y -> incl x2 y.
+  Proof.
+    intros x1 x2 y [J1 J2] Hincl.
+    eapply incl_tran; eauto.
+  Qed.
+
+  Lemma set_eq__incl : forall x1 x2, set_eq x1 x2 -> incl x1 x2.
+  Proof.
+    intros x1 x2 J.
+    destruct J; auto.
+  Qed.
+
+  Lemma incl_set_eq_both : forall x1 x2 y1 y2,
+    set_eq x1 x2 ->
+    set_eq y1 y2 ->
+    incl x1 y1 -> incl x2 y2.
+  Proof.
+    intros x1 x2 y1 y2 [J1 J2] [J3 J4] J5.
+    apply incl_tran with (m:=y1); auto.
+    apply incl_tran with (m:=x1); auto.
+  Qed.
+
+  Lemma set_eq_empty_inv2 : forall x,
+    set_eq (ListSet.empty_set _) x -> x = ListSet.empty_set _.
+  Proof.
+    intros.
+    apply set_eq_sym in H.
+    eapply set_eq_empty_inv; eauto.
+  Qed.
+
+  Lemma incl_app_invr : forall (l1 l2 l:list A),
+    incl (l1++l2) l -> incl l2 l.
+  Proof.
+    intros l1 l2 l H x J.
+    apply H.
+    apply (@incl_appr _ l2 l1 l2); auto using incl_refl.
+  Qed.
+
+  Lemma incl_app_invl : forall (l1 l2 l:list A),
+    incl (l1++l2) l -> incl l1 l.
+  Proof.
+    intros l1 l2 l H x J.
+    apply H.
+    apply (@incl_appl _ l1 l2 l1); auto using incl_refl.
+  Qed.
+
+  Lemma incl_set_eq_right : forall y1 y2 x,
+    set_eq y1 y2 -> incl x y1 -> incl x y2.
+  Proof.
+    intros y1 y2 x [J1 J2] Hincl.
+    eapply incl_tran; eauto.
+  Qed.
+
+  Lemma set_eq_inter : forall l1 l2 l1' l2'
+    (H : set_eq l1 l1')
+    (H0 : set_eq l2 l2'),
+    set_eq (ListSet.set_inter Hdec l1 l2)
+      (ListSet.set_inter Hdec l1' l2').
+  Proof.
+    intros.
+    destruct H. destruct H0.
+    split; intros a J.
+      apply ListSet.set_inter_intro.
+        apply ListSet.set_inter_elim1 in J; auto.
+          apply H; auto.
+        apply ListSet.set_inter_elim2 in J; auto.
+          apply H0; auto.
+      apply ListSet.set_inter_intro.
+        apply ListSet.set_inter_elim1 in J; auto.
+          apply H1; auto.
+        apply ListSet.set_inter_elim2 in J; auto.
+          apply H2; auto.
+  Qed.
+
+  Lemma set_inter_empty_eq_empty1: forall l1,
+     set_eq (set_inter Hdec (empty_set _) l1) (empty_set _).
+  Proof.
+     intros.
+      split; intros x J.
+        apply set_inter_elim in J.
+        destruct J; auto.
+        inv J.
+  Qed.
+
+  Lemma set_inter_empty_eq_empty2: forall l1,
+     set_eq (set_inter Hdec l1 (empty_set _)) (empty_set _).
+  Proof.
+     intros.
+      split; intros x J.
+        apply set_inter_elim in J.
+        destruct J; auto.
+        inv J.
+  Qed.
+
+  Lemma set_inter_incl: forall l1 l2,
+    incl l1 l2 -> set_eq (set_inter Hdec l1 l2) l1.
+  Proof.
+    intros.
+    split; intros x J.
+      apply set_inter_elim in J.
+      destruct J; auto.
+
+      apply set_inter_intro; auto.
+        apply H in J; auto.
+  Qed.
+
+  Lemma set_inter_refl: forall l1, set_eq (set_inter Hdec l1 l1) l1.
+  Proof.
+    intro.
+    split; intros x J.
+      apply set_inter_elim in J.
+      destruct J; auto.
+
+      apply set_inter_intro; auto.
+  Qed.
+
+  Lemma incl_inter : forall l1 l2 l1' l2'
+    (H : incl l1 l1') (H0 : incl l2 l2'),
+    incl (ListSet.set_inter Hdec l1 l2)
+         (ListSet.set_inter Hdec l1' l2').
+  Proof.
+    intros.
+    intros x J.
+    apply set_inter_elim in J. destruct J.
+    apply H in H1. apply H0 in H2.
+    apply set_inter_intro; auto.
+  Qed.
+
+  Lemma set_eq_rev: forall pds,
+    set_eq (rev pds) pds.
+  Proof.
+    induction pds; simpl.
+      apply set_eq_refl.
+ 
+      apply set_eq_trans with (y:=pds ++ (a::nil)).
+        apply set_eq_app; auto using set_eq_refl.
+        apply set_eq_swap; auto using set_eq_refl.
+  Qed.
+
+  Lemma incl_empty: forall s, incl (empty_set A) s.
+  Proof. intros s. intros x Hinc. inv Hinc. Qed.
+
+  Lemma set_inter_commut: forall (s s0 : set A),
+    set_eq (set_inter Hdec s s0) (set_inter Hdec s0 s).
+  Proof.
+    intros.
+    split.
+      intros a J.
+      apply set_inter_elim in J. destruct J.
+      apply set_inter_intro; auto.
+
+      intros a J.
+      apply set_inter_elim in J. destruct J.
+      apply set_inter_intro; auto.
+  Qed.
+
+  Lemma set_inter_incll: forall l1 l2,
+    incl (set_inter Hdec l1 l2) l1.
+  Proof.
+    intros.
+    intros x J.
+    apply set_inter_elim in J; tauto.
+  Qed.
+
+  Lemma set_inter_inclr: forall l1 l2,
+    incl (set_inter Hdec l1 l2) l2.
+  Proof.
+    intros.
+    intros x J.
+    apply set_inter_elim in J; tauto.
+  Qed.
+
+  Lemma incl_inter_left: forall s1 s2 s3 (H : incl s1 s3) (H' : incl s2 s3),
+    incl (set_inter Hdec s1 s2) s3.
+  Proof.
+    intros.
+    intros x Hin.
+    apply set_inter_elim in Hin. 
+    destruct Hin.
+    eauto with datatypes v62.
+  Qed.
+
+  Lemma set_union_eq_right: forall x y z (Heq: set_eq y z),
+    set_eq (set_union Hdec x y) (set_union Hdec x z).
+  Proof.
+    intros.
+    destruct Heq as [J1 J2].
+    split; intros e Hine.
+      apply set_union_elim in Hine.
+      apply set_union_intro.
+      destruct Hine; auto.
+        right. apply J1. auto.
+  
+      apply set_union_elim in Hine.
+      apply set_union_intro.
+      destruct Hine; auto.
+        right. apply J2. auto.
+  Qed.
+  
+  Lemma set_inter_union_distr_r: forall x1 x2 y,
+    set_eq (set_inter Hdec y (x1++x2))
+           (set_union Hdec (set_inter Hdec y x1) (set_inter Hdec y x2)).
+  Proof.
+    intros.
+    split; intros e Hine.
+      apply set_union_intro.
+      apply set_inter_elim in Hine.
+      destruct Hine as [J1 J2].
+      unfold set_In in J2.
+      destruct_in J2.
+        left. apply set_inter_intro; auto. 
+        right. apply set_inter_intro; auto. 
+  
+      apply set_union_elim in Hine.
+      destruct Hine as [Hine | Hine].
+        apply set_inter_elim in Hine.
+        destruct Hine as [J1 J2].
+        apply set_inter_intro; auto.
+          apply in_or_app; auto.
+  
+        apply set_inter_elim in Hine.
+        destruct Hine as [J1 J2].
+        apply set_inter_intro; auto.
+          apply in_or_app; auto.
+  Qed.
+  
+  Lemma set_inter_notin_r: forall y xs (Hnotin: ~ In y xs),
+    set_inter Hdec xs (y::nil) = empty_set _.
+  Proof.
+    induction xs; simpl; intros; auto.
+      destruct_if.
+        destruct_if.
+        contradict Hnotin. auto.
+  Qed.
+              
+  Lemma set_inter_prefix: forall x1 x2 y,
+    set_eq (y ++ set_inter Hdec x1 x2)
+           (set_inter Hdec (y++x1) (y++x2)).
+  Proof.
+    intros.
+    split; intros e Hine.
+      destruct_in Hine.
+        apply set_inter_intro; unfold set_In; apply in_or_app; auto.
+   
+        apply set_inter_elim in Hine.
+        destruct_conjs.
+        apply set_inter_intro; unfold set_In in *; apply in_or_app; auto.
+  
+      apply set_inter_elim in Hine.
+      destruct_conjs. unfold set_In in *.
+      apply in_or_app.
+      destruct_in H; auto.
+      destruct_in H0; auto.
+      right. apply set_inter_intro; auto.
+  Qed.
+  
+  Lemma set_inter_drop_incl: forall x y1 y2 (Hinc: incl y1 y2),
+    set_eq (set_inter Hdec x (y1++y2)) (set_inter Hdec x y2).
+  Proof.
+    intros.
+    split; intros e Hine.
+      apply set_inter_elim in Hine.
+      destruct Hine as [J1 J2]. 
+      unfold set_In in *.
+      destruct_in J2.
+        apply set_inter_intro; auto. 
+          apply Hinc; auto.
+        apply set_inter_intro; auto. 
+  
+      apply set_inter_elim in Hine.
+      destruct Hine as [J1 J2]. 
+      unfold set_In in *.
+      apply set_inter_intro; auto. 
+        unfold set_In. apply in_or_app; auto.
+  Qed.
+  
+  Lemma in_incl: forall A (x:A) y (Hin: In x y), incl (x::nil) y.
+  Proof.
+    intros.
+    intros e Hinx. 
+    destruct_in Hinx.
+  Qed. 
+  
+  Lemma set_inter_drop_notin_r: forall xs y ys (Hnotin: ~ In y xs),
+    set_eq (set_inter Hdec xs (y::ys)) (set_inter Hdec xs ys).
+  Proof.
+    intros.
+    split; intros e Hine.
+      apply set_inter_elim in Hine.
+      destruct Hine as [J1 J2].
+      unfold set_In in *.
+      destruct_in J2.
+        apply set_inter_intro; auto.
+  
+      apply set_inter_elim in Hine.
+      destruct Hine as [J1 J2].
+      apply set_inter_intro; auto.
+        unfold set_In. simpl. auto.
+  Qed.
+  
+  Lemma set_inter_drop_notin_l: forall x xs ys (Hnotin: ~ In x ys),
+    set_eq (set_inter Hdec (x::xs) ys) (set_inter Hdec xs ys).
+  Proof.
+    intros.
+    apply set_inter_drop_notin_r with (ys:=xs) in Hnotin.
+    apply set_eq_trans with (y:=set_inter Hdec ys xs); 
+      eauto using set_eq_trans, set_inter_commut.
+  Qed.
+
+  Lemma set_union_empty_eq_empty2: forall l1,
+    set_eq (set_union Hdec l1 (empty_set _)) l1.
+  Proof.
+    intros.
+    split; intros x Hin.
+      apply set_union_elim in Hin.
+      destruct Hin as [Hin | Hin]; auto.
+        inv Hin.
+  
+      apply set_union_intro; auto.
+  Qed.
+  
+  Lemma set_eq_union : forall l1 l2 l1' l2'
+    (H : set_eq l1 l1')
+    (H0 : set_eq l2 l2'),
+    set_eq (set_union Hdec l1 l2) (set_union Hdec l1' l2').
+  Proof.
+    intros.
+    destruct H as [J1 J2].
+    destruct H0 as [J3 J4].
+    split; intros x Hin;
+      apply set_union_elim in Hin;
+      apply set_union_intro;
+      destruct Hin as [Hin | Hin]; auto with datatypes v62.
+  Qed.
+          
+  Lemma set_union_empty_eq_empty1: forall l1,
+    set_eq (set_union Hdec (empty_set _) l1) l1.
+  Proof.
+    intros.
+    split; intros x Hin.
+      apply set_union_elim in Hin.
+      destruct Hin as [Hin | Hin]; auto.
+        inv Hin.
+  
+      apply set_union_intro; auto.
+  Qed.
+  
+  Definition set_disjoint (ls1 ls2 : list A): Prop :=
+  set_eq (set_inter Hdec ls1 ls2) (@empty_set A).
+
+  Lemma set_remove_in_length: forall n s (Hin: In n s),
+    S (length (set_remove Hdec n s)) = length s.
+  Proof.
+    induction s; simpl; intros.
+      tauto.
+  
+      destruct_if.
+      destruct Hin as [Hin | Hin]; subst; simpl; try solve [congruence | auto].
+  Qed.
+  
+  Lemma set_remove_length: forall n s, 
+    (length (set_remove Hdec n s) <= length s)%nat.
+  Proof.
+    induction s; simpl; intros.
+      omega.
+      destruct_if. simpl. omega.
+  Qed.
+  
+  Lemma set_add_length: forall n s, 
+    (length (set_add Hdec n s) <= S (length s))%nat.
+  Proof.
+    induction s; simpl; intros.
+      omega.
+      destruct_if. simpl. omega.
+  Qed.
+  
+  Lemma set_add_NoDup: forall n s (Hnodup: NoDup s), NoDup (set_add Hdec n s).
+  Proof.
+    induction 1; simpl.
+      constructor; auto. constructor. 
+  
+      destruct_if.
+      constructor; auto. 
+      constructor; auto.
+        intro J. apply set_add_elim in J.
+        destruct J as [J | J]; subst; auto.
+  Qed.
+  
+  Lemma set_inter_NoDup: forall s1 s2 (Hnodup1: NoDup s1) (Hnodup2: NoDup s2), 
+    NoDup (set_inter Hdec s1 s2).
+  Proof.
+    induction 1; simpl; intros.
+      constructor.
+  
+      destruct_if.
+      constructor; auto. 
+        intro J. apply set_inter_elim in J.
+        destruct J. auto.
+  Qed.
+  
+  Lemma set_remove_spec1 : forall s n n',
+    In n' s -> n <> n' -> In n' (set_remove Hdec n s).
+  Proof.
+    induction s; intros; simpl in *; auto.
+      destruct H as [H | H]; subst.
+        destruct (Hdec n n') as [J1 | J2]; subst;
+          try solve [simpl; auto | contradict H0; auto].
+
+        destruct (Hdec n a) as [J1 | J2]; subst; simpl; auto.
+  Qed.
+
+  Lemma set_remove_spec2 : forall s n n',
+    In n' (set_remove Hdec n s) -> In n' s.
+  Proof.
+    induction s; intros; simpl in *; auto.
+      destruct (Hdec n a) as [J1 | J2]; subst; simpl in *; auto.
+        destruct H as [H | H]; eauto.
+  Qed.
+  
+  Lemma set_remove_NoDup: forall n s (Hnodup: NoDup s), 
+    NoDup (set_remove Hdec n s).
+  Proof.
+    induction 1; simpl.
+      constructor. 
+  
+      destruct_if.
+      constructor; auto. 
+        intro J. apply set_remove_spec2 in J.
+        auto.
+  Qed.
+
+  Lemma incl__eq_or_exact: forall
+    (l1 l2:list A) (Hinc: incl l1 l2),
+    set_eq l1 l2 \/ (exists a, In a l2 /\ ~ In a l1).
+  Proof.
+    intros.
+    destruct (incl_dec Hdec l2 l1) as [J | J].
+      left. split; auto.
+  
+      right. clear Hinc.
+      generalize dependent l1.
+      induction l2; intros.
+        contradict J. intros x Hinx. inv Hinx.
+        
+        assert (~ In a l1 \/ ~ incl l2 l1) as G.
+          destruct (In_dec Hdec a l1); auto.
+            right. intro K. apply J. auto with datatypes v62.
+        destruct G as [G | G].
+          exists a. simpl. auto.
+  
+          apply IHl2 in G. destruct G as [a' [Hin Hnotin]]. 
+          exists a'. simpl. auto.
+  Qed.
+
+  Definition elements_of_set (ls1: list A): list A :=
+  remove_redundancy Hdec nil ls1.
+
+  Lemma incl_elements_of_set: forall l1 l2 (Hinc : incl l1 l2),
+    incl (elements_of_set l1) (elements_of_set l2).
+  Proof.
+    intros.
+    intros x Hinx.
+      apply remove_redundancy_in.
+      apply Hinc.
+      unfold elements_of_set in Hinx.
+      eapply remove_redundancy_in in Hinx; eauto. 
+  Qed.
+  
+  Lemma length_incl_elements_of_set: forall l1 l2 (Hinc : incl l1 l2),
+    (length (elements_of_set l1) <= length (elements_of_set l2))%nat.
+  Proof.
+    intros.
+    apply incl_elements_of_set in Hinc.
+    apply NoDup_incl_length in Hinc; auto.
+      apply remove_redundancy_NoDup.
+      apply remove_redundancy_NoDup.
+  Qed.
+
+  Lemma exact_incl_elements_of_set: forall l1 l2 
+    (Hinc : incl l1 l2) (Hex: exists a, In a l2 /\ ~ In a l1),
+    incl (elements_of_set l1) (elements_of_set l2) /\
+      exists a, In a (elements_of_set l2) /\ ~ In a (elements_of_set l1).
+  Proof.
+    intros.
+    split.
+      apply incl_elements_of_set; auto.
+  
+      destruct Hex as [a [Hin Hnotin]].
+      apply remove_redundancy_in with (Hdec:=Hdec) in Hin.
+      exists a.
+      split; auto.
+        intro J.
+        apply Hnotin.
+        unfold elements_of_set in J.
+        eapply remove_redundancy_in in J; eauto. 
+  Qed.
+  
+  Lemma length_exact_incl_elements_of_set: forall l1 l2 (Hinc : incl l1 l2)
+     (Hex: exists a, In a l2 /\ ~ In a l1),
+    (length (elements_of_set l1) < length (elements_of_set l2))%nat.
+  Proof.
+    intros.
+    apply exact_incl_elements_of_set in Hinc; auto.
+    destruct Hinc as [J1 J2].
+    apply NoDup_exact_incl_length in J1; auto.
+      apply remove_redundancy_NoDup.
+      apply remove_redundancy_NoDup.
+  Qed.
+  
+  Lemma NoDup_set_eq_length_eq: forall 
+    (ls1:list A) (Hnp1: NoDup ls1) ls2
+    (Hnp2: NoDup ls2) (Heq: AtomSet.set_eq ls1 ls2),
+    (length ls1 = length ls2)%nat.
+  Proof.
+    intros.
+    destruct Heq as [J1 J2].
+    apply NoDup_incl_length in J1; auto.
+    apply NoDup_incl_length in J2; auto.
+    omega.
+  Qed.
+
+End AtomSet. 
+
+Hint Resolve set_eq_app set_eq_swap set_eq__rewrite_env set_eq_refl
+  set_eq_sym set_eq_trans incl_empty_inv set_eq_empty_inv 
+  incl_set_eq_left set_eq__incl incl_set_eq_both set_eq_empty_inv2
+  incl_app_invr  incl_app_invl incl_set_eq_right set_eq_inter 
+  set_inter_empty_eq_empty1 set_inter_empty_eq_empty2 incl_inter_left
+  incl_empty set_inter_commut set_inter_incll set_inter_inclr
+  set_inter_incl set_inter_refl incl_inter set_eq_rev
+  set_union_eq_right set_inter_union_distr_r set_inter_notin_r
+  set_inter_prefix set_inter_drop_incl in_incl
+  set_inter_drop_notin_r set_inter_drop_notin_l 
+  set_union_empty_eq_empty2 set_eq_union set_union_empty_eq_empty1: atomset.
+
+End AtomSet.
+
+(*********** More positive *************)
+
+Lemma Pnlt__Pgt_Peq : forall n m: positive, 
+  ~ ((n < m)%positive) -> (n > m)%positive \/ (n = m)%positive.
+Proof.
+  unfold BinPos.Plt, Pgt.
+  intros.
+  remember ((n ?= m)%positive) as R.
+  destruct R; try solve [congruence | auto].
+    symmetry in HeqR.
+    apply Pos.compare_eq_iff in HeqR. intuition.
+Qed.
+
+Lemma Pgt_trans : forall (n m p : positive)
+  (H1: (n > m)%positive) (H2: (m > p)%positive), (n > p)%positive.
+Proof.
+  unfold Pgt; intros.
+  apply ZC2. apply ZC1 in H1. apply ZC1 in H2.
+  eapply Plt_trans; eauto.
+Qed.
+
+Lemma Plt_succ': forall (x: positive), (x < (Psucc x))%positive.
+Proof. apply Pcompare_p_Sp. Qed.
+
+Lemma Pgt_irrefl: forall p, ~ (p>p)%positive.
+Proof.
+  intros. intros J.
+  apply ZC1 in J.
+  contradict J. apply Plt_irrefl.
+Qed.
+
+Lemma Pgt_neq: forall p1 p2, (p1>p2)%positive -> p1 <> p2.
+Proof.
+  intros. intro EQ. subst.
+  eapply Pgt_irrefl; eauto.
+Qed.
+
+Lemma Plt_neq: forall p1 p2, (p1<p2)%positive -> p1 <> p2.
+Proof.
+  intros. intro EQ. subst.
+  eapply Plt_irrefl; eauto.
+Qed.
+
+Hint Resolve Pgt_irrefl Pgt_neq Plt_neq Plt_lt_succ Plt_succ' Plt_trans
+  : positive.
+
+Ltac Peqb_eq_tac :=
+repeat match goal with
+| H: Peqb _ _ = true |- _ => eapply Peqb_eq in H; subst
+| |- Peqb _ _ = true => eapply Peqb_eq
+end.
+
+Fixpoint P_of_plus_nat p (n:nat) : positive :=
+  match n with
+    | O => p
+    | S x => Psucc (P_of_plus_nat p x)
+  end.
+
+Lemma P_of_plus_one_nat__P_of_succ_nat: forall n,
+  P_of_plus_nat 1 n = P_of_succ_nat n.
+Proof.
+  induction n; simpl; auto.
+    rewrite <- IHn. auto.
+Qed.
+
+Lemma P_of_plus_nat__ge_base: forall q n,
+  (P_of_plus_nat q n >= q)%positive.
+Proof.
+  induction n; simpl; intros; zify; omega.
+Qed.
+
+Lemma P_of_plus_nat__ge: forall q n1 n2 (Hge: (n1 >= n2)%nat),
+  (P_of_plus_nat q n1 >= P_of_plus_nat q n2)%positive.
+Proof.
+  induction n1; simpl; intros.
+    destruct n2; simpl; zify; omega.
+
+    destruct n2; simpl.
+      assert (J:=P_of_plus_nat__ge_base q n1).
+      zify; omega.
+
+      assert (n1>=n2)%nat as J. omega.   
+      apply IHn1 in J. 
+      zify; omega.
+Qed.
+
+Lemma P_of_plus_nat_Pplus_commut: forall n p1 p2,
+  (p1 + (P_of_plus_nat p2 n) = P_of_plus_nat (p1 + p2) n)%positive.
+Proof.
+  induction n; simpl; auto.
+    intros.
+    rewrite <- IHn. zify; omega.
+Qed.
+
+(*********** Forall *************)
+
+Lemma Forall_split: forall A (R:A->Prop) ls2 ls1
+  (Hst: Forall R (ls1++ls2)),
+  Forall R ls1 /\ Forall R ls2.
+Proof.
+  induction ls1; simpl; intros.
+    split; auto. 
+
+    inv Hst. 
+    split; try tauto. 
+      constructor; try tauto.     
+Qed.
+
+Lemma Forall_rev_cons: forall A n (R:A->Prop) (Hp: R n) ls1 (H1: Forall R ls1),
+  Forall R (ls1 ++ n::nil).
+Proof.
+  induction 2; simpl; intros; constructor; auto.
+Qed.
+
+Lemma order_lt_order: forall p x (Horder : (p > x)%positive) l0
+  (Horder : Forall (Plt p) l0),
+  Forall (Plt x) l0.
+Proof.
+  induction 2; simpl; intros; constructor; auto.
+    eapply Plt_trans; eauto.
+    apply ZC1. auto.
+Qed.
+
+Lemma Forall_lt__notin: forall Xd Ysdms (H : Forall (Plt Xd) Ysdms),
+  ListSet.set_mem positive_eq_dec Xd Ysdms = false.
+Proof.
+  induction 1; simpl; auto.
+    destruct_if.
+      apply Plt_ne in H. congruence.
+Qed.
+
+(*********** Sort *************)
+
+Require Import Sorted.
+
+Lemma sorted_append: forall A (R:A -> A -> Prop) a (l1:list A),
+  (forall a1 l1',
+    l1 = l1'++a1::nil -> R a1 a) ->
+  Sorted R l1 -> Sorted R (l1 ++ a :: nil).
+Proof.
+  induction l1; intros; simpl; auto.
+    inv H0.
+    constructor; auto.
+      apply IHl1; auto.
+        intros. subst.
+        apply H with (l1'0:=a0 :: l1'); auto.
+      inv H4; simpl; auto.
+      constructor.
+        apply H with (l1':=nil); auto.
+Qed.
+
+Lemma HdRel_insert: forall A (R:A -> A -> Prop) a a0 l2 l1
+  (H : forall (a1 : A) (l1' : list A), a :: l1 = l1' ++ a1 :: nil -> R a1 a0)
+  (H5 : HdRel R a (l1 ++ l2)),
+  HdRel R a (l1 ++ a0 :: l2).
+Proof.
+  induction l1; simpl; intros.
+    constructor.
+      apply H with (l1':=nil); auto.
+    inv H5. constructor; auto.
+Qed.
+
+Lemma sorted_insert: forall A (R:A -> A -> Prop) (l2 l1:list A) a,
+  (forall a1 l1', l1 = l1'++a1::nil -> R a1 a) ->
+  (forall a2 l2', l2 = a2::l2' -> R a a2) ->
+  Sorted R (l1 ++ l2) -> Sorted R (l1 ++ a :: l2).
+Proof.
+  induction l1; simpl; intros.
+    constructor; auto.
+      destruct l2; constructor.
+        eapply H0; eauto.
+
+    inv H1.
+    constructor.
+      apply IHl1; auto.
+        intros. subst.
+        apply H with (l1'0:=a::l1'); eauto.
+        apply HdRel_insert; auto.
+Qed.
+
+Lemma Sorted_HdRel__Forall: forall A (R : A -> A -> Prop) l0 (H0 : Sorted R l0),
+  forall a : A,
+  (forall x y z : A,
+   In x (a :: l0) ->
+   In y (a :: l0) -> In z (a :: l0) -> R x y -> R y z -> R x z) ->
+  HdRel R a l0 -> Forall (R a) l0.
+Proof.
+  induction l0; simpl; intros.
+    apply Forall_forall.
+    intros. inv H2.
+
+    apply Forall_forall.
+    intros.
+    simpl in H2.
+    inv H1.
+    destruct H2 as [H2 | H2]; subst; auto.
+    inv H0.
+    apply IHl0 in H6; auto.
+      eapply Forall_forall in H6; eauto.
+      apply H with (y:=a); auto.
+
+      intros.
+      eapply H with (y:=y); simpl; eauto.
+Qed.
+
+Lemma strict_Sorted_StronglySorted : forall A (R:A -> A -> Prop) data,
+  (forall x y z,
+     In x data -> In y data -> In z data ->
+     R x y -> R y z -> R x z) ->
+  Sorted R data -> StronglySorted R data.
+Proof.
+  intros.
+  induction H0; constructor.
+    apply IHSorted.
+      intros. eapply H with (y:=y); simpl; eauto.
+      apply Sorted_HdRel__Forall in H; auto.
+Qed.
+
+Lemma Plt_Sorted__rev_Pgt_Sorted: forall dts (Hsort : Sorted Plt dts),
+  Sorted Pgt (rev dts).
+Proof.
+  induction 1; simpl; auto.
+    apply sorted_append; auto.
+      intros.
+      rewrite <- rev_involutive in H at 1.
+      rewrite H0 in H. rewrite rev_unit in H. inv H. 
+      apply ZC2 in H2. auto.
+Qed.
+
+Lemma Pgt_Sorted__StronglySorted: forall l1 (Hsort: Sorted Pgt l1), 
+  StronglySorted Pgt l1.
+Proof.
+  intros.
+  apply Sorted_StronglySorted; auto.
+   unfold Relations_1.Transitive.
+   apply Pgt_trans.
+Qed.
+
+Lemma StronglySorted_split: forall A (R:A->A->Prop) ls2 ls1
+  (Hst: StronglySorted R (ls1++ls2)),
+  StronglySorted R ls1 /\ StronglySorted R ls2.
+Proof.
+  induction ls1; simpl; intros.
+    split; auto. 
+      constructor.
+
+    inv Hst. 
+    apply Forall_split in H2.
+    split; try tauto. 
+      constructor; try tauto.
+Qed.
+
+Lemma StronglySorted__R_front_back: forall A (R:A->A->Prop) ls2 ls1
+  (Hst: StronglySorted R (ls1++ls2)) a1 a2 (Hin1: In a1 ls1) (Hin2: In a2 ls2),
+  R a1 a2.
+Proof.
+  induction ls1; simpl; intros.
+    tauto.
+
+    inv Hst.
+    destruct Hin1 as [Hin1 | Hin1]; subst; eauto.
+      eapply Forall_forall in H2; eauto with datatypes v62.
+Qed.
+
+Lemma StronglySorted_rev_cons: forall A (R:A->A->Prop) n ls1 
+  (Hst: StronglySorted R ls1) (Hp: Forall (fun a => R a n) ls1),
+  StronglySorted R (ls1++n::nil).
+Proof.
+  induction ls1; simpl; intros.
+    constructor; auto.
+
+    inv Hst. inv Hp.
+    constructor; auto.
+      apply Forall_rev_cons; auto. 
+Qed.
+
+Lemma Plt_Sorted__StronglySorted: forall l1 (Hsort: Sorted Plt l1), 
+  StronglySorted Plt l1.
+Proof.
+  intros.
+  apply Sorted_StronglySorted; auto.
+   unfold Relations_1.Transitive.
+   eauto with positive.
+Qed.
 
diff -ruN lib/compcert-1.9/Floats.v lib.patched/compcert-1.9/Floats.v
--- lib/compcert-1.9/Floats.v	2014-08-30 20:09:04.806089049 -0400
+++ lib.patched/compcert-1.9/Floats.v	2014-08-30 00:29:06.156255495 -0400
@@ -23,7 +23,7 @@
 Require Import Coqlib.
 Require Import Integers.
 
-Parameter float: Type.                  (**r the type of IEE754 doubles *)
+Parameter float: Set.                  (**r the type of IEE754 doubles *)
 
 Module Float.
 
@@ -36,15 +36,16 @@
 Parameter neg: float -> float.          (**r opposite (change sign) *)
 Parameter abs: float -> float.          (**r absolute value (set sign to [+]) *)
 Parameter singleoffloat: float -> float. (**r conversion to single precision *)
-Parameter intoffloat: float -> option int. (**r conversion to signed 32-bit int *)
-Parameter intuoffloat: float -> option int. (**r conversion to unsigned 32-bit int *)
-Parameter floatofint: int -> float.     (**r conversion from signed 32-bit int *)
-Parameter floatofintu: int -> float.    (**r conversion from unsigned 32-bit int *)
+Parameter intoffloat: float -> int32.     (**r conversion to signed 32-bit int *)
+Parameter intuoffloat: float -> int32.    (**r conversion to unsigned 32-bit int *)
+Parameter floatofint: int32 -> float.     (**r conversion from signed 32-bit int *)
+Parameter floatofintu: int32 -> float.    (**r conversion from unsigned 32-bit int *)
 
 Parameter add: float -> float -> float. (**r addition *)
 Parameter sub: float -> float -> float. (**r subtraction *)
 Parameter mul: float -> float -> float. (**r multiplication *)
 Parameter div: float -> float -> float. (**r division *)
+Parameter rem: float -> float -> float. (**r mod *)
 
 Parameter cmp: comparison -> float -> float -> bool.  (**r comparison *)
 
@@ -54,13 +55,13 @@
 Parameter bits_of_double: float -> int64.
 Parameter double_of_bits: int64 -> float.
 
-Parameter bits_of_single: float -> int.
-Parameter single_of_bits: int -> float.
+Parameter bits_of_single: float -> int32.
+Parameter single_of_bits: int32 -> float.
 
-Definition from_words (hi lo: int) : float :=
+Definition from_words (hi lo: int32) : float :=
   double_of_bits
-    (Int64.or (Int64.shl (Int64.repr (Int.unsigned hi)) (Int64.repr 32))
-              (Int64.repr (Int.unsigned lo))).
+    (Int.or 63 (Int.shl 63 (Int.repr 63 (Int.unsigned 31 hi)) (Int.repr 63 32))
+              (Int.repr 63 (Int.unsigned 31 lo))).
 
 (** Below are the only properties of floating-point arithmetic that we
   rely on in the compiler proof. *)
@@ -116,52 +117,63 @@
 Axiom singleoffloat_of_bits:
   forall b, singleoffloat (single_of_bits b) = single_of_bits b.
 
+(* Added by Vellvm: Is it correct? *)
+Axiom bits_of_single_of_bits: forall i,
+  Floats.Float.bits_of_single (Floats.Float.single_of_bits i) = i.
+(* Added by Vellvm: Is it correct? *)
+Axiom bits_of_double_of_bits: forall i,
+  Floats.Float.bits_of_double (Floats.Float.double_of_bits i) = i.
+
 (** Conversions between floats and unsigned ints can be defined
   in terms of conversions between floats and signed ints.
   (Most processors provide only the latter, forcing the compiler
   to emulate the former.)   *)
 
-Definition ox8000_0000 := Int.repr Int.half_modulus.  (**r [0x8000_0000] *)
+Definition ox8000_0000 := Int.repr 31 (Int.half_modulus 31).  (**r [0x8000_0000] *)
 
 Axiom floatofintu_floatofint_1:
   forall x,
-  Int.ltu x ox8000_0000 = true ->
+  Int.ltu 31 x ox8000_0000 = true ->
   floatofintu x = floatofint x.
 
 Axiom floatofintu_floatofint_2:
   forall x,
-  Int.ltu x ox8000_0000 = false ->
-  floatofintu x = add (floatofint (Int.sub x ox8000_0000))
+  Int.ltu 31 x ox8000_0000 = false ->
+  floatofintu x = add (floatofint (Int.sub 31 x ox8000_0000))
                       (floatofintu ox8000_0000).
 
 Axiom intuoffloat_intoffloat_1:
-  forall x n,
+  forall x,
   cmp Clt x (floatofintu ox8000_0000) = true ->
-  intuoffloat x = Some n ->
-  intoffloat x = Some n.
+  intuoffloat x = intoffloat x.
 
 Axiom intuoffloat_intoffloat_2:
-  forall x n,
+  forall x,
   cmp Clt x (floatofintu ox8000_0000) = false ->
-  intuoffloat x = Some n ->
-  intoffloat (sub x (floatofintu ox8000_0000)) = Some (Int.sub n ox8000_0000).
+  intuoffloat x =
+  Int.add 31 (intoffloat (sub x (floatofintu ox8000_0000)))
+          ox8000_0000.
 
 (** Conversions from ints to floats can be defined as bitwise manipulations
   over the in-memory representation.  This is what the PowerPC port does.
   The trick is that [from_words 0x4330_0000 x] is the float
   [2^52 + floatofintu x]. *)
 
-Definition ox4330_0000 := Int.repr 1127219200.        (**r [0x4330_0000] *)
+Definition ox4330_0000 := Int.repr 31 1127219200.        (**r [0x4330_0000] *)
 
 Axiom floatofintu_from_words:
   forall x,
   floatofintu x =
-    sub (from_words ox4330_0000 x) (from_words ox4330_0000 Int.zero).
+    sub (from_words ox4330_0000 x) (from_words ox4330_0000 (Int.zero 31)).
 
 Axiom floatofint_from_words:
   forall x,
   floatofint x =
-    sub (from_words ox4330_0000 (Int.add x ox8000_0000))
+    sub (from_words ox4330_0000 (Int.add 31 x ox8000_0000))
         (from_words ox4330_0000 ox8000_0000).
 
+(* Added by Vellvm: Is it correct? *)
+Axiom zero_singleoffloat__eq__zero:
+  Floats.Float.zero = Floats.Float.singleoffloat Floats.Float.zero.
+
 End Float.
diff -ruN lib/compcert-1.9/Integers.v lib.patched/compcert-1.9/Integers.v
--- lib/compcert-1.9/Integers.v	2014-08-30 20:09:04.806089049 -0400
+++ lib.patched/compcert-1.9/Integers.v	2014-08-30 00:29:06.156255495 -0400
@@ -16,7 +16,9 @@
 (** Formalizations of machine integers modulo $2^N$ #2<sup>N</sup>#. *)
 
 Require Import Axioms.
+Require Import Znumtheory.
 Require Import Coqlib.
+Require Import Psatz.
 
 (** * Comparisons *)
 
@@ -50,14 +52,21 @@
 
 (** * Parameterization by the word size, in bits. *)
 
-Module Type WORDSIZE.
-  Variable wordsize: nat.
-  Axiom wordsize_not_zero: wordsize <> 0%nat.
-End WORDSIZE.
+Module Int.
 
-Module Make(WS: WORDSIZE).
+Section Integers.
+
+Variable wordsize_one: nat.
+
+Definition wordsize := S wordsize_one.
+Remark wordsize_not_zero:
+  wordsize <> 0%nat.
+Proof.
+  unfold wordsize. auto.
+Qed.
+
+Opaque wordsize.
 
-Definition wordsize: nat := WS.wordsize.
 Definition modulus : Z := two_power_nat wordsize.
 Definition half_modulus : Z := modulus / 2.
 Definition max_unsigned : Z := modulus - 1.
@@ -67,7 +76,7 @@
 Remark wordsize_pos:
   Z_of_nat wordsize > 0.
 Proof.
-  unfold wordsize. generalize WS.wordsize_not_zero. omega.
+  generalize wordsize_not_zero; omega.
 Qed.
 
 Remark modulus_power:
@@ -88,10 +97,10 @@
   integer (type [Z]) plus a proof that it is in the range 0 (included) to
   [modulus] (excluded. *)
 
-Record int: Type := mkint { intval: Z; intrange: 0 <= intval < modulus }.
+Record int : Type := mkint { intval: Z; intrange: 0 <= intval < modulus }.
 
 (** The [unsigned] and [signed] functions return the Coq integer corresponding
-  to the given machine integer, interpreted as unsigned or signed 
+  to the given machine integer, interpreted as unsigned or signed
   respectively. *)
 
 Definition unsigned (n: int) : Z := intval n.
@@ -104,7 +113,7 @@
 (** Conversely, [repr] takes a Coq integer and returns the corresponding
   machine integer.  The argument is treated modulo [modulus]. *)
 
-Definition repr (x: Z) : int := 
+Definition repr (x: Z) : int :=
   mkint (Zmod x modulus) (Z_mod_lt x modulus modulus_pos).
 
 Definition zero := repr 0.
@@ -115,7 +124,7 @@
 Lemma mkint_eq:
   forall x y Px Py, x = y -> mkint x Px = mkint y Py.
 Proof.
-  intros. subst y. 
+  intros. subst y.
   generalize (proof_irr Px Py); intro.
   subst Py. reflexivity.
 Qed.
@@ -129,7 +138,7 @@
 
 (** * Arithmetic and logical operations over machine integers *)
 
-Definition eq (x y: int) : bool := 
+Definition eq (x y: int) : bool :=
   if zeq (unsigned x) (unsigned y) then true else false.
 Definition lt (x y: int) : bool :=
   if zlt (signed x) (signed y) then true else false.
@@ -167,11 +176,6 @@
 Definition modu (x y: int) : int :=
   repr (Zmod (unsigned x) (unsigned y)).
 
-Definition add_carry (x y cin: int): int :=
-  if zlt (unsigned x + unsigned y + unsigned cin) modulus
-  then zero
-  else one.
-
 (** For bitwise operations, we need to convert between Coq integers [Z]
   and their bit-level representations.  Bit-level representations are
   represented as characteristic functions, that is, functions [f]
@@ -328,8 +332,8 @@
 Remark half_modulus_power:
   half_modulus = two_p (Z_of_nat wordsize - 1).
 Proof.
-  unfold half_modulus. rewrite modulus_power. 
-  set (ws1 := Z_of_nat wordsize - 1). 
+  unfold half_modulus. rewrite modulus_power.
+  set (ws1 := Z_of_nat wordsize - 1).
   replace (Z_of_nat wordsize) with (Zsucc ws1).
   rewrite two_p_S. rewrite Zmult_comm. apply Z_div_mult. omega.
   unfold ws1. generalize wordsize_pos; omega.
@@ -338,8 +342,8 @@
 
 Remark half_modulus_modulus: modulus = 2 * half_modulus.
 Proof.
-  rewrite half_modulus_power. rewrite modulus_power. 
-  rewrite <- two_p_S. decEq. omega. 
+  rewrite half_modulus_power. rewrite modulus_power.
+  rewrite <- two_p_S. decEq. omega.
   generalize wordsize_pos; omega.
 Qed.
 
@@ -372,8 +376,8 @@
 Remark wordsize_max_unsigned: Z_of_nat wordsize <= max_unsigned.
 Proof.
   assert (Z_of_nat wordsize < modulus).
-    rewrite modulus_power. apply two_p_strict. 
-    generalize wordsize_pos. omega. 
+    rewrite modulus_power. apply two_p_strict.
+    generalize wordsize_pos. omega.
   unfold max_unsigned. omega.
 Qed.
 
@@ -386,7 +390,7 @@
 
 Remark max_signed_unsigned: max_signed < max_unsigned.
 Proof.
-  unfold max_signed, max_unsigned. rewrite half_modulus_modulus. 
+  unfold max_signed, max_unsigned. rewrite half_modulus_modulus.
   generalize half_modulus_pos. omega.
 Qed.
 
@@ -434,14 +438,14 @@
 Lemma eqmod_mod_eq:
   forall x y, eqmod x y -> x mod modul = y mod modul.
 Proof.
-  intros x y [k EQ]. subst x. 
+  intros x y [k EQ]. subst x.
   rewrite Zplus_comm. apply Z_mod_plus. auto.
 Qed.
 
 Lemma eqmod_mod:
   forall x, eqmod x (x mod modul).
 Proof.
-  intros; red. exists (x / modul). 
+  intros; red. exists (x / modul).
   rewrite Zmult_comm. apply Z_div_mod_eq. auto.
 Qed.
 
@@ -455,7 +459,7 @@
 Lemma eqmod_neg:
   forall x y, eqmod x y -> eqmod (-x) (-y).
 Proof.
-  intros x y [k EQ]; red. exists (-k). rewrite EQ. ring. 
+  intros x y [k EQ]; red. exists (-k). rewrite EQ. ring.
 Qed.
 
 Lemma eqmod_sub:
@@ -479,11 +483,11 @@
 Lemma eqmod_divides:
   forall n m x y, eqmod n x y -> Zdivide m n -> eqmod m x y.
 Proof.
-  intros. destruct H as [k1 EQ1]. destruct H0 as [k2 EQ2]. 
+  intros. destruct H as [k1 EQ1]. destruct H0 as [k2 EQ2].
   exists (k1*k2). rewrite <- Zmult_assoc. rewrite <- EQ2. auto.
-Qed. 
+Qed.
 
-(** We then specialize these definitions to equality modulo 
+(** We then specialize these definitions to equality modulo
   $2^{wordsize}$ #2<sup>wordsize</sup>#. *)
 
 Hint Resolve modulus_pos: ints.
@@ -536,7 +540,7 @@
 
 Lemma eqm_samerepr: forall x y, eqm x y -> repr x = repr y.
 Proof.
-  intros. unfold repr. apply mkint_eq. 
+  intros. unfold repr. apply mkint_eq.
   apply eqmod_mod_eq. auto with ints. exact H.
 Qed.
 
@@ -550,7 +554,7 @@
 Lemma eqm_unsigned_repr_l:
   forall a b, eqm a b -> eqm (unsigned (repr a)) b.
 Proof.
-  intros. apply eqm_trans with a. 
+  intros. apply eqm_trans with a.
   apply eqm_sym. apply eqm_unsigned_repr. auto.
 Qed.
 Hint Resolve eqm_unsigned_repr_l: ints.
@@ -559,7 +563,7 @@
   forall a b, eqm a b -> eqm a (unsigned (repr b)).
 Proof.
   intros. apply eqm_trans with b. auto.
-  apply eqm_unsigned_repr. 
+  apply eqm_unsigned_repr.
 Qed.
 Hint Resolve eqm_unsigned_repr_r: ints.
 
@@ -568,7 +572,7 @@
 Proof.
   intro; red; unfold signed. set (y := unsigned x).
   case (zlt y half_modulus); intro.
-  apply eqmod_refl. red; exists (-1); ring. 
+  apply eqmod_refl. red; exists (-1); ring.
 Qed.
 
 Theorem unsigned_range:
@@ -581,7 +585,7 @@
 Theorem unsigned_range_2:
   forall i, 0 <= unsigned i <= max_unsigned.
 Proof.
-  intro; unfold max_unsigned. 
+  intro; unfold max_unsigned.
   generalize (unsigned_range i). omega.
 Qed.
 Hint Resolve unsigned_range_2: ints.
@@ -589,13 +593,13 @@
 Theorem signed_range:
   forall i, min_signed <= signed i <= max_signed.
 Proof.
-  intros. unfold signed. 
+  intros. unfold signed.
   generalize (unsigned_range i). set (n := unsigned i). intros.
   case (zlt n half_modulus); intro.
   unfold max_signed. generalize min_signed_neg. omega.
   unfold min_signed, max_signed.
-  rewrite half_modulus_modulus in *. omega. 
-Qed.  
+  rewrite half_modulus_modulus in *. omega.
+Qed.
 
 Theorem repr_unsigned:
   forall i, repr (unsigned i) = i.
@@ -607,7 +611,7 @@
 Lemma repr_signed:
   forall i, repr (signed i) = i.
 Proof.
-  intros. transitivity (repr (unsigned i)). 
+  intros. transitivity (repr (unsigned i)).
   apply eqm_samerepr. apply eqm_signed_unsigned. auto with ints.
 Qed.
 Hint Resolve repr_signed: ints.
@@ -631,19 +635,32 @@
   intros. unfold signed. case (zle 0 z); intro.
   replace (unsigned (repr z)) with z.
   rewrite zlt_true. auto. unfold max_signed in H. omega.
-  symmetry. apply unsigned_repr. generalize max_signed_unsigned. omega. 
+  symmetry. apply unsigned_repr. generalize max_signed_unsigned. omega.
   pose (z' := z + modulus).
   replace (repr z) with (repr z').
   replace (unsigned (repr z')) with z'.
   rewrite zlt_false. unfold z'. omega.
   unfold z'. unfold min_signed in H.
-  rewrite half_modulus_modulus. omega. 
+  rewrite half_modulus_modulus. omega.
   symmetry. apply unsigned_repr.
   unfold z', max_unsigned. unfold min_signed, max_signed in H.
-  rewrite half_modulus_modulus. omega. 
+  rewrite half_modulus_modulus. omega.
   apply eqm_samerepr. unfold z'; red. exists 1. omega.
 Qed.
 
+Lemma signed_repr_ge_0 : forall z, z >=0 -> signed (repr z) <= z.
+Proof.
+  intros.
+  unfold signed, repr, unsigned, half_modulus, modulus. simpl.
+  assert (Hpow : 0 < two_power_nat wordsize). unfold Zlt. auto.
+  destruct (zlt (z mod two_power_nat wordsize) (two_power_nat wordsize / 2)).
+    apply Zmod_le. auto.
+    omega.
+  apply Zle_trans with (z mod two_power_nat wordsize).
+    omega.
+  apply Zmod_le. auto. omega.
+Qed.
+
 Theorem signed_eq_unsigned:
   forall x, unsigned x <= max_signed -> signed x = unsigned x.
 Proof.
@@ -660,16 +677,16 @@
 
 Theorem unsigned_one: unsigned one = 1.
 Proof.
-  simpl. apply Zmod_small. split. omega. 
-  unfold modulus. replace wordsize with (S(pred wordsize)). 
-  rewrite two_power_nat_S. generalize (two_power_nat_pos (pred wordsize)). 
+  simpl. apply Zmod_small. split. omega.
+  unfold modulus. replace wordsize with (S(pred wordsize)).
+  rewrite two_power_nat_S. generalize (two_power_nat_pos (pred wordsize)).
   omega.
-  generalize wordsize_pos. omega. 
+  generalize wordsize_pos. omega.
 Qed.
 
 Theorem unsigned_mone: unsigned mone = modulus - 1.
 Proof.
-  simpl unsigned. 
+  simpl unsigned.
   replace (-1) with ((modulus - 1) + (-1) * modulus).
   rewrite Z_mod_plus_full. apply Zmod_small.
   generalize modulus_pos. omega. omega.
@@ -684,12 +701,12 @@
 Proof.
   unfold signed. rewrite unsigned_mone.
   rewrite zlt_false. omega.
-  rewrite half_modulus_modulus. generalize half_modulus_pos. omega.  
+  rewrite half_modulus_modulus. generalize half_modulus_pos. omega.
 Qed.
 
 Theorem one_not_zero: one <> zero.
 Proof.
-  assert (unsigned one <> unsigned zero). 
+  assert (unsigned one <> unsigned zero).
   rewrite unsigned_one; rewrite unsigned_zero; congruence.
   congruence.
 Qed.
@@ -697,7 +714,7 @@
 Theorem unsigned_repr_wordsize:
   unsigned iwordsize = Z_of_nat wordsize.
 Proof.
-  simpl. apply Zmod_small. 
+  simpl. apply Zmod_small.
   generalize wordsize_pos wordsize_max_unsigned; unfold max_unsigned; omega.
 Qed.
 
@@ -715,7 +732,7 @@
 Proof.
   intros; unfold eq. case (eq_dec x y); intro.
   subst y. rewrite zeq_true. auto.
-  rewrite zeq_false. auto. 
+  rewrite zeq_false. auto.
   destruct x; destruct y.
   simpl. red; intro. elim n. apply mkint_eq. auto.
 Qed.
@@ -730,6 +747,11 @@
   intros. generalize (eq_spec x y); case (eq x y); intros; congruence.
 Qed.
 
+Theorem one_neq_zero: eq one zero = false.
+Proof.
+  unfold eq. rewrite unsigned_one; rewrite unsigned_zero. auto.
+Qed.
+
 (** ** Properties of addition *)
 
 Theorem add_unsigned: forall x y, add x y = repr (unsigned x + unsigned y).
@@ -737,7 +759,7 @@
 Qed.
 
 Theorem add_signed: forall x y, add x y = repr (signed x + signed y).
-Proof. 
+Proof.
   intros. rewrite add_unsigned. apply eqm_samerepr.
   apply eqm_add; apply eqm_sym; apply eqm_signed_unsigned.
 Qed.
@@ -751,18 +773,13 @@
   rewrite Zplus_0_r. apply repr_unsigned.
 Qed.
 
-Theorem add_zero_l: forall x, add zero x = x.
-Proof.
-  intros. rewrite add_commut. apply add_zero.
-Qed.
-
 Theorem add_assoc: forall x y z, add (add x y) z = add x (add y z).
 Proof.
   intros; unfold add.
   set (x' := unsigned x).
   set (y' := unsigned y).
   set (z' := unsigned z).
-  apply eqm_samerepr. 
+  apply eqm_samerepr.
   apply eqm_trans with ((x' + y') + z').
   auto with ints.
   rewrite <- Zplus_assoc. auto with ints.
@@ -770,7 +787,7 @@
 
 Theorem add_permut: forall x y z, add x (add y z) = add y (add x z).
 Proof.
-  intros. rewrite (add_commut y z). rewrite <- add_assoc. apply add_commut. 
+  intros. rewrite (add_commut y z). rewrite <- add_assoc. apply add_commut.
 Qed.
 
 Theorem add_neg_zero: forall x, add x (neg x) = zero.
@@ -789,7 +806,7 @@
 
 Theorem neg_zero: neg zero = zero.
 Proof.
-  unfold neg. rewrite unsigned_zero. auto. 
+  unfold neg. rewrite unsigned_zero. auto.
 Qed.
 
 Theorem neg_involutive: forall x, neg (neg x) = x.
@@ -797,7 +814,7 @@
   intros; unfold neg.
   apply eqm_repr_eq. eapply eqm_trans. apply eqm_neg.
   apply eqm_unsigned_repr_l. apply eqm_refl. apply eqm_refl2. omega.
-Qed. 
+Qed.
 
 Theorem neg_add_distr: forall x y, neg(add x y) = add (neg x) (neg y).
 Proof.
@@ -813,7 +830,7 @@
 
 Theorem sub_zero_l: forall x, sub x zero = x.
 Proof.
-  intros; unfold sub. rewrite unsigned_zero. 
+  intros; unfold sub. rewrite unsigned_zero.
   replace (unsigned x - 0) with (unsigned x) by omega. apply repr_unsigned.
 Qed.
 
@@ -835,7 +852,7 @@
 
 Theorem sub_add_l: forall x y z, sub (add x y) z = add (sub x z) y.
 Proof.
-  intros. repeat rewrite sub_add_opp. 
+  intros. repeat rewrite sub_add_opp.
   repeat rewrite add_assoc. decEq. apply add_commut.
 Qed.
 
@@ -850,7 +867,7 @@
   sub (add x z) (add y z) = sub x y.
 Proof.
   intros. rewrite sub_add_opp. rewrite neg_add_distr.
-  rewrite add_assoc. 
+  rewrite add_assoc.
   rewrite (add_commut (neg y) (neg z)).
   rewrite <- (add_assoc z). rewrite add_neg_zero.
   rewrite (add_commut zero). rewrite add_zero.
@@ -868,12 +885,12 @@
 
 Theorem mul_commut: forall x y, mul x y = mul y x.
 Proof.
-  intros; unfold mul. decEq. ring. 
+  intros; unfold mul. decEq. ring.
 Qed.
 
 Theorem mul_zero: forall x, mul x zero = zero.
 Proof.
-  intros; unfold mul. rewrite unsigned_zero. 
+  intros; unfold mul. rewrite unsigned_zero.
   unfold zero. decEq. ring.
 Qed.
 
@@ -913,11 +930,11 @@
 Theorem mul_add_distr_r:
   forall x y z, mul x (add y z) = add (mul x y) (mul x z).
 Proof.
-  intros. rewrite mul_commut. rewrite mul_add_distr_l. 
+  intros. rewrite mul_commut. rewrite mul_add_distr_l.
   decEq; apply mul_commut.
-Qed. 
+Qed.
 
-Theorem neg_mul_distr_l: 
+Theorem neg_mul_distr_l:
   forall x y, neg(mul x y) = mul (neg x) y.
 Proof.
   intros. unfold mul, neg.
@@ -932,7 +949,7 @@
    forall x y, neg(mul x y) = mul x (neg y).
 Proof.
   intros. rewrite (mul_commut x y). rewrite (mul_commut x (neg y)).
-  apply neg_mul_distr_l. 
+  apply neg_mul_distr_l.
 Qed.
 
 Theorem mul_signed:
@@ -948,13 +965,13 @@
   forall x y, y <> zero -> x = add (mul (divu x y) y) (modu x y).
 Proof.
   intros. unfold add, mul, divu, modu.
-  transitivity (repr (unsigned x)). auto with ints. 
-  apply eqm_samerepr. 
+  transitivity (repr (unsigned x)). auto with ints.
+  apply eqm_samerepr.
   set (x' := unsigned x). set (y' := unsigned y).
   apply eqm_trans with ((x' / y') * y' + x' mod y').
   apply eqm_refl2. rewrite Zmult_comm. apply Z_div_mod_eq.
   generalize (unsigned_range y); intro.
-  assert (unsigned y <> 0). red; intro. 
+  assert (unsigned y <> 0). red; intro.
   elim H. rewrite <- (repr_unsigned y). unfold zero. congruence.
   unfold y'. omega.
   auto with ints.
@@ -963,7 +980,7 @@
 Theorem modu_divu:
   forall x y, y <> zero -> modu x y = sub x (mul (divu x y) y).
 Proof.
-  intros. 
+  intros.
   assert (forall a b c, a = add b c -> c = sub a b).
   intros. subst a. rewrite sub_add_l. rewrite sub_idem.
   rewrite add_commut. rewrite add_zero. auto.
@@ -976,8 +993,8 @@
   intros; unfold mods, sub, mul, divs.
   apply eqm_samerepr.
   unfold Zmod_round.
-  apply eqm_sub. apply eqm_signed_unsigned. 
-  apply eqm_unsigned_repr_r. 
+  apply eqm_sub. apply eqm_signed_unsigned.
+  apply eqm_unsigned_repr_r.
   apply eqm_mult. auto with ints. apply eqm_signed_unsigned.
 Qed.
 
@@ -990,7 +1007,7 @@
   destruct x; simpl.
   auto.
   destruct p; reflexivity.
-  destruct p; try reflexivity. simpl. 
+  destruct p; try reflexivity. simpl.
   assert (forall z, 2 * (z + 1) - 1 = 2 * z + 1). intro; omega.
   generalize (H (Zpos p)); simpl. congruence.
 Qed.
@@ -1000,7 +1017,7 @@
 Proof.
   intros.
   intros. unfold Z_shift_add. destruct b; destruct x; simpl; auto.
-  destruct p; simpl; auto. f_equal. f_equal. 
+  destruct p; simpl; auto. f_equal. f_equal.
   rewrite <- Pplus_one_succ_r. apply Psucc_o_double_minus_one_eq_xO.
 Qed.
 
@@ -1008,9 +1025,9 @@
   forall b1 x1 b2 x2,
   Z_shift_add b1 x1 = Z_shift_add b2 x2 -> b1 = b2 /\ x1 = x2.
 Proof.
-  intros. 
+  intros.
   assert ((b1, x1) = (b2, x2)).
-    repeat rewrite <- Z_bin_decomp_shift_add. rewrite H; auto. 
+    repeat rewrite <- Z_bin_decomp_shift_add. rewrite H; auto.
   split; congruence.
 Qed.
 
@@ -1021,8 +1038,8 @@
 Proof.
   induction n; intros; simpl.
   auto.
-  rewrite inj_S in H. decEq. apply (H 0). omega. 
-  apply IHn. intros. 
+  rewrite inj_S in H. decEq. apply (H 0). omega.
+  apply IHn. intros.
   replace (i + Zsucc i1) with (Zsucc i + i1) by omega.
   replace (i + Zsucc i2) with (Zsucc i + i2) by omega.
   apply H. omega.
@@ -1036,14 +1053,14 @@
   induction n; intros; simpl.
   rewrite two_power_nat_O. exists (-x). omega.
   rewrite two_power_nat_S. simpl bits_of_Z. caseEq (Z_bin_decomp x). intros b y ZBD.
-  rewrite zeq_true. destruct (IHn y) as [k EQ]. 
+  rewrite zeq_true. destruct (IHn y) as [k EQ].
   replace (Z_of_bits n (fun i => if zeq i 0 then b else bits_of_Z n y (i - 1)) 1)
      with (Z_of_bits n (bits_of_Z n y) 0).
-  rewrite EQ. exists k. 
+  rewrite EQ. exists k.
   rewrite <- (Z_shift_add_bin_decomp x). rewrite ZBD. simpl fst; simpl snd.
   unfold Z_shift_add; destruct b; ring.
   apply Z_of_bits_exten. intros.
-  rewrite zeq_false. decEq. omega. omega. 
+  rewrite zeq_false. decEq. omega. omega.
   intro. exact (H wordsize x).
 Qed.
 
@@ -1058,7 +1075,7 @@
 Proof.
   intros. caseEq (Z_bin_decomp (2 * x - 1)). intros b y EQ.
   generalize (Z_shift_add_bin_decomp (2 * x - 1)).
-  rewrite EQ; simpl fst; simpl snd. 
+  rewrite EQ; simpl fst; simpl snd.
   replace (2 * x - 1) with (Z_shift_add true (x - 1)).
   intro. elim (Z_shift_add_inj _ _ _ _ H); intros.
   congruence. unfold Z_shift_add. omega.
@@ -1073,7 +1090,7 @@
   simpl in H0. omegaContradiction.
   destruct (zeq x 0). subst x. change (two_p 0 - 1) with 0. rewrite bits_of_Z_zero.
   unfold proj_sumbool; rewrite zlt_false. auto. omega.
-  simpl. replace (two_p x) with (2 * two_p (x - 1)). rewrite Z_bin_decomp_2xm1. 
+  simpl. replace (two_p x) with (2 * two_p (x - 1)). rewrite Z_bin_decomp_2xm1.
   destruct (zeq i 0). subst. unfold proj_sumbool. rewrite zlt_true. auto. omega.
   rewrite inj_S in H0. rewrite IHn. unfold proj_sumbool. destruct (zlt i x).
   apply zlt_true. omega.
@@ -1086,7 +1103,7 @@
   0 <= x < Z_of_nat wordsize ->
   bits_of_Z wordsize (modulus - 1) x = true.
 Proof.
-  intros. unfold modulus. rewrite two_power_nat_two_p. 
+  intros. unfold modulus. rewrite two_power_nat_two_p.
   rewrite bits_of_Z_two_p. unfold proj_sumbool. apply zlt_true; omega.
   omega. omega.
 Qed.
@@ -1104,7 +1121,7 @@
 Lemma Z_of_bits_range_1:
   forall f i, 0 <= Z_of_bits wordsize f i < modulus.
 Proof.
-  intros. apply Z_of_bits_range. 
+  intros. apply Z_of_bits_range.
 Qed.
 Hint Resolve Z_of_bits_range_1: ints.
 
@@ -1126,9 +1143,9 @@
   rewrite Z_bin_decomp_shift_add.
   destruct (zeq i 0).
   f_equal. omega.
-  rewrite IHn. f_equal. omega. 
+  rewrite IHn. f_equal. omega.
   rewrite inj_S in H. omega.
-Qed.  
+Qed.
 
 Lemma bits_of_Z_of_bits:
   forall n f i,
@@ -1136,7 +1153,7 @@
   bits_of_Z n (Z_of_bits n f 0) i = f i.
 Proof.
   intros. rewrite bits_of_Z_of_bits_gen; auto. decEq; omega.
-Qed.  
+Qed.
 
 Lemma bits_of_Z_below:
   forall n x i, i < 0 -> bits_of_Z n x i = false.
@@ -1152,25 +1169,25 @@
   induction n; intros; simpl.
   auto.
   caseEq (Z_bin_decomp x); intros b x1 EQ. rewrite zeq_false.
-  rewrite IHn. 
-  destruct x; simpl in EQ. inv EQ. auto. 
+  rewrite IHn.
+  destruct x; simpl in EQ. inv EQ. auto.
+  destruct p; inv EQ; auto.
   destruct p; inv EQ; auto.
-  destruct p; inv EQ; auto. 
   rewrite inj_S in H. omega. rewrite inj_S in H. omega.
 Qed.
 
 Lemma bits_of_Z_of_bits_gen':
   forall n f i j,
   bits_of_Z n (Z_of_bits n f j) i =
-  if zlt i 0 then false 
+  if zlt i 0 then false
   else if zle (Z_of_nat n) i then false
   else f (i + j).
 Proof.
-  intros. 
+  intros.
   destruct (zlt i 0). apply bits_of_Z_below; auto.
   destruct (zle (Z_of_nat n) i). apply bits_of_Z_above. omega.
   apply bits_of_Z_of_bits_gen. omega.
-Qed. 
+Qed.
 
 Lemma Z_of_bits_excl:
   forall n f g h j,
@@ -1181,7 +1198,7 @@
   induction n.
   intros; reflexivity.
   intros. simpl. rewrite inj_S in H. rewrite inj_S in H0.
-  rewrite <- (IHn f g h (Zsucc j)). 
+  rewrite <- (IHn f g h (Zsucc j)).
   assert (j <= j < j + Zsucc(Z_of_nat n)). omega.
   unfold Z_shift_add.
   rewrite <- H0; auto.
@@ -1200,16 +1217,16 @@
 Proof.
   induction m; intros.
   simpl. repeat rewrite Zplus_0_r. rewrite two_power_nat_O. omega.
-  rewrite inj_S. rewrite two_power_nat_S. simpl Z_of_bits. 
+  rewrite inj_S. rewrite two_power_nat_S. simpl Z_of_bits.
   rewrite IHm. replace (i + Zsucc (Z_of_nat m)) with (Zsucc i + Z_of_nat m) by omega.
-  unfold Z_shift_add. destruct (f i); ring. 
+  unfold Z_shift_add. destruct (f i); ring.
 Qed.
 
 Lemma Z_of_bits_truncate:
   forall f n i,
   eqm (Z_of_bits (wordsize + n) f i) (Z_of_bits wordsize f i).
 Proof.
-  intros. exists (Z_of_bits n f (i + Z_of_nat wordsize)). 
+  intros. exists (Z_of_bits n f (i + Z_of_nat wordsize)).
   rewrite Z_of_bits_compose. fold modulus. auto.
 Qed.
 
@@ -1219,32 +1236,20 @@
   Z_of_bits n f i = 0.
 Proof.
   induction n; intros; simpl. auto.
-  rewrite inj_S in H. rewrite H. rewrite IHn. auto. 
+  rewrite inj_S in H. rewrite H. rewrite IHn. auto.
   intros; apply H; omega. omega.
 Qed.
 
-Lemma Z_of_bits_complement:
-  forall f n i,
-  Z_of_bits n (fun j => negb (f j)) i = two_power_nat n - 1 - Z_of_bits n f i.
-Proof.
-  induction n; intros; simpl Z_of_bits.
-  auto.
-  rewrite two_power_nat_S. rewrite IHn.
-Opaque Zmult Zplus Zminus.
-  destruct (f i); simpl. ring. ring.
-Transparent Zmult Zplus Zminus.
-Qed.
-
 Lemma Z_of_bits_true:
   forall f n i,
   (forall j, i <= j < i + Z_of_nat n -> f j = true) ->
   Z_of_bits n f i = two_power_nat n - 1.
 Proof.
-  intros. set (z := fun (i: Z) => false). 
-  transitivity (Z_of_bits n (fun j => negb (z j)) i). 
-  apply Z_of_bits_exten; intros. unfold z. rewrite H. auto. omega. 
-  rewrite Z_of_bits_complement. rewrite Z_of_bits_false. omega. 
-  unfold z; auto.
+  induction n; intros.
+  simpl. auto.
+  rewrite two_power_nat_S. simpl Z_of_bits. rewrite inj_S in H.
+  rewrite H. rewrite IHn. unfold Z_shift_add. omega.
+  intros; apply H. omega. omega.
 Qed.
 
 (** ** Properties of bitwise and, or, xor *)
@@ -1266,7 +1271,7 @@
   bitwise_binop f x (bitwise_binop f y z).
 Proof.
   unfold bitwise_binop; intros. repeat rewrite unsigned_repr; auto with ints.
-  decEq; apply Z_of_bits_exten; intros.  
+  decEq; apply Z_of_bits_exten; intros.
   repeat rewrite Zplus_0_r. repeat rewrite bits_of_Z_of_bits; auto.
 Qed.
 
@@ -1277,8 +1282,8 @@
   bitwise_binop f x x = x.
 Proof.
   unfold bitwise_binop; intros.
-  apply eqm_repr_eq. eapply eqm_trans. 2: apply Z_of_bits_of_Z. 
-  apply eqm_refl2. apply Z_of_bits_exten. auto. 
+  apply eqm_repr_eq. eapply eqm_trans. 2: apply Z_of_bits_of_Z.
+  apply eqm_refl2. apply Z_of_bits_exten. auto.
 Qed.
 
 Theorem and_commut: forall x y, and x y = and y x.
@@ -1290,15 +1295,15 @@
 Theorem and_zero: forall x, and x zero = zero.
 Proof.
   intros. unfold and, bitwise_binop.
-  apply eqm_samerepr. eapply eqm_trans. 2: apply Z_of_bits_of_Z. 
-  apply eqm_refl2. apply Z_of_bits_exten. intros. 
+  apply eqm_samerepr. eapply eqm_trans. 2: apply Z_of_bits_of_Z.
+  apply eqm_refl2. apply Z_of_bits_exten. intros.
   rewrite unsigned_zero. rewrite bits_of_Z_zero. apply andb_b_false.
 Qed.
 
 Theorem and_mone: forall x, and x mone = x.
 Proof.
   intros. unfold and, bitwise_binop.
-  apply eqm_repr_eq. eapply eqm_trans. 2: apply Z_of_bits_of_Z. 
+  apply eqm_repr_eq. eapply eqm_trans. 2: apply Z_of_bits_of_Z.
   apply eqm_refl2. apply Z_of_bits_exten; intros.
   rewrite unsigned_mone. rewrite bits_of_Z_mone. apply andb_b_true.
   omega.
@@ -1309,6 +1314,29 @@
   intros. apply (bitwise_binop_idem andb). destruct a; auto.
 Qed.
 
+Theorem add_and:
+  forall x y z,
+  and y z = zero ->
+  add (and x y) (and x z) = and x (or y z).
+Proof.
+  intros. unfold add, and, bitwise_binop.
+  repeat rewrite unsigned_repr; auto with ints. decEq.
+  apply Z_of_bits_excl; intros.
+  assert (forall a b c, a && b && (a && c) = a && (b && c)).
+    destruct a; destruct b; destruct c; reflexivity.
+  rewrite H1.
+  replace (bits_of_Z wordsize (unsigned y) i &&
+           bits_of_Z wordsize (unsigned z) i)
+     with (bits_of_Z wordsize (unsigned (and y z)) i).
+  rewrite H. rewrite unsigned_zero.
+  rewrite bits_of_Z_zero. apply andb_b_false.
+  unfold and, bitwise_binop. rewrite unsigned_repr; auto with ints.
+  rewrite bits_of_Z_of_bits. reflexivity. auto.
+  rewrite <- demorgan1.
+  unfold or, bitwise_binop. rewrite unsigned_repr; auto with ints.
+  rewrite bits_of_Z_of_bits; auto.
+Qed.
+
 Theorem or_commut: forall x y, or x y = or y x.
 Proof (bitwise_binop_commut orb orb_comm).
 
@@ -1317,18 +1345,18 @@
 
 Theorem or_zero: forall x, or x zero = x.
 Proof.
-  intros. unfold or, bitwise_binop. 
+  intros. unfold or, bitwise_binop.
   apply eqm_repr_eq. eapply eqm_trans. 2: apply Z_of_bits_of_Z.
-  apply eqm_refl2. apply Z_of_bits_exten. intros. 
-  rewrite unsigned_zero. rewrite bits_of_Z_zero. apply orb_b_false. 
+  apply eqm_refl2. apply Z_of_bits_exten. intros.
+  rewrite unsigned_zero. rewrite bits_of_Z_zero. apply orb_b_false.
 Qed.
 
 Theorem or_mone: forall x, or x mone = mone.
 Proof.
   intros. unfold or, bitwise_binop.
   apply eqm_repr_eq. eapply eqm_trans. 2: apply Z_of_bits_of_Z.
-  apply eqm_refl2. apply Z_of_bits_exten. intros. 
-  rewrite unsigned_mone. rewrite bits_of_Z_mone. apply orb_b_true. 
+  apply eqm_refl2. apply Z_of_bits_exten. intros.
+  rewrite unsigned_mone. rewrite bits_of_Z_mone. apply orb_b_true.
   omega.
 Qed.
 
@@ -1337,6 +1365,12 @@
   intros. apply (bitwise_binop_idem orb). destruct a; auto.
 Qed.
 
+Theorem or_zero_one: or zero one = one.
+Proof. rewrite or_commut. apply or_zero. Qed.
+
+Theorem or_one_one: or one one = one.
+Proof. apply or_idem. Qed.
+
 Theorem and_or_distrib:
   forall x y z,
   and x (or y z) = or (and x y) (and x z).
@@ -1346,7 +1380,7 @@
   decEq; apply Z_of_bits_exten; intros.
   repeat rewrite bits_of_Z_of_bits; repeat rewrite Zplus_0_r; auto.
   apply demorgan1.
-Qed.  
+Qed.
 
 Theorem xor_commut: forall x y, xor x y = xor y x.
 Proof (bitwise_binop_commut xorb xorb_comm).
@@ -1361,16 +1395,16 @@
 Proof.
   intros. unfold xor, bitwise_binop.
   apply eqm_repr_eq. eapply eqm_trans. 2: apply Z_of_bits_of_Z.
-  apply eqm_refl2. apply Z_of_bits_exten. intros. 
-  rewrite unsigned_zero. rewrite bits_of_Z_zero. apply xorb_false. 
+  apply eqm_refl2. apply Z_of_bits_exten. intros.
+  rewrite unsigned_zero. rewrite bits_of_Z_zero. apply xorb_false.
 Qed.
 
 Theorem xor_idem: forall x, xor x x = zero.
 Proof.
   intros. unfold xor, bitwise_binop.
   apply eqm_repr_eq. eapply eqm_trans. 2: apply Z_of_bits_of_Z.
-  apply eqm_refl2. apply Z_of_bits_exten. intros. 
-  rewrite unsigned_zero. rewrite bits_of_Z_zero. apply xorb_nilpotent. 
+  apply eqm_refl2. apply Z_of_bits_exten. intros.
+  rewrite unsigned_zero. rewrite bits_of_Z_zero. apply xorb_nilpotent.
 Qed.
 
 Theorem xor_zero_one: xor zero one = one.
@@ -1390,154 +1424,12 @@
   assert (forall a b c, a && (xorb b c) = xorb (a && b) (a && c)).
     destruct a; destruct b; destruct c; reflexivity.
   auto.
-Qed.  
-
-(** Properties of bitwise complement.*)
+Qed.
 
 Theorem not_involutive:
   forall (x: int), not (not x) = x.
 Proof.
-  intros. unfold not. rewrite xor_assoc. rewrite xor_idem. apply xor_zero. 
-Qed.
-
-Theorem not_zero:
-  not zero = mone.
-Proof.
-  unfold not. rewrite xor_commut. apply xor_zero.
-Qed.
-
-Theorem not_mone:
-  not mone = zero.
-Proof.
-  rewrite <- (not_involutive zero). symmetry. decEq. apply not_zero.
-Qed.
-
-Theorem not_or_and_not:
-  forall x y, not (or x y) = and (not x) (not y).
-Proof.
-  intros; unfold not, xor, and, or, bitwise_binop.
-  repeat rewrite unsigned_repr; auto with ints.
-  decEq; apply Z_of_bits_exten; intros.
-  repeat rewrite bits_of_Z_of_bits; repeat rewrite Zplus_0_r; auto.
-  rewrite unsigned_mone. rewrite bits_of_Z_mone; auto.
-  assert (forall a b, xorb (a || b) true = xorb a true && xorb b true).
-    destruct a; destruct b; reflexivity.
-  auto.
-Qed.
-
-Theorem not_and_or_not:
-  forall x y, not (and x y) = or (not x) (not y).
-Proof.
-  intros. rewrite <- (not_involutive x) at 1. rewrite <- (not_involutive y) at 1.
-  rewrite <- not_or_and_not. apply not_involutive.
-Qed.
-
-Theorem and_not_self:
-  forall x, and x (not x) = zero.
-Proof.
-  intros. unfold not. rewrite and_xor_distrib. 
-  rewrite and_idem. rewrite and_mone. apply xor_idem.
-Qed.
-
-Theorem or_not_self:
-  forall x, or x (not x) = mone.
-Proof.
-  intros. rewrite <- (not_involutive x) at 1. rewrite or_commut.
-  rewrite <- not_and_or_not. rewrite and_not_self. apply not_zero. 
-Qed.
-
-Theorem xor_not_self:
-  forall x, xor x (not x) = mone.
-Proof.
-  intros. unfold not. rewrite <- xor_assoc. rewrite xor_idem. apply not_zero. 
-Qed.
-
-Theorem not_neg:
-  forall x, not x = add (neg x) mone.
-Proof.
-  intros.
-  unfold not, xor, bitwise_binop. rewrite unsigned_mone.
-  set (ux := unsigned x).
-  set (bx := bits_of_Z wordsize ux).
-  transitivity (repr (Z_of_bits wordsize (fun i => negb (bx i)) 0)).
-  decEq. apply Z_of_bits_exten. intros. rewrite bits_of_Z_mone; auto. omega.
-  rewrite Z_of_bits_complement. apply eqm_samerepr. rewrite unsigned_mone. fold modulus. 
-  replace (modulus - 1 - Z_of_bits wordsize bx 0)
-     with ((- Z_of_bits wordsize bx 0) + (modulus - 1)) by omega.
-  apply eqm_add. unfold neg. apply eqm_unsigned_repr_r. apply eqm_neg. 
-  apply Z_of_bits_of_Z. apply eqm_refl. 
-Qed.
-
-Theorem neg_not:
-  forall x, neg x = add (not x) one.
-Proof.
-  intros. rewrite not_neg. rewrite add_assoc. 
-  replace (add mone one) with zero. rewrite add_zero. auto. 
-  apply eqm_samerepr. rewrite unsigned_mone. rewrite unsigned_one. 
-  exists (-1). ring. 
-Qed.
-
-(** Connections between [add] and bitwise logical operations. *)
-
-Theorem add_is_or:
-  forall x y,
-  and x y = zero ->
-  add x y = or x y.
-Proof.
-  intros. unfold add, or, bitwise_binop.
-  apply eqm_samerepr. eapply eqm_trans. apply eqm_add.
-  apply eqm_sym. apply Z_of_bits_of_Z.
-  apply eqm_sym. apply Z_of_bits_of_Z.
-  apply eqm_refl2. 
-  apply Z_of_bits_excl. 
-  intros. 
-  replace (bits_of_Z wordsize (unsigned x) i &&
-           bits_of_Z wordsize (unsigned y) i)
-     with (bits_of_Z wordsize (unsigned (and x y)) i).
-  rewrite H. rewrite unsigned_zero. rewrite bits_of_Z_zero. auto.
-  unfold and, bitwise_binop. rewrite unsigned_repr; auto with ints. 
-  rewrite bits_of_Z_of_bits. reflexivity. auto. 
-  auto.
-Qed.
-
-Theorem xor_is_or:
-  forall x y, and x y = zero -> xor x y = or x y.
-Proof.
-  intros. unfold xor, or, bitwise_binop. 
-  decEq. apply Z_of_bits_exten; intros.
-  set (bitx := bits_of_Z wordsize (unsigned x) (i + 0)).
-  set (bity := bits_of_Z wordsize (unsigned y) (i + 0)).
-  assert (bitx && bity = false).
-  replace (bitx && bity)
-     with (bits_of_Z wordsize (unsigned (and x y)) (i + 0)).
-  rewrite H. rewrite unsigned_zero. apply bits_of_Z_zero.
-  unfold and, bitwise_binop. rewrite unsigned_repr; auto with ints.
-  unfold bitx, bity. rewrite bits_of_Z_of_bits. reflexivity.
-  omega.
-  destruct bitx; destruct bity; auto; simpl in H1; congruence.
-Qed.
-
-Theorem add_is_xor:
-  forall x y,
-  and x y = zero ->
-  add x y = xor x y.
-Proof.
-  intros. rewrite xor_is_or; auto. apply add_is_or; auto.
-Qed.
-
-Theorem add_and:
-  forall x y z,
-  and y z = zero ->
-  add (and x y) (and x z) = and x (or y z).
-Proof.
-  intros. rewrite add_is_or.
-  rewrite and_or_distrib; auto.
-  rewrite (and_commut x y).
-  rewrite and_assoc. 
-  repeat rewrite <- (and_assoc x). 
-  rewrite (and_commut (and x x)).
-  rewrite <- and_assoc.
-  rewrite H. rewrite and_commut. apply and_zero.
+  intros. unfold not. rewrite xor_assoc. rewrite xor_idem. apply xor_zero.
 Qed.
 
 (** ** Properties of shifts *)
@@ -1545,7 +1437,7 @@
 Theorem shl_zero: forall x, shl x zero = x.
 Proof.
   intros. unfold shl. rewrite unsigned_zero. simpl (-0).
-  transitivity (repr (unsigned x)). apply eqm_samerepr. apply Z_of_bits_of_Z. 
+  transitivity (repr (unsigned x)). apply eqm_samerepr. apply Z_of_bits_of_Z.
   auto with ints.
 Qed.
 
@@ -1562,7 +1454,7 @@
   rewrite bits_of_Z_of_bits_gen; auto.
   rewrite bits_of_Z_of_bits_gen; auto.
   repeat rewrite bits_of_Z_below; auto.
-  repeat rewrite bits_of_Z_of_bits_gen; auto. repeat rewrite Zplus_0_r. auto. 
+  repeat rewrite bits_of_Z_of_bits_gen; auto. repeat rewrite Zplus_0_r. auto.
   generalize (unsigned_range n). omega.
 Qed.
 
@@ -1597,13 +1489,13 @@
 
 Theorem shl_shl:
   forall x y z,
-  ltu y iwordsize = true -> 
+  ltu y iwordsize = true ->
   ltu z iwordsize = true ->
   ltu (add y z) iwordsize = true ->
   shl (shl x y) z = shl x (add y z).
 Proof.
   intros. unfold shl, add.
-  generalize (ltu_inv _ _ H). 
+  generalize (ltu_inv _ _ H).
   generalize (ltu_inv _ _ H0).
   rewrite unsigned_repr_wordsize.
   set (x' := unsigned x).
@@ -1612,7 +1504,7 @@
   intros.
   repeat rewrite unsigned_repr; auto with ints.
   decEq; apply Z_of_bits_exten; intros n R.
-  rewrite bits_of_Z_of_bits_gen'. 
+  rewrite bits_of_Z_of_bits_gen'.
   destruct (zlt (n + - z') 0).
   symmetry. apply bits_of_Z_below. omega.
   destruct (zle (Z_of_nat wordsize) (n + - z')).
@@ -1624,7 +1516,7 @@
 Theorem shru_zero: forall x, shru x zero = x.
 Proof.
   intros. unfold shru. rewrite unsigned_zero.
-  transitivity (repr (unsigned x)). apply eqm_samerepr. apply Z_of_bits_of_Z. 
+  transitivity (repr (unsigned x)). apply eqm_samerepr. apply Z_of_bits_of_Z.
   auto with ints.
 Qed.
 
@@ -1667,13 +1559,13 @@
 
 Theorem shru_shru:
   forall x y z,
-  ltu y iwordsize = true -> 
+  ltu y iwordsize = true ->
   ltu z iwordsize = true ->
   ltu (add y z) iwordsize = true ->
   shru (shru x y) z = shru x (add y z).
 Proof.
   intros. unfold shru, add.
-  generalize (ltu_inv _ _ H). 
+  generalize (ltu_inv _ _ H).
   generalize (ltu_inv _ _ H0).
   rewrite unsigned_repr_wordsize.
   set (x' := unsigned x).
@@ -1681,7 +1573,7 @@
   set (z' := unsigned z).
   intros. repeat rewrite unsigned_repr; auto with ints.
   decEq; apply Z_of_bits_exten. intros n R.
-  rewrite bits_of_Z_of_bits_gen'. 
+  rewrite bits_of_Z_of_bits_gen'.
   destruct (zlt (n + z') 0). omegaContradiction.
   destruct (zle (Z_of_nat wordsize) (n + z')).
   symmetry. apply bits_of_Z_above. omega.
@@ -1694,8 +1586,8 @@
   intros. unfold shr. rewrite unsigned_zero.
   transitivity (repr (unsigned x)). apply eqm_samerepr.
   eapply eqm_trans. 2: apply Z_of_bits_of_Z.
-  apply eqm_refl2. apply Z_of_bits_exten; intros. 
-  rewrite zlt_true. auto. omega. 
+  apply eqm_refl2. apply Z_of_bits_exten; intros.
+  rewrite zlt_true. auto. omega.
   auto with ints.
 Qed.
 
@@ -1708,7 +1600,7 @@
   decEq; apply Z_of_bits_exten; intros.
   repeat rewrite bits_of_Z_of_bits_gen; repeat rewrite Zplus_0_r; auto.
   generalize (unsigned_range n); intro.
-  destruct (zlt (i + unsigned n) (Z_of_nat wordsize)); omega. 
+  destruct (zlt (i + unsigned n) (Z_of_nat wordsize)); omega.
 Qed.
 
 Theorem and_shr:
@@ -1729,18 +1621,18 @@
   forall x y n,
   xor (shr x n) (shr y n) = shr (xor x y) n.
 Proof.
-  unfold xor; intros. apply bitwise_binop_shr. 
+  unfold xor; intros. apply bitwise_binop_shr.
 Qed.
 
 Theorem shr_shr:
   forall x y z,
-  ltu y iwordsize = true -> 
+  ltu y iwordsize = true ->
   ltu z iwordsize = true ->
   ltu (add y z) iwordsize = true ->
   shr (shr x y) z = shr x (add y z).
 Proof.
   intros. unfold shr, add.
-  generalize (ltu_inv _ _ H). 
+  generalize (ltu_inv _ _ H).
   generalize (ltu_inv _ _ H0).
   rewrite unsigned_repr_wordsize.
   set (x' := unsigned x).
@@ -1752,10 +1644,10 @@
   rewrite bits_of_Z_of_bits_gen.
   rewrite (Zplus_comm y' z'). rewrite Zplus_assoc. auto.
   omega.
-  rewrite bits_of_Z_of_bits_gen. 
-  decEq. symmetry. rewrite zlt_false. 
-  destruct (zeq y' 0). rewrite zlt_true; omega. rewrite zlt_false; omega. 
-  omega. omega. 
+  rewrite bits_of_Z_of_bits_gen.
+  decEq. symmetry. rewrite zlt_false.
+  destruct (zeq y' 0). rewrite zlt_true; omega. rewrite zlt_false; omega.
+  omega. omega.
   generalize two_wordsize_max_unsigned; omega.
 Qed.
 
@@ -1764,9 +1656,9 @@
   0 <= n <= Z_of_nat wordsize ->
   0 <= two_p n - 1 <= max_unsigned.
 Proof.
-  intros. split. 
+  intros. split.
   assert (two_p n > 0). apply two_p_gt_ZERO. omega. omega.
-  assert (two_p n <= two_p (Z_of_nat wordsize)). apply two_p_monotone. auto. 
+  assert (two_p n <= two_p (Z_of_nat wordsize)). apply two_p_monotone. auto.
   unfold max_unsigned. unfold modulus. rewrite two_power_nat_two_p. omega.
 Qed.
 
@@ -1778,15 +1670,15 @@
   intros. exploit ltu_inv; eauto. rewrite unsigned_repr_wordsize. intros.
   unfold and, bitwise_binop, shl, shru.
   repeat rewrite unsigned_repr; auto with ints.
-  decEq; apply Z_of_bits_exten; intros. rewrite Zplus_0_r. 
+  decEq; apply Z_of_bits_exten; intros. rewrite Zplus_0_r.
   rewrite bits_of_Z_two_p.
   destruct (zlt (i + unsigned y) (Z_of_nat wordsize)).
-  rewrite bits_of_Z_of_bits_gen. unfold proj_sumbool. rewrite zlt_true. 
-  rewrite andb_true_r. f_equal. omega. 
-  omega. omega. 
-  rewrite bits_of_Z_above. unfold proj_sumbool. rewrite zlt_false. rewrite andb_false_r; auto. 
-  omega. omega. omega. auto. 
-  apply two_p_m1_range. omega. 
+  rewrite bits_of_Z_of_bits_gen. unfold proj_sumbool. rewrite zlt_true.
+  rewrite andb_true_r. f_equal. omega.
+  omega. omega.
+  rewrite bits_of_Z_above. unfold proj_sumbool. rewrite zlt_false. rewrite andb_false_r; auto.
+  omega. omega. omega. auto.
+  apply two_p_m1_range. omega.
 Qed.
 
 (** ** Properties of rotations *)
@@ -1798,17 +1690,17 @@
 Proof.
   intros. exploit ltu_inv; eauto. rewrite unsigned_repr_wordsize; intros.
   unfold shl, rolm, rol, and, bitwise_binop.
-  repeat rewrite unsigned_repr; auto with ints. 
-  decEq; apply Z_of_bits_exten; intros. rewrite Zplus_0_r. 
+  repeat rewrite unsigned_repr; auto with ints.
+  decEq; apply Z_of_bits_exten; intros. rewrite Zplus_0_r.
   repeat rewrite bits_of_Z_of_bits_gen; auto.
   destruct (zlt i (unsigned n)).
   assert (i + - unsigned n < 0). omega.
   rewrite (bits_of_Z_below wordsize (unsigned x) _ H2).
   rewrite (bits_of_Z_below wordsize (unsigned mone) _ H2).
-  symmetry. apply andb_b_false. 
+  symmetry. apply andb_b_false.
   assert (0 <= i + - unsigned n < Z_of_nat wordsize).
     generalize (unsigned_range n). omega.
-  rewrite unsigned_mone. 
+  rewrite unsigned_mone.
   rewrite bits_of_Z_mone; auto. rewrite andb_b_true. decEq.
   rewrite Zmod_small. omega. omega.
 Qed.
@@ -1818,16 +1710,16 @@
   ltu n iwordsize = true ->
   shru x n = rolm x (sub iwordsize n) (shru mone n).
 Proof.
-  intros. generalize (ltu_inv _ _ H). rewrite unsigned_repr_wordsize. intro. 
+  intros. generalize (ltu_inv _ _ H). rewrite unsigned_repr_wordsize. intro.
   unfold shru, rolm, rol, and, bitwise_binop.
   repeat rewrite unsigned_repr; auto with ints.
   decEq; apply Z_of_bits_exten; intros. rewrite Zplus_0_r.
-  repeat rewrite bits_of_Z_of_bits_gen; auto. 
-  unfold sub. rewrite unsigned_repr_wordsize. 
-  rewrite unsigned_repr. 
+  repeat rewrite bits_of_Z_of_bits_gen; auto.
+  unfold sub. rewrite unsigned_repr_wordsize.
+  rewrite unsigned_repr.
   case (zlt (i + unsigned n) (Z_of_nat wordsize)); intro LT2.
   rewrite unsigned_mone. rewrite bits_of_Z_mone. rewrite andb_b_true.
-  decEq. 
+  decEq.
   replace (i + - (Z_of_nat wordsize - unsigned n))
      with ((i + unsigned n) + (-1) * Z_of_nat wordsize) by omega.
   rewrite Z_mod_plus. symmetry. apply Zmod_small.
@@ -1843,9 +1735,9 @@
   forall x,
   rol x zero = x.
 Proof.
-  intros. transitivity (repr (unsigned x)). 
-  unfold rol. apply eqm_samerepr. eapply eqm_trans. 2: apply Z_of_bits_of_Z. 
-  apply eqm_refl2. apply Z_of_bits_exten; intros. decEq. rewrite unsigned_zero. 
+  intros. transitivity (repr (unsigned x)).
+  unfold rol. apply eqm_samerepr. eapply eqm_trans. 2: apply Z_of_bits_of_Z.
+  apply eqm_refl2. apply Z_of_bits_exten; intros. decEq. rewrite unsigned_zero.
   replace (i + - 0) with (i + 0) by omega. apply Zmod_small. omega.
   apply repr_unsigned.
 Qed.
@@ -1889,12 +1781,12 @@
   Zdivide (Z_of_nat wordsize) modulus ->
   rol (rol x n) m = rol x (modu (add n m) iwordsize).
 Proof.
-  intros. unfold rol. 
+  intros. unfold rol.
   repeat rewrite unsigned_repr; auto with ints.
   decEq; apply Z_of_bits_exten; intros.
   repeat rewrite bits_of_Z_of_bits; repeat rewrite Zplus_0_r; auto.
-  rewrite bits_of_Z_of_bits_gen. decEq. 
-  unfold modu, add. 
+  rewrite bits_of_Z_of_bits_gen. decEq.
+  unfold modu, add.
   set (W := Z_of_nat wordsize).
   set (M := unsigned m); set (N := unsigned n).
   assert (W > 0). unfold W; generalize wordsize_pos; omega.
@@ -1905,17 +1797,17 @@
   apply eqmod_trans with (i - (N + M) mod W).
   apply eqmod_trans with ((i - M) - N).
   apply eqmod_sub. apply eqmod_sym. apply eqmod_mod. auto.
-  apply eqmod_refl. 
+  apply eqmod_refl.
   replace (i - M - N) with (i - (N + M)).
   apply eqmod_sub. apply eqmod_refl. apply eqmod_mod. auto.
   omega.
-  apply eqmod_sub. apply eqmod_refl. 
+  apply eqmod_sub. apply eqmod_refl.
   eapply eqmod_trans; [idtac|apply H2].
   eapply eqmod_trans; [idtac|apply eqmod_mod].
   apply eqmod_sym. eapply eqmod_trans; [idtac|apply eqmod_mod].
   apply eqmod_sym. apply H2. auto. auto.
   symmetry. unfold W. apply unsigned_repr_wordsize.
-  apply Z_mod_lt. generalize wordsize_pos; omega. 
+  apply Z_mod_lt. generalize wordsize_pos; omega.
 Qed.
 
 Theorem rolm_zero:
@@ -1933,7 +1825,7 @@
            (and (rol m1 n2) m2).
 Proof.
   intros.
-  unfold rolm. rewrite rol_and. rewrite and_assoc. 
+  unfold rolm. rewrite rol_and. rewrite and_assoc.
   rewrite rol_rol. reflexivity. auto.
 Qed.
 
@@ -1941,7 +1833,7 @@
   forall x n m1 m2,
   or (rolm x n m1) (rolm x n m2) = rolm x n (or m1 m2).
 Proof.
-  intros; unfold rolm. symmetry. apply and_or_distrib. 
+  intros; unfold rolm. symmetry. apply and_or_distrib.
 Qed.
 
 Theorem ror_rol:
@@ -1951,12 +1843,12 @@
 Proof.
   intros. unfold ror, rol, sub.
   generalize (ltu_inv _ _ H).
-  rewrite unsigned_repr_wordsize. 
+  rewrite unsigned_repr_wordsize.
   intro. repeat rewrite unsigned_repr; auto with ints.
   decEq; apply Z_of_bits_exten; intros. decEq.
-  apply eqmod_mod_eq. omega. 
+  apply eqmod_mod_eq. omega.
   exists 1. omega.
-  generalize wordsize_pos; generalize wordsize_max_unsigned; omega. 
+  generalize wordsize_pos; generalize wordsize_max_unsigned; omega.
 Qed.
 
 Theorem or_ror:
@@ -1977,20 +1869,20 @@
   decEq; apply Z_of_bits_exten. intros i iRANGE. rewrite Zplus_0_r.
   repeat rewrite bits_of_Z_of_bits_gen; auto.
   assert (y = sub iwordsize z).
-    rewrite <- H1. rewrite add_commut. rewrite sub_add_l. rewrite sub_idem. 
+    rewrite <- H1. rewrite add_commut. rewrite sub_add_l. rewrite sub_idem.
     rewrite add_commut. rewrite add_zero. auto.
   assert (unsigned y = Z_of_nat wordsize - unsigned z).
-    rewrite H4. unfold sub. rewrite unsigned_repr_wordsize. apply unsigned_repr. 
-    generalize wordsize_max_unsigned; omega. 
-  destruct (zlt (i + unsigned z) (Z_of_nat wordsize)). 
-  rewrite Zmod_small. 
+    rewrite H4. unfold sub. rewrite unsigned_repr_wordsize. apply unsigned_repr.
+    generalize wordsize_max_unsigned; omega.
+  destruct (zlt (i + unsigned z) (Z_of_nat wordsize)).
+  rewrite Zmod_small.
   replace (bits_of_Z wordsize ux (i + - unsigned y)) with false. auto.
-  symmetry. apply bits_of_Z_below. omega. omega. 
+  symmetry. apply bits_of_Z_below. omega. omega.
   replace (bits_of_Z wordsize ux (i + unsigned z)) with false. rewrite orb_false_r.
-  decEq. 
+  decEq.
   replace (i + unsigned z) with (i - unsigned y + 1 * Z_of_nat wordsize) by omega.
-  rewrite Z_mod_plus. apply Zmod_small. omega. generalize wordsize_pos; omega. 
-  symmetry. apply bits_of_Z_above. auto. 
+  rewrite Z_mod_plus. apply Zmod_small. omega. generalize wordsize_pos; omega.
+  symmetry. apply bits_of_Z_above. auto.
 Qed.
 
 (** ** Properties of [Z_one_bits] and [is_power2]. *)
@@ -2012,22 +1904,22 @@
 Lemma Z_one_bits_powerserie:
   forall x, 0 <= x < modulus -> x = powerserie (Z_one_bits wordsize x 0).
 Proof.
-  assert (forall n x i, 
+  assert (forall n x i,
     0 <= i ->
     0 <= x < two_power_nat n ->
     x * two_p i = powerserie (Z_one_bits n x i)).
   induction n; intros.
-  simpl. rewrite two_power_nat_O in H0. 
+  simpl. rewrite two_power_nat_O in H0.
   assert (x = 0). omega. subst x. omega.
   rewrite two_power_nat_S in H0. simpl Z_one_bits.
   generalize (Z_shift_add_bin_decomp x).
   generalize (Z_bin_decomp_range x _ H0).
-  case (Z_bin_decomp x). simpl. intros b y RANGE SHADD. 
+  case (Z_bin_decomp x). simpl. intros b y RANGE SHADD.
   subst x. unfold Z_shift_add.
-  destruct b. simpl powerserie. rewrite <- IHn. 
+  destruct b. simpl powerserie. rewrite <- IHn.
   rewrite two_p_is_exp. change (two_p 1) with 2. ring.
   auto. omega. omega. auto.
-  rewrite <- IHn. 
+  rewrite <- IHn.
   rewrite two_p_is_exp. change (two_p 1) with 2. ring.
   auto. omega. omega. auto.
   intros. rewrite <- H. change (two_p 0) with 1. omega.
@@ -2070,10 +1962,10 @@
   is_power2 n = Some logn -> ltu logn iwordsize = true.
 Proof.
   intros. unfold ltu. rewrite unsigned_repr_wordsize.
-  generalize (is_power2_rng _ _ H). 
+  generalize (is_power2_rng _ _ H).
   case (zlt (unsigned logn) (Z_of_nat wordsize)); intros.
-  auto. omegaContradiction. 
-Qed. 
+  auto. omegaContradiction.
+Qed.
 
 Lemma is_power2_correct:
   forall n logn,
@@ -2090,7 +1982,7 @@
   rewrite unsigned_repr. replace (two_p z) with (two_p z + 0).
   auto. omega. elim (H z); intros.
   generalize wordsize_max_unsigned; omega.
-  auto with coqlib. 
+  auto with coqlib.
   intros; discriminate.
 Qed.
 
@@ -2101,8 +1993,8 @@
 Proof.
   intros. split.
   assert (two_p n > 0). apply two_p_gt_ZERO. omega. omega.
-  generalize (two_p_monotone_strict _ _ H). rewrite <- two_power_nat_two_p. 
-  unfold max_unsigned, modulus. omega. 
+  generalize (two_p_monotone_strict _ _ H). rewrite <- two_power_nat_two_p.
+  unfold max_unsigned, modulus. omega.
 Qed.
 
 Remark Z_one_bits_zero:
@@ -2117,12 +2009,12 @@
   Z_one_bits n (two_p x) i = (i + x) :: nil.
 Proof.
   induction n; intros; simpl. simpl in H. omegaContradiction.
-  rewrite inj_S in H. 
+  rewrite inj_S in H.
   assert (x = 0 \/ 0 < x) by omega. destruct H0.
   subst x; simpl. decEq. omega. apply Z_one_bits_zero.
   replace (two_p x) with (Z_shift_add false (two_p (x-1))).
   rewrite Z_bin_decomp_shift_add.
-  replace (i + x) with ((i + 1) + (x - 1)) by omega. 
+  replace (i + x) with ((i + 1) + (x - 1)) by omega.
   apply IHn. omega.
   unfold Z_shift_add. rewrite <- two_p_S. decEq; omega. omega.
 Qed.
@@ -2131,11 +2023,18 @@
   forall n, 0 <= n < Z_of_nat wordsize ->
   is_power2 (repr (two_p n)) = Some (repr n).
 Proof.
-  intros. unfold is_power2. rewrite unsigned_repr. 
+  intros. unfold is_power2. rewrite unsigned_repr.
   rewrite Z_one_bits_two_p. auto. auto.
   apply two_p_range. auto.
 Qed.
 
+Lemma is_power2_zero : is_power2 zero = None.
+Proof.
+  unfold is_power2.
+  change (unsigned zero) with 0.
+  rewrite Z_one_bits_zero. auto.
+Qed.
+
 (** ** Relation between bitwise operations and multiplications / divisions by powers of 2 *)
 
 (** Left shifts and multiplications by powers of 2. *)
@@ -2146,22 +2045,22 @@
   (forall i, i < 0 -> f i = false) ->
   eqm (Z_of_bits wordsize f (-m)) (two_p m * Z_of_bits wordsize f 0).
 Proof.
-  intros. 
-  set (m' := nat_of_Z m). 
+  intros.
+  set (m' := nat_of_Z m).
   assert (Z_of_nat m' = m). apply nat_of_Z_eq. auto.
-  generalize (Z_of_bits_compose f m' wordsize (-m)). rewrite H1. 
-  replace (-m+m) with 0 by omega. rewrite two_power_nat_two_p. rewrite H1. 
+  generalize (Z_of_bits_compose f m' wordsize (-m)). rewrite H1.
+  replace (-m+m) with 0 by omega. rewrite two_power_nat_two_p. rewrite H1.
   replace (Z_of_bits m' f (-m)) with 0. intro EQ.
   eapply eqm_trans. apply eqm_sym. eapply Z_of_bits_truncate with (n := m').
-  rewrite plus_comm. rewrite EQ. apply eqm_refl2. ring. 
-  symmetry. apply Z_of_bits_false. rewrite H1. intros. apply H0. omega. 
+  rewrite plus_comm. rewrite EQ. apply eqm_refl2. ring.
+  symmetry. apply Z_of_bits_false. rewrite H1. intros. apply H0. omega.
 Qed.
 
 Lemma shl_mul_two_p:
   forall x y,
   shl x y = mul x (repr (two_p (unsigned y))).
 Proof.
-  intros. unfold shl, mul. apply eqm_samerepr. 
+  intros. unfold shl, mul. apply eqm_samerepr.
   eapply eqm_trans.
   apply Z_of_bits_shift_left.
   generalize (unsigned_range y). omega.
@@ -2174,7 +2073,7 @@
   forall x y,
   shl x y = mul x (shl one y).
 Proof.
-  intros. 
+  intros.
   assert (shl one y = repr (two_p (unsigned y))).
   rewrite shl_mul_two_p. rewrite mul_commut. rewrite mul_one. auto.
   rewrite H. apply shl_mul_two_p.
@@ -2199,33 +2098,33 @@
   exists k,
   Z_of_bits wordsize f 0 = k + two_p m * Z_of_bits wordsize f m /\ 0 <= k < two_p m.
 Proof.
-  intros. 
-  set (m' := nat_of_Z m). 
+  intros.
+  set (m' := nat_of_Z m).
   assert (Z_of_nat m' = m). apply nat_of_Z_eq. auto.
   generalize (Z_of_bits_compose f m' wordsize 0).
   rewrite two_power_nat_two_p. rewrite H1.
   rewrite plus_comm. rewrite Z_of_bits_compose.
   replace (Z_of_bits m' f (0 + Z_of_nat wordsize)) with 0.
-  repeat rewrite Zplus_0_l. intros EQ. 
-  exists (Z_of_bits m' f 0); split. rewrite EQ. ring. 
-  rewrite <- H1. rewrite <- two_power_nat_two_p. apply Z_of_bits_range. 
-  symmetry. apply Z_of_bits_false. intros. apply H0. omega. 
+  repeat rewrite Zplus_0_l. intros EQ.
+  exists (Z_of_bits m' f 0); split. rewrite EQ. ring.
+  rewrite <- H1. rewrite <- two_power_nat_two_p. apply Z_of_bits_range.
+  symmetry. apply Z_of_bits_false. intros. apply H0. omega.
 Qed.
 
 Lemma shru_div_two_p:
   forall x y,
   shru x y = repr (unsigned x / two_p (unsigned y)).
 Proof.
-  intros. unfold shru. 
+  intros. unfold shru.
   set (x' := unsigned x). set (y' := unsigned y).
   destruct (Z_of_bits_shift_right y' (bits_of_Z wordsize x')) as [k [EQ RANGE]].
   generalize (unsigned_range y). unfold y'; omega.
-  intros. rewrite bits_of_Z_above; auto. 
-  decEq. symmetry. apply Zdiv_unique with k; auto. 
+  intros. rewrite bits_of_Z_above; auto.
+  decEq. symmetry. apply Zdiv_unique with k; auto.
   transitivity (Z_of_bits wordsize (bits_of_Z wordsize x') 0).
   apply eqm_small_eq. apply eqm_sym. apply Z_of_bits_of_Z.
   unfold x'; auto with ints. auto with ints.
-  rewrite EQ. ring. 
+  rewrite EQ. ring.
 Qed.
 
 Theorem divu_pow2:
@@ -2245,26 +2144,26 @@
   (forall i, i >= Z_of_nat wordsize -> f i = true) ->
   exists k,
   Z_of_bits wordsize f 0 - modulus =
-           k + two_p m * (Z_of_bits wordsize f m - modulus) 
+           k + two_p m * (Z_of_bits wordsize f m - modulus)
   /\ 0 <= k < two_p m.
 Proof.
-  intros. 
-  set (m' := nat_of_Z m). 
+  intros.
+  set (m' := nat_of_Z m).
   assert (Z_of_nat m' = m). apply nat_of_Z_eq. auto.
   generalize (Z_of_bits_compose f m' wordsize 0).
   rewrite two_power_nat_two_p. rewrite H1.
   rewrite plus_comm. rewrite Z_of_bits_compose.
-  repeat rewrite Zplus_0_l. fold modulus. 
+  repeat rewrite Zplus_0_l. fold modulus.
   replace (Z_of_bits m' f (Z_of_nat wordsize)) with (two_p m - 1).
   intros EQ.
   exists (Z_of_bits m' f 0); split.
   replace (Z_of_bits wordsize f 0)
      with (Z_of_bits wordsize f m * two_p m + Z_of_bits m' f 0 - (two_p m - 1) * modulus)
   by omega.
-  ring. 
+  ring.
   rewrite <- H1. rewrite <- two_power_nat_two_p. apply Z_of_bits_range.
-  rewrite <- H1. rewrite <- two_power_nat_two_p. 
-  symmetry. apply Z_of_bits_true. intros. apply H0. omega. 
+  rewrite <- H1. rewrite <- two_power_nat_two_p.
+  symmetry. apply Z_of_bits_true. intros. apply H0. omega.
 Qed.
 
 Lemma sign_bit_of_Z_rec:
@@ -2273,16 +2172,16 @@
   bits_of_Z (S n) x (Z_of_nat n) = if zlt x (two_power_nat n) then false else true.
 Proof.
   induction n; intros.
-  rewrite two_power_nat_S in H. rewrite two_power_nat_O in *. simpl. 
-  caseEq (Z_bin_decomp x); intros b x1 ZBD. rewrite zeq_true. 
-  generalize (Z_shift_add_bin_decomp x). rewrite ZBD; simpl. intros. subst x. 
+  rewrite two_power_nat_S in H. rewrite two_power_nat_O in *. simpl.
+  caseEq (Z_bin_decomp x); intros b x1 ZBD. rewrite zeq_true.
+  generalize (Z_shift_add_bin_decomp x). rewrite ZBD; simpl. intros. subst x.
   unfold Z_shift_add in *.
-  destruct b. rewrite zlt_false. auto. omega. rewrite zlt_true. auto. omega. 
-  rewrite inj_S. remember (S n) as sn. simpl. rewrite two_power_nat_S in H. 
+  destruct b. rewrite zlt_false. auto. omega. rewrite zlt_true. auto. omega.
+  rewrite inj_S. remember (S n) as sn. simpl. rewrite two_power_nat_S in H.
   generalize (Z_shift_add_bin_decomp x). destruct (Z_bin_decomp x) as [b x1].
-  simpl. intros. rewrite zeq_false. 
+  simpl. intros. rewrite zeq_false.
   replace (Zsucc (Z_of_nat n) - 1) with (Z_of_nat n). rewrite IHn.
-  rewrite <- H0. subst sn. rewrite two_power_nat_S. 
+  rewrite <- H0. subst sn. rewrite two_power_nat_S.
   destruct (zlt x1 (two_power_nat n)).
   rewrite zlt_true. auto. unfold Z_shift_add; destruct b; omega.
   rewrite zlt_false. auto. unfold Z_shift_add; destruct b; omega.
@@ -2295,8 +2194,8 @@
   bits_of_Z wordsize (unsigned x) (Z_of_nat wordsize - 1) =
   if zlt (unsigned x) half_modulus then false else true.
 Proof.
-  intros. 
-  rewrite half_modulus_power. 
+  intros.
+  rewrite half_modulus_power.
   set (w1 := nat_of_Z (Z_of_nat wordsize - 1)).
   assert (Z_of_nat wordsize - 1 = Z_of_nat w1).
       unfold w1. rewrite nat_of_Z_eq; auto. generalize wordsize_pos; omega.
@@ -2316,26 +2215,26 @@
 (* positive case *)
   rewrite <- shru_div_two_p. unfold shru. decEq; apply Z_of_bits_exten; intros.
   destruct (zlt (i + unsigned y) (Z_of_nat wordsize)). auto.
-  rewrite SIGN. symmetry. apply bits_of_Z_above. auto. 
+  rewrite SIGN. symmetry. apply bits_of_Z_above. auto.
 (* negative case *)
   set (x' := unsigned x) in *. set (y' := unsigned y) in *.
   set (f := fun i => bits_of_Z wordsize x'
                       (if zlt i (Z_of_nat wordsize) then i else Z_of_nat wordsize - 1)).
   destruct (Z_of_bits_shift_right_neg y' f) as [k [EQ RANGE]].
   generalize (unsigned_range y). unfold y'; omega.
-  intros. unfold f. rewrite zlt_false; auto. 
+  intros. unfold f. rewrite zlt_false; auto.
   set (A := Z_of_bits wordsize f y') in *.
   set (B := Z_of_bits wordsize f 0) in *.
   assert (B = Z_of_bits wordsize (bits_of_Z wordsize x') 0).
-    unfold B. apply Z_of_bits_exten; intros. 
-    unfold f. rewrite zlt_true. auto. omega. 
+    unfold B. apply Z_of_bits_exten; intros.
+    unfold f. rewrite zlt_true. auto. omega.
   assert (B = x').
-    apply eqm_small_eq. rewrite H. apply Z_of_bits_of_Z. 
-    unfold B; apply Z_of_bits_range. 
+    apply eqm_small_eq. rewrite H. apply Z_of_bits_of_Z.
+    unfold B; apply Z_of_bits_range.
     unfold x'; apply unsigned_range.
   assert (Q: (x' - modulus) / two_p y' = A - modulus).
     apply Zdiv_unique with k; auto. rewrite <- H0. rewrite EQ. ring.
-  rewrite Q. apply eqm_samerepr. exists 1; ring. 
+  rewrite Q. apply eqm_samerepr. exists 1; ring.
 Qed.
 
 Theorem divs_pow2:
@@ -2351,7 +2250,40 @@
 
 (** Unsigned modulus over [2^n] is masking with [2^n-1]. *)
 
-Lemma Z_of_bits_mod_mask:
+Lemma Z_of_bits_ge_wz : forall wz n f j b,
+  n >= Z_of_nat wz + j ->
+  Z_of_bits wz (fun i => if zlt i n then f i else b) j =
+  Z_of_bits wz f j.
+Proof.
+  induction wz; intros; simpl; auto.
+  rewrite IHwz; auto.
+    destruct (zlt j n); auto.
+      assert (n > j) as J.
+        (* clear z. *)
+        assert (J':=@O_lt_Z_of_S wz).
+        eauto with zarith.
+      contradict H; omega.
+      (* contradict z; omega. *)
+    rewrite <- Z_of_Sn_add_z__eq__Z_of_n_add_sz. auto.
+Qed.
+
+Lemma Z_of_bits_mod_mask_1:
+  forall f n,
+  n > Z_of_nat wordsize ->
+  Z_of_bits wordsize (fun i => if zlt i n then f i else false) 0 =
+  (Z_of_bits wordsize f 0) mod (two_p n).
+Proof.
+  intros.
+  assert (J:=@Z_of_bits_range f wordsize 0).
+  rewrite Zmod_small.
+  rewrite Z_of_bits_ge_wz; auto with zarith.
+  rewrite two_power_nat_two_p in J.
+  assert (0 <= Z_of_nat wordsize < n) as R. auto with zarith.
+  apply two_p_monotone_strict in R.
+  auto with zarith.
+Qed.
+
+Lemma Z_of_bits_mod_mask_2:
   forall f n,
   0 <= n <= Z_of_nat wordsize ->
   Z_of_bits wordsize (fun i => if zlt i n then f i else false) 0 =
@@ -2367,15 +2299,27 @@
   generalize (Z_of_bits_compose f' n1 m1 0).
   rewrite H2. rewrite Zplus_0_l. rewrite two_power_nat_two_p. rewrite H0. intros.
   assert (Z_of_bits n1 f' 0 = Z_of_bits n1 f 0).
-    apply Z_of_bits_exten; intros. unfold f'. apply zlt_true. omega. 
+    apply Z_of_bits_exten; intros. unfold f'. apply zlt_true. omega.
   assert (Z_of_bits m1 f' n = 0).
-    apply Z_of_bits_false; intros. unfold f'. apply zlt_false. omega. 
+    apply Z_of_bits_false; intros. unfold f'. apply zlt_false. omega.
   assert (Z_of_bits wordsize f' 0 = Z_of_bits n1 f 0).
     rewrite H4. rewrite H5. rewrite H6. ring.
-  symmetry. apply Zmod_unique with (Z_of_bits m1 f n). omega. 
+  symmetry. apply Zmod_unique with (Z_of_bits m1 f n). omega.
   rewrite H7. rewrite <- H0. rewrite <- two_power_nat_two_p. apply Z_of_bits_range.
 Qed.
 
+Lemma Z_of_bits_mod_mask:
+  forall f n,
+  0 <= n ->
+  Z_of_bits wordsize (fun i => if zlt i n then f i else false) 0 =
+  (Z_of_bits wordsize f 0) mod (two_p n).
+Proof.
+  intros.
+  destruct (zle n (Z_of_nat wordsize)).
+    apply Z_of_bits_mod_mask_2; auto.
+    apply Z_of_bits_mod_mask_1; auto.
+Qed.
+
 Theorem modu_and:
   forall x n logn,
   is_power2 n = Some logn ->
@@ -2386,19 +2330,19 @@
   unfold modu, and, bitwise_binop. decEq.
   set (ux := unsigned x).
   replace ux with (Z_of_bits wordsize (bits_of_Z wordsize ux) 0).
-  rewrite H0. rewrite <- Z_of_bits_mod_mask. 
-  apply Z_of_bits_exten; intros. rewrite Zplus_0_r. 
-  rewrite bits_of_Z_of_bits; auto. 
+  rewrite H0. rewrite <- Z_of_bits_mod_mask.
+  apply Z_of_bits_exten; intros. rewrite Zplus_0_r.
+  rewrite bits_of_Z_of_bits; auto.
   replace (unsigned (sub n one)) with (two_p (unsigned logn) - 1).
   rewrite bits_of_Z_two_p. unfold proj_sumbool.
-  destruct (zlt i (unsigned logn)). rewrite andb_true_r; auto. rewrite andb_false_r; auto. 
-  omega. auto. 
+  destruct (zlt i (unsigned logn)). rewrite andb_true_r; auto. rewrite andb_false_r; auto.
+  omega. auto.
   rewrite <- H0. unfold sub. symmetry. rewrite unsigned_one. apply unsigned_repr.
-  rewrite H0. 
+  rewrite H0.
   assert (two_p (unsigned logn) > 0). apply two_p_gt_ZERO. omega.
-  generalize (two_p_range _ H1). omega. 
+  generalize (two_p_range _ H1). omega.
   omega.
-  apply eqm_small_eq. apply Z_of_bits_of_Z. apply Z_of_bits_range. 
+  apply eqm_small_eq. apply Z_of_bits_of_Z. apply Z_of_bits_range.
   unfold ux. apply unsigned_range.
 Qed.
 
@@ -2408,8 +2352,8 @@
   forall x y,
   add (shr x y) (shr_carry x y) = shrx x y.
 Proof.
-  intros. unfold shr_carry. 
-  rewrite sub_add_opp. rewrite add_permut. 
+  intros. unfold shr_carry.
+  rewrite sub_add_opp. rewrite add_permut.
   rewrite add_neg_zero. apply add_zero.
 Qed.
 
@@ -2419,7 +2363,7 @@
   Zdiv_round x y = if zlt x 0 then (x + y - 1) / y else x / y.
 Proof.
   intros. unfold Zdiv_round.
-  destruct (zlt x 0). 
+  destruct (zlt x 0).
   rewrite zlt_false; try omega.
   generalize (Z_div_mod_eq (-x) y H).
   generalize (Z_mod_lt (-x) y H).
@@ -2439,36 +2383,36 @@
   shrx x y =
   shr (if lt x zero then add x (sub (shl one y) one) else x) y.
 Proof.
-  intros. rewrite shr_div_two_p. unfold shrx. unfold divs.  
-  exploit ltu_inv; eauto. rewrite unsigned_repr. 
+  intros. rewrite shr_div_two_p. unfold shrx. unfold divs.
+  exploit ltu_inv; eauto. rewrite unsigned_repr.
   set (uy := unsigned y). intro RANGE.
   assert (shl one y = repr (two_p uy)).
     transitivity (mul one (repr (two_p uy))).
-    symmetry. apply mul_pow2. replace y with (repr uy). 
+    symmetry. apply mul_pow2. replace y with (repr uy).
     apply is_power2_two_p. omega. apply repr_unsigned.
     rewrite mul_commut. apply mul_one.
   assert (two_p uy > 0). apply two_p_gt_ZERO. omega.
-  assert (two_p uy < half_modulus). 
-    rewrite half_modulus_power. 
+  assert (two_p uy < half_modulus).
+    rewrite half_modulus_power.
     apply two_p_monotone_strict. auto.
   assert (two_p uy < modulus).
-    rewrite modulus_power. apply two_p_monotone_strict. omega. 
+    rewrite modulus_power. apply two_p_monotone_strict. omega.
   assert (unsigned (shl one y) = two_p uy).
     rewrite H0. apply unsigned_repr. unfold max_unsigned. omega.
   assert (signed (shl one y) = two_p uy).
     rewrite H0. apply signed_repr.
     unfold max_signed. generalize min_signed_neg. omega.
-  rewrite H5. 
+  rewrite H5.
   rewrite Zdiv_round_Zdiv; auto.
-  unfold lt. rewrite signed_zero.  
+  unfold lt. rewrite signed_zero.
   destruct (zlt (signed x) 0); auto.
   rewrite add_signed.
   assert (signed (sub (shl one y) one) = two_p uy - 1).
-    unfold sub. rewrite H4. rewrite unsigned_one.  
+    unfold sub. rewrite H4. rewrite unsigned_one.
     apply signed_repr.
-    generalize min_signed_neg. unfold max_signed. omega. 
+    generalize min_signed_neg. unfold max_signed. omega.
   rewrite H6. rewrite signed_repr. decEq. decEq. omega.
-  generalize (signed_range x). intros.  
+  generalize (signed_range x). intros.
   assert (two_p uy - 1 <= max_signed). unfold max_signed. omega.
   omega.
   generalize wordsize_pos wordsize_max_unsigned; omega.
@@ -2476,6 +2420,126 @@
 
 (** ** Properties of integer zero extension and sign extension. *)
 
+Section EXTENSIONS'.
+
+Variable n: Z.
+Hypothesis RANGE: 0 < n.
+
+Theorem zero_ext_mod:
+  forall x, unsigned (zero_ext n x) = Zmod (unsigned x) (two_p n).
+Proof.
+  intros.
+  replace (unsigned x) with (Z_of_bits wordsize (bits_of_Z wordsize (unsigned x)) 0).
+  unfold zero_ext. rewrite unsigned_repr; auto with ints.
+  apply Z_of_bits_mod_mask. omega.
+  apply eqm_small_eq; auto with ints. apply Z_of_bits_of_Z.
+Qed.
+
+Theorem sign_ext_zero_ext:
+  forall x, sign_ext n (zero_ext n x) = sign_ext n x.
+Proof.
+  intros. unfold sign_ext, zero_ext.
+  repeat rewrite unsigned_repr; auto with ints.
+  decEq; apply Z_of_bits_exten; intros. rewrite Zplus_0_r.
+  destruct (zlt i n); rewrite bits_of_Z_of_bits; auto.
+  rewrite zlt_true; auto. rewrite zlt_true; auto. omega. omega.
+Qed.
+
+Theorem zero_ext_sign_ext:
+  forall x, zero_ext n (sign_ext n x) = zero_ext n x.
+Proof.
+  intros. unfold sign_ext, zero_ext.
+  repeat rewrite unsigned_repr; auto with ints.
+  decEq; apply Z_of_bits_exten; intros. rewrite Zplus_0_r.
+  destruct (zlt i n); auto.
+  rewrite bits_of_Z_of_bits; auto.
+  rewrite zlt_true; auto.
+Qed.
+
+Lemma zero_ext_ge_wz : forall x,
+  n >= Z_of_nat wordsize ->
+  zero_ext n x = x.
+Proof.
+  intros.
+  unfold zero_ext.
+  rewrite Z_of_bits_ge_wz; auto with zarith.
+  apply eqm_repr_eq.
+  apply Z_of_bits_of_Z.
+Qed.
+
+Lemma sign_ext_ge_wz : forall x,
+  n >= Z_of_nat wordsize ->
+  sign_ext n x = x.
+Proof.
+  intros.
+  unfold sign_ext.
+  rewrite Z_of_bits_ge_wz; auto with zarith.
+  apply eqm_repr_eq.
+  apply Z_of_bits_of_Z.
+Qed.
+
+(*
+Lemma and_two_p_ge_wz : forall x,
+  n >= Z_of_nat wordsize ->
+  and x (repr (two_p n - 1)) = x.
+Qed.
+
+Theorem zero_ext_and_ge_wz:
+  forall x,
+  n >= Z_of_nat wordsize ->
+  zero_ext n x = and x (repr (two_p n - 1)).
+Proof.
+  intros.
+  rewrite zero_ext_ge_wz; auto.
+  rewrite and_two_p_ge_wz; auto.
+Qed.
+
+Theorem zero_ext_idem_ge_wz:
+  forall x,
+  n >= Z_of_nat wordsize ->
+  zero_ext n (zero_ext n x) = zero_ext n x.
+Proof.
+  intros. repeat (rewrite zero_ext_and_ge_wz; auto).
+  rewrite and_assoc. rewrite and_idem. auto.
+Qed.
+*)
+
+Theorem sign_ext_idem_ge_wz:
+  forall x,
+  n >= Z_of_nat wordsize ->
+  sign_ext n (sign_ext n x) = sign_ext n x.
+Proof.
+  intros. repeat (rewrite sign_ext_ge_wz; auto).
+Qed.
+
+Theorem sign_ext_equal_if_zero_equal:
+  forall x y,
+  zero_ext n x = zero_ext n y ->
+  sign_ext n x = sign_ext n y.
+Proof.
+  intros. rewrite <- (sign_ext_zero_ext x).
+  rewrite <- (sign_ext_zero_ext y). congruence.
+Qed.
+
+(** [zero_ext n x] is the unique integer congruent to [x] modulo [2^n]
+    in the range [0...2^n-1]. *)
+
+Lemma zero_ext_range:
+  forall x, 0 <= unsigned (zero_ext n x) < two_p n.
+Proof.
+  intros. rewrite zero_ext_mod; auto with zarith.
+  apply Z_mod_lt. apply two_p_gt_ZERO. omega.
+Qed.
+
+Lemma eqmod_zero_ext:
+  forall x, eqmod (two_p n) (unsigned (zero_ext n x)) (unsigned x).
+Proof.
+  intros. rewrite zero_ext_mod; auto with zarith.
+  apply eqmod_sym. apply eqmod_mod. apply two_p_gt_ZERO. omega.
+Qed.
+
+End EXTENSIONS'.
+
 Section EXTENSIONS.
 
 Variable n: Z.
@@ -2492,7 +2556,7 @@
 Remark two_p_n_range':
   two_p n <= max_signed + 1.
 Proof.
-  unfold max_signed. rewrite half_modulus_power. 
+  unfold max_signed. rewrite half_modulus_power.
   assert (two_p n <= two_p (Z_of_nat wordsize - 1)).
   apply two_p_monotone. omega.
   omega.
@@ -2501,7 +2565,7 @@
 Remark unsigned_repr_two_p:
   unsigned (repr (two_p n)) = two_p n.
 Proof.
-  apply unsigned_repr. apply two_p_n_range. 
+  apply unsigned_repr. apply two_p_n_range.
 Qed.
 
 Remark eqm_eqmod_two_p:
@@ -2519,27 +2583,17 @@
 Proof.
   intros; unfold zero_ext, and, bitwise_binop.
   decEq; apply Z_of_bits_exten; intros.
-  rewrite unsigned_repr. rewrite bits_of_Z_two_p. 
-  unfold proj_sumbool. destruct (zlt (i+0) n). 
-  rewrite andb_true_r; auto. rewrite andb_false_r; auto. 
-  omega. omega. 
+  rewrite unsigned_repr. rewrite bits_of_Z_two_p.
+  unfold proj_sumbool. destruct (zlt (i+0) n).
+  rewrite andb_true_r; auto. rewrite andb_false_r; auto.
+  omega. omega.
   generalize two_p_n_range two_p_n_pos; omega.
 Qed.
 
-Theorem zero_ext_mod:
-  forall x, unsigned (zero_ext n x) = Zmod (unsigned x) (two_p n).
-Proof.
-  intros.
-  replace (unsigned x) with (Z_of_bits wordsize (bits_of_Z wordsize (unsigned x)) 0).
-  unfold zero_ext. rewrite unsigned_repr; auto with ints. 
-  apply Z_of_bits_mod_mask. omega.
-  apply eqm_small_eq; auto with ints. apply Z_of_bits_of_Z.
-Qed.
-
 Theorem zero_ext_idem:
   forall x, zero_ext n (zero_ext n x) = zero_ext n x.
 Proof.
-  intros. repeat rewrite zero_ext_and. 
+  intros. repeat rewrite zero_ext_and.
   rewrite and_assoc. rewrite and_idem. auto.
 Qed.
 
@@ -2549,57 +2603,27 @@
   intros. unfold sign_ext.
   repeat rewrite unsigned_repr; auto with ints.
   decEq; apply Z_of_bits_exten; intros. rewrite Zplus_0_r.
-  repeat rewrite bits_of_Z_of_bits; auto. 
+  repeat rewrite bits_of_Z_of_bits; auto.
   destruct (zlt i n). auto. destruct (zlt (n - 1) n); auto.
   omega.
 Qed.
 
-Theorem sign_ext_zero_ext:
-  forall x, sign_ext n (zero_ext n x) = sign_ext n x.
-Proof.
-  intros. unfold sign_ext, zero_ext.
-  repeat rewrite unsigned_repr; auto with ints.
-  decEq; apply Z_of_bits_exten; intros. rewrite Zplus_0_r.
-  destruct (zlt i n); rewrite bits_of_Z_of_bits; auto.
-  rewrite zlt_true; auto. rewrite zlt_true; auto. omega. omega.
-Qed.
-
-Theorem zero_ext_sign_ext:
-  forall x, zero_ext n (sign_ext n x) = zero_ext n x.
-Proof.
-  intros. unfold sign_ext, zero_ext.
-  repeat rewrite unsigned_repr; auto with ints.
-  decEq; apply Z_of_bits_exten; intros. rewrite Zplus_0_r.
-  destruct (zlt i n); auto.
-  rewrite bits_of_Z_of_bits; auto.
-  rewrite zlt_true; auto.
-Qed.
-
-Theorem sign_ext_equal_if_zero_equal:
-  forall x y,
-  zero_ext n x = zero_ext n y ->
-  sign_ext n x = sign_ext n y.
-Proof.
-  intros. rewrite <- (sign_ext_zero_ext x).
-  rewrite <- (sign_ext_zero_ext y). congruence.
-Qed.
-
 Theorem zero_ext_shru_shl:
-  forall x, 
+  forall x,
   let y := repr (Z_of_nat wordsize - n) in
   zero_ext n x = shru (shl x y) y.
 Proof.
   intros.
   assert (unsigned y = Z_of_nat wordsize - n).
     unfold y. apply unsigned_repr. generalize wordsize_max_unsigned. omega.
-  rewrite zero_ext_and. symmetry. 
+  rewrite zero_ext_and. symmetry.
   replace n with (Z_of_nat wordsize - unsigned y).
   apply shru_shl_and. unfold ltu. apply zlt_true.
   rewrite H. rewrite unsigned_repr_wordsize. omega. omega.
 Qed.
 
 Theorem sign_ext_shr_shl:
-  forall x, 
+  forall x,
   let y := repr (Z_of_nat wordsize - n) in
   sign_ext n x = shr (shl x y) y.
 Proof.
@@ -2610,27 +2634,11 @@
   repeat rewrite unsigned_repr; auto with ints.
   decEq; apply Z_of_bits_exten; intros; rewrite Zplus_0_r.
   destruct (zlt i n). rewrite zlt_true. rewrite bits_of_Z_of_bits_gen.
-  decEq. omega.  omega. omega. 
-  rewrite zlt_false. rewrite bits_of_Z_of_bits_gen. 
+  decEq. omega.  omega. omega.
+  rewrite zlt_false. rewrite bits_of_Z_of_bits_gen.
   decEq. omega. omega. omega.
 Qed.
 
-(** [zero_ext n x] is the unique integer congruent to [x] modulo [2^n]
-    in the range [0...2^n-1]. *)
-
-Lemma zero_ext_range:
-  forall x, 0 <= unsigned (zero_ext n x) < two_p n.
-Proof.
-  intros. rewrite zero_ext_mod. apply Z_mod_lt. apply two_p_gt_ZERO. omega. 
-Qed.
-
-Lemma eqmod_zero_ext:
-  forall x, eqmod (two_p n) (unsigned (zero_ext n x)) (unsigned x).
-Proof.
-  intros. rewrite zero_ext_mod. apply eqmod_sym. apply eqmod_mod. 
-  apply two_p_gt_ZERO. omega.
-Qed.
-
 (** [sign_ext n x] is the unique integer congruent to [x] modulo [2^n]
     in the range [-2^(n-1)...2^(n-1) - 1]. *)
 
@@ -2639,16 +2647,16 @@
   signed (sign_ext n x) =
   signed (repr (unsigned x * two_p (Z_of_nat wordsize - n))) / two_p (Z_of_nat wordsize - n).
 Proof.
-  intros. 
+  intros.
   assert (two_p (Z_of_nat wordsize - n) > 0). apply two_p_gt_ZERO. omega.
   rewrite sign_ext_shr_shl. rewrite shr_div_two_p. rewrite shl_mul_two_p.
-  unfold mul. repeat rewrite unsigned_repr. rewrite signed_repr. auto. 
-  apply Zdiv_interval_2. apply signed_range. 
+  unfold mul. repeat rewrite unsigned_repr. rewrite signed_repr. auto.
+  apply Zdiv_interval_2. apply signed_range.
   generalize min_signed_neg; omega. apply max_signed_pos.
   auto.
   generalize wordsize_max_unsigned; omega.
-  assert (two_p (Z_of_nat wordsize - n) < modulus). 
-    rewrite modulus_power. apply two_p_monotone_strict. omega. 
+  assert (two_p (Z_of_nat wordsize - n) < modulus).
+    rewrite modulus_power. apply two_p_monotone_strict. omega.
   unfold max_unsigned. omega.
   generalize wordsize_max_unsigned; omega.
 Qed.
@@ -2661,21 +2669,21 @@
   rewrite sign_ext_div. apply Zdiv_interval_1. omega. auto. apply two_p_gt_ZERO; omega.
   rewrite <- Zopp_mult_distr_l. rewrite <- two_p_is_exp.
   replace (n - 1 + (Z_of_nat wordsize - n)) with (Z_of_nat wordsize - 1) by omega.
-  rewrite <- half_modulus_power. 
+  rewrite <- half_modulus_power.
   generalize (signed_range (repr (unsigned x * two_p (Z_of_nat wordsize - n)))).
-  unfold min_signed, max_signed. omega. 
+  unfold min_signed, max_signed. omega.
   omega. omega.
 Qed.
 
 Lemma eqmod_sign_ext:
   forall x, eqmod (two_p n) (signed (sign_ext n x)) (unsigned x).
 Proof.
-  intros. rewrite sign_ext_div. 
+  intros. rewrite sign_ext_div.
   assert (eqm (signed (repr (unsigned x * two_p (Z_of_nat wordsize - n))))
               (unsigned x * two_p (Z_of_nat wordsize - n))).
   eapply eqm_trans. apply eqm_signed_unsigned. apply eqm_sym. apply eqm_unsigned_repr.
   destruct H as [k EQ]. exists k.
-  rewrite EQ. rewrite Z_div_plus. decEq. 
+  rewrite EQ. rewrite Z_div_plus. decEq.
   replace modulus with (two_p (n + (Z_of_nat wordsize - n))).
   rewrite two_p_is_exp. rewrite Zmult_assoc. apply Z_div_mult.
   apply two_p_gt_ZERO; omega.
@@ -2687,9 +2695,9 @@
 Lemma eqmod_sign_ext':
   forall x, eqmod (two_p n) (unsigned (sign_ext n x)) (unsigned x).
 Proof.
-  intros. eapply eqmod_trans. 
-  apply eqm_eqmod_two_p. auto. apply eqm_sym. apply eqm_signed_unsigned. 
-  apply eqmod_sign_ext. 
+  intros. eapply eqmod_trans.
+  apply eqm_eqmod_two_p. auto. apply eqm_sym. apply eqm_signed_unsigned.
+  apply eqmod_sign_ext.
 Qed.
 
 End EXTENSIONS.
@@ -2702,8 +2710,8 @@
   intros. unfold zero_ext.
   repeat rewrite unsigned_repr; auto with ints.
   decEq; apply Z_of_bits_exten; intros; rewrite Zplus_0_r.
-  destruct (zlt i n). rewrite zlt_true. rewrite bits_of_Z_of_bits. apply zlt_true. 
-  auto. omega. omega. 
+  destruct (zlt i n). rewrite zlt_true. rewrite bits_of_Z_of_bits. apply zlt_true.
+  auto. omega. omega.
   destruct (zlt i n'); auto. rewrite bits_of_Z_of_bits. apply zlt_false.
   auto. omega.
 Qed.
@@ -2716,13 +2724,13 @@
   intros. unfold sign_ext.
   repeat rewrite unsigned_repr; auto with ints.
   decEq; apply Z_of_bits_exten; intros; rewrite Zplus_0_r.
-  destruct (zlt i n). rewrite zlt_true. rewrite bits_of_Z_of_bits. apply zlt_true. 
-  auto. omega. omega. 
+  destruct (zlt i n). rewrite zlt_true. rewrite bits_of_Z_of_bits. apply zlt_true.
+  auto. omega. omega.
   destruct (zlt i n'). rewrite bits_of_Z_of_bits. apply zlt_false.
   auto. omega.
   rewrite bits_of_Z_of_bits.
   destruct (zlt (n' - 1) n). assert (n' = n) by omega. congruence. auto.
-  omega. 
+  omega.
 Qed.
 
 Theorem sign_zero_ext_widen:
@@ -2733,8 +2741,8 @@
   intros. unfold sign_ext, zero_ext.
   repeat rewrite unsigned_repr; auto with ints.
   decEq; apply Z_of_bits_exten; intros; rewrite Zplus_0_r.
-  destruct (zlt i n). rewrite zlt_true. rewrite bits_of_Z_of_bits. apply zlt_true. 
-  auto. omega. omega. 
+  destruct (zlt i n). rewrite zlt_true. rewrite bits_of_Z_of_bits. apply zlt_true.
+  auto. omega. omega.
   destruct (zlt i n'). rewrite bits_of_Z_of_bits. apply zlt_false.
   auto. omega.
   rewrite bits_of_Z_of_bits. apply zlt_false. omega. omega.
@@ -2742,17 +2750,18 @@
 
 (** ** Properties of [one_bits] (decomposition in sum of powers of two) *)
 
+Opaque Z_one_bits. (* Otherwise, next Qed blows up! *)
+
 Theorem one_bits_range:
   forall x i, In i (one_bits x) -> ltu i iwordsize = true.
 Proof.
-  assert (A: forall p, 0 <= p < Z_of_nat wordsize -> ltu (repr p) iwordsize = true).
-    intros. unfold ltu, iwordsize. apply zlt_true. 
-    repeat rewrite unsigned_repr. tauto. 
-    generalize wordsize_max_unsigned. omega.
-    generalize wordsize_max_unsigned. omega.
   intros. unfold one_bits in H.
-  destruct (list_in_map_inv _ _ _ H) as [i0 [EQ IN]].
-  subst i. apply A. apply Z_one_bits_range with (unsigned x); auto.
+  elim (list_in_map_inv _ _ _ H). intros i0 [EQ IN].
+  subst i. unfold ltu. unfold iwordsize. apply zlt_true.
+  generalize (Z_one_bits_range _ _ IN). intros.
+  assert (0 <= Z_of_nat wordsize <= max_unsigned).
+    generalize wordsize_pos wordsize_max_unsigned; omega.
+  repeat rewrite unsigned_repr; omega.
 Qed.
 
 Fixpoint int_of_one_bits (l: list int) : int :=
@@ -2764,21 +2773,21 @@
 Theorem one_bits_decomp:
   forall x, x = int_of_one_bits (one_bits x).
 Proof.
-  intros. 
+  intros.
   transitivity (repr (powerserie (Z_one_bits wordsize (unsigned x) 0))).
   transitivity (repr (unsigned x)).
   auto with ints. decEq. apply Z_one_bits_powerserie.
   auto with ints.
-  unfold one_bits. 
+  unfold one_bits.
   generalize (Z_one_bits_range (unsigned x)).
   generalize (Z_one_bits wordsize (unsigned x) 0).
   induction l.
   intros; reflexivity.
   intros; simpl. rewrite <- IHl. unfold add. apply eqm_samerepr.
-  apply eqm_add. rewrite shl_mul_two_p. rewrite mul_commut. 
-  rewrite mul_one. apply eqm_unsigned_repr_r. 
+  apply eqm_add. rewrite shl_mul_two_p. rewrite mul_commut.
+  rewrite mul_one. apply eqm_unsigned_repr_r.
   rewrite unsigned_repr. auto with ints.
-  generalize (H a (in_eq _ _)). generalize wordsize_max_unsigned. omega.  
+  generalize (H a (in_eq _ _)). generalize wordsize_max_unsigned. omega.
   auto with ints.
   intros; apply H; auto with coqlib.
 Qed.
@@ -2815,7 +2824,7 @@
 Proof.
   intros. unfold eq. case (zeq (unsigned x) (unsigned y)); intro.
   unfold add. rewrite e. apply zeq_true.
-  apply zeq_false. unfold add. red; intro. apply n. 
+  apply zeq_false. unfold add. red; intro. apply n.
   apply eqm_small_eq; auto with ints.
   replace (unsigned x) with ((unsigned x + unsigned d) - unsigned d).
   replace (unsigned y) with ((unsigned y + unsigned d) - unsigned d).
@@ -2825,28 +2834,6 @@
   omega. omega.
 Qed.
 
-Lemma translate_ltu:
-  forall x y d,
-  0 <= unsigned x + unsigned d <= max_unsigned ->
-  0 <= unsigned y + unsigned d <= max_unsigned ->
-  ltu (add x d) (add y d) = ltu x y.
-Proof.
-  intros. unfold add. unfold ltu.
-  repeat rewrite unsigned_repr; auto. case (zlt (unsigned x) (unsigned y)); intro.
-  apply zlt_true. omega.
-  apply zlt_false. omega.
-Qed.
-
-Theorem translate_cmpu:
-  forall c x y d,
-  0 <= unsigned x + unsigned d <= max_unsigned ->
-  0 <= unsigned y + unsigned d <= max_unsigned ->
-  cmpu c (add x d) (add y d) = cmpu c x y.
-Proof.
-  intros. unfold cmpu.
-  rewrite translate_eq. repeat rewrite translate_ltu; auto.
-Qed.  
-
 Lemma translate_lt:
   forall x y d,
   min_signed <= signed x + signed d <= max_signed ->
@@ -2867,13 +2854,13 @@
 Proof.
   intros. unfold cmp.
   rewrite translate_eq. repeat rewrite translate_lt; auto.
-Qed.  
+Qed.
 
 Theorem notbool_isfalse_istrue:
   forall x, is_false x -> is_true (notbool x).
 Proof.
-  unfold is_false, is_true, notbool; intros; subst x. 
-  rewrite eq_true. apply one_not_zero. 
+  unfold is_false, is_true, notbool; intros; subst x.
+  rewrite eq_true. apply one_not_zero.
 Qed.
 
 Theorem notbool_istrue_isfalse:
@@ -2888,20 +2875,20 @@
   forall x,
   shru x (repr (Z_of_nat wordsize - 1)) = if lt x zero then one else zero.
 Proof.
-  intros. rewrite shru_div_two_p. 
+  intros. rewrite shru_div_two_p.
   replace (two_p (unsigned (repr (Z_of_nat wordsize - 1))))
     with half_modulus.
-  generalize (unsigned_range x); intro. 
-  unfold lt. rewrite signed_zero. unfold signed. 
+  generalize (unsigned_range x); intro.
+  unfold lt. rewrite signed_zero. unfold signed.
   destruct (zlt (unsigned x) half_modulus).
   rewrite zlt_false.
-  replace (unsigned x / half_modulus) with 0. reflexivity. 
+  replace (unsigned x / half_modulus) with 0. reflexivity.
   symmetry. apply Zdiv_unique with (unsigned x). ring. omega. omega.
-  rewrite zlt_true. 
+  rewrite zlt_true.
   replace (unsigned x / half_modulus) with 1. reflexivity.
   symmetry. apply Zdiv_unique with (unsigned x - half_modulus). ring.
   rewrite half_modulus_modulus in H. omega. omega.
-  rewrite unsigned_repr. apply half_modulus_power. 
+  rewrite unsigned_repr. apply half_modulus_power.
   generalize wordsize_pos wordsize_max_unsigned; omega.
 Qed.
 
@@ -2916,44 +2903,28 @@
   generalize (unsigned_range x). omega. omega.
 Qed.
 
-End Make.
+End Integers.
+
+End Int.
 
 (** * Specialization to integers of size 8, 32, and 64 bits *)
 
-Module Wordsize_32.
-  Definition wordsize := 32%nat.
-  Remark wordsize_not_zero: wordsize <> 0%nat.
-  Proof. unfold wordsize; congruence. Qed.
-End Wordsize_32.
+Notation int32 := (Int.int 31).
 
-Module Int := Make(Wordsize_32).
+Notation byte := (Int.int 7).
 
-Notation int := Int.int.
+Notation int64 := (Int.int 63).
 
-Remark int_wordsize_divides_modulus:
-  Zdivide (Z_of_nat Int.wordsize) Int.modulus.
+Remark int32_wordsize_divides_modulus:
+  Zdivide (Z_of_nat 32) (Int.modulus 31).
 Proof.
-  exists (two_p (32-5)); reflexivity. 
+  exists (two_p (32-5)); reflexivity.
 Qed.
 
-Module Wordsize_8.
-  Definition wordsize := 8%nat.
-  Remark wordsize_not_zero: wordsize <> 0%nat.
-  Proof. unfold wordsize; congruence. Qed.
-End Wordsize_8.
-
-Module Byte := Make(Wordsize_8).
-
-Notation byte := Byte.int.
-
-Module Wordsize_64.
-  Definition wordsize := 64%nat.
-  Remark wordsize_not_zero: wordsize <> 0%nat.
-  Proof. unfold wordsize; congruence. Qed.
-End Wordsize_64.
-
-Module Int64 := Make(Wordsize_64).
-
-Notation int64 := Int64.int.
-
+Lemma min_le_zero_le_max: Int.min_signed 31 <= 0 <= Int.max_signed 31.
+Proof.
+  unfold Int.max_signed, Int.min_signed, Int.half_modulus,
+         Int.modulus, Int.wordsize.
+  simpl. auto with zarith.
+Qed.
 
diff -ruN lib/compcert-1.9/Iteration.v lib.patched/compcert-1.9/Iteration.v
--- lib/compcert-1.9/Iteration.v	2014-08-30 20:09:04.806089049 -0400
+++ lib.patched/compcert-1.9/Iteration.v	2014-08-30 00:29:06.156255495 -0400
@@ -36,7 +36,7 @@
 
 (* A constructive implementation using bounded iteration. *)
 
-Module PrimIter: ITER.
+Module PrimIter <: ITER.
 
 Section ITERATION.
 
@@ -165,8 +165,189 @@
 
 End ITERATION.
 
+Section MoreITERATION.
+
+Variable A1 A2 B1 B2 : Type. 
+Variable step1 : A1 -> B1 + A1.
+Variable step2 : A2 -> B2 + A2.
+Variable P : A1 -> A2 -> Prop.
+
+Hypothesis step_none2: forall (a1 : A1) (a2 : A2),
+  P a1 a2 -> 
+  match step1 a1, step2 a2 with
+  | inl b1, inl b2 => True
+  | inr a1', inr a2' => P a1' a2'
+  | _, _ => False
+  end.
+
+Definition P_iter_none2_right p := forall a1 a2, 
+  P a1 a2 -> 
+  iter _ _ step2 p a2 = None -> iter _ _ step1 p a1 = None.
+
+Lemma iter_none2_right: forall n, P_iter_none2_right n.
+Proof.
+  apply (well_founded_ind Plt_wf (fun p => P_iter_none2_right p)).
+  unfold P_iter_none2_right.
+  intros until a2. intro H0. repeat rewrite unroll_iter.
+  unfold iter_step. 
+  case (peq x 1); intro; try congruence.
+  generalize (step_none2 a1 a2 H0).
+  case (step1 a1).
+    case (step2 a2); intros; try congruence; inv H1.
+    case (step2 a2); intros; try inv H1.
+      apply H with (a2:=a); auto.
+      apply Ppred_Plt; auto. 
+Qed.
+
+Lemma iterate_none2_right: forall (a1: A1) (a2: A2),
+  P a1 a2 ->
+  PrimIter.iterate A2 B2 step2 a2 = None ->
+  PrimIter.iterate A1 B1 step1 a1 = None. 
+Proof.
+  intros. unfold PrimIter.iterate in *.
+  assert (J:=@iter_none2_right num_iterations). eauto.
+Qed.
+
+Definition P_iter_none2_left p := forall a1 a2, 
+  P a1 a2 -> 
+  iter _ _ step1 p a1 = None -> iter _ _ step2 p a2 = None.
+
+Lemma iter_none2_left: forall n, P_iter_none2_left n.
+Proof.
+  apply (well_founded_ind Plt_wf (fun p => P_iter_none2_left p)).
+  unfold P_iter_none2_left.
+  intros until a2. intro H0. repeat rewrite unroll_iter.
+  unfold iter_step. 
+  case (peq x 1); intro; try congruence.
+  generalize (step_none2 a1 a2 H0).
+  case (step1 a1).
+    case (step2 a2); intros; try congruence; inv H1.
+    case (step2 a2); intros; try inv H1.
+      apply H with (a1:=a0); auto.
+      apply Ppred_Plt; auto. 
+Qed.
+
+Lemma iterate_none2_left: forall (a1: A1) (a2: A2),
+  P a1 a2 ->
+  PrimIter.iterate A1 B1 step1 a1 = None -> 
+  PrimIter.iterate A2 B2 step2 a2 = None.
+Proof.
+  intros. unfold PrimIter.iterate in *.
+  assert (J:=@iter_none2_left num_iterations). eauto.
+Qed.
+
+Variable Q : B1 -> B2 -> Prop.
+
+Hypothesis step_some2: forall (a1 : A1) (a2 : A2),
+  P a1 a2 -> 
+  match step1 a1, step2 a2 with
+  | inl b1, inl b2 => Q b1 b2
+  | inr a1', inr a2' => P a1' a2'
+  | _, _ => False
+  end.
+
+Definition P_iter_some2 p := forall a1 a2 b1 b2, 
+  P a1 a2 -> 
+  iter _ _ step1 p a1 = Some b1 -> iter _ _ step2 p a2 = Some b2 -> 
+  Q b1 b2.
+
+Lemma iter_some2: forall n, P_iter_some2 n.
+Proof.
+  apply (well_founded_ind Plt_wf (fun p => P_iter_some2 p)).
+  unfold P_iter_some2.
+  intros until b2. intro H0. repeat rewrite unroll_iter.
+  unfold iter_step. 
+  case (peq x 1); intro; try congruence.
+  generalize (step_some2 a1 a2 H0).
+  case (step1 a1).
+    case (step2 a2); intros; try congruence; inv H1.
+    case (step2 a2); intros; try inv H1.
+      apply H with (Ppred x) a0 a; auto.
+      apply Ppred_Plt; auto. 
+Qed.
+
+Lemma iterate_some2: forall (a1: A1) (b1: B1) (a2: A2) (b2: B2),
+  PrimIter.iterate A1 B1 step1 a1 = Some b1 -> 
+  PrimIter.iterate A2 B2 step2 a2 = Some b2 -> 
+  P a1 a2 -> Q b1 b2.
+Proof.
+  intros. apply iter_some2 with num_iterations a1 a2; assumption.
+Qed.
+
+End MoreITERATION.
+
 End PrimIter.
 
+Module SafePrimIter.
+
+Section ITERATION.
+
+Variables A: Type.
+Variable step: A -> A + A.
+
+Definition iter_step (x: positive)
+                     (next: forall y, Plt y x -> A -> A)
+                     (s: A) : A :=
+  match peq x xH with
+  | left EQ => s
+  | right NOTEQ =>
+      match step s with
+      | inl res => res
+      | inr s'  => next (Ppred x) (Ppred_Plt x NOTEQ) s'
+      end
+  end.
+
+Definition iter: positive -> A -> A :=
+  Fix Plt_wf (fun _ => A -> A) iter_step.
+
+Definition num_iterations := 1000000000000%positive.
+
+(** We then prove the expected unrolling equations for [iter]. *)
+
+Remark unroll_iter:
+  forall x, iter x = iter_step x (fun y _ => iter y).
+Proof.
+  unfold iter; apply (Fix_eq Plt_wf (fun _ => A -> A) iter_step).
+  intros. unfold iter_step. apply extensionality. intro s. 
+  case (peq x xH); intro. auto. 
+  rewrite H. auto. 
+Qed.
+
+(** The [iterate] function is defined as [iter] up to
+    [num_iterations] through the loop. *)
+
+Definition iterate := iter num_iterations.
+
+(** We now prove the invariance property [iterate_prop]. *)
+
+Variable P: A -> Prop.
+
+Hypothesis step_prop:
+  forall a : A, P a ->
+  match step a with inl b => P b | inr a' => P a' end.
+
+Lemma iter_prop:
+  forall n a b, P a -> iter n a = b -> P b.
+Proof.
+  apply (well_founded_ind Plt_wf 
+         (fun p => forall a b, P a -> iter p a = b -> P b)).
+  intros until b. intro. rewrite unroll_iter.
+  unfold iter_step. case (peq x 1); intro. congruence.
+  generalize (step_prop a H0).
+  case (step a); intros. congruence. 
+  apply H with (Ppred x) a0. apply Ppred_Plt; auto. auto. auto.
+Qed.
+
+Lemma iterate_prop:
+  forall a b, iterate a = b -> P a -> P b.
+Proof.
+  intros. apply iter_prop with num_iterations a; assumption.
+Qed.
+
+End ITERATION.
+
+End SafePrimIter.
+
 (* An implementation using classical logic and unbounded iteration,
   in the style of Yves Bertot's paper, "Extending the Calculus
   of Constructions with Tarski's fix-point theorem". *)
@@ -304,3 +485,4 @@
 End ITERATION.
 
 End GenIter.
+
diff -ruN lib/compcert-1.9/Kildall.v lib.patched/compcert-1.9/Kildall.v
--- lib/compcert-1.9/Kildall.v	2014-08-30 20:09:04.806089049 -0400
+++ lib.patched/compcert-1.9/Kildall.v	2014-08-30 00:29:06.156255495 -0400
@@ -16,23 +16,24 @@
 Require Import Iteration.
 Require Import Maps.
 Require Import Lattice.
+Require Import Metatheory.
 
 (** A forward dataflow problem is a set of inequations of the form
-- [X(s) >= transf n X(n)] 
+- [X(s) >= transf n X(n)]
   if program point [s] is a successor of program point [n]
 - [X(n) >= a]
   if [(n, a)] belongs to a given list of (program points, approximations).
 
 The unknowns are the [X(n)], indexed by program points (e.g. nodes in the
-CFG graph of a RTL function).  They range over a given ordered set that 
+CFG graph of a RTL function).  They range over a given ordered set that
 represents static approximations of the program state at each point.
-The [transf] function is the abstract transfer function: it computes an 
+The [transf] function is the abstract transfer function: it computes an
 approximation [transf n X(n)] of the program state after executing instruction
 at point [n], as a function of the approximation [X(n)] of the program state
 before executing that instruction.
 
 Symmetrically, a backward dataflow problem is a set of inequations of the form
-- [X(n) >= transf s X(s)] 
+- [X(n) >= transf s X(s)]
   if program point [s] is a successor of program point [n]
 - [X(n) >= a]
   if [(n, a)] belongs to a given list of (program points, approximations).
@@ -55,11 +56,6 @@
 
 (** * Solving forward dataflow problems using Kildall's algorithm *)
 
-Definition successors_list (successors: PTree.t (list positive)) (pc: positive) : list positive :=
-  match successors!pc with None => nil | Some l => l end.
-
-Notation "a !!! b" := (successors_list a b) (at level 1).
-
 (** A forward dataflow solver has the following generic interface.
   Unknowns range over the type [L.t], which is equipped with
   semi-lattice operations (see file [Lattice]).  *)
@@ -69,10 +65,10 @@
   Declare Module L: SEMILATTICE.
 
   Variable fixpoint:
-    forall (successors: PTree.t (list positive))
-           (transf: positive -> L.t -> L.t)
-           (entrypoints: list (positive * L.t)),
-    option (PMap.t L.t).
+    forall (successors: ATree.t (list atom))
+           (transf: atom -> L.t -> L.t)
+           (entrypoints: list (atom * L.t)),
+    option (AMap.t L.t).
 
   (** [fixpoint successors transf entrypoints] is the solver.
     It returns either an error or a mapping from program points to
@@ -97,11 +93,11 @@
     L.ge res!!n v.
 
   (** The [fixpoint_entry] theorem shows that the returned solution,
-    if any, satisfies the additional constraints expressed 
+    if any, satisfies the additional constraints expressed
     by [entrypoints]. *)
 
   Hypothesis fixpoint_invariant:
-    forall successors transf entrypoints 
+    forall successors transf entrypoints
            (P: L.t -> Prop),
     P L.bot ->
     (forall x y, P x -> P y -> P (L.lub x y)) ->
@@ -115,6 +111,25 @@
       and that holds for [L.bot] also holds for the results of
       the analysis. *)
 
+  Hypothesis fixpoint_inv:
+    forall (successors: ATree.t (list atom)) (transf: atom -> L.t -> L.t)
+           (entrypoints: list (atom * L.t)) (P: atom -> L.t -> Prop)
+    (P_bot: forall n, P n L.bot)
+    (P_lub: forall n x y, P n x -> P n y -> P n (L.lub x y))
+    (P_transf: forall pc sc x y (Hin: In sc (successors!!!pc))
+      (HPx: P pc x) (HPy: P sc y), P sc (L.lub y (transf pc x)))
+    (P_entrypoints: forall n v, In (n, v) entrypoints -> P n v)
+    (transf_mono: forall p x y,
+       L.ge x y -> L.ge (transf p x) (transf p y))
+    (ge_lub: forall x y1 y2, 
+       L.ge y1 y2 -> L.ge (L.lub x y1) (L.lub x y2))
+    (P_ge: forall n x y, L.ge x y -> P n x -> P n y),
+    forall res,
+    fixpoint successors transf entrypoints = Some res ->
+    forall pc, P pc res!!pc.
+
+  (** A variant of fixpoint_invariant *)
+
 End DATAFLOW_SOLVER.
 
 (** Kildall's algorithm manipulates worklists, which are sets of CFG nodes
@@ -127,11 +142,11 @@
 Module Type NODE_SET.
 
   Variable t: Type.
-  Variable add: positive -> t -> t.
-  Variable pick: t -> option (positive * t).
-  Variable initial: PTree.t (list positive) -> t.
+  Variable add: atom -> t -> t.
+  Variable pick: t -> option (atom * t).
+  Variable initial: ATree.t (list atom) -> t.
 
-  Variable In: positive -> t -> Prop.
+  Variable In: atom -> t -> Prop.
   Hypothesis add_spec:
     forall n n' s, In n' (add n s) <-> n = n' \/ In n' s.
   Hypothesis pick_none:
@@ -145,7 +160,7 @@
 
 End NODE_SET.
 
-(** We now define a generic solver that works over 
+(** We now define a generic solver that works over
     any semi-lattice structure. *)
 
 Module Dataflow_Solver (LAT: SEMILATTICE) (NS: NODE_SET):
@@ -155,9 +170,9 @@
 
 Section Kildall.
 
-Variable successors: PTree.t (list positive).
-Variable transf: positive -> L.t -> L.t.
-Variable entrypoints: list (positive * L.t).
+Variable successors: ATree.t (list atom).
+Variable transf: atom -> L.t -> L.t.
+Variable entrypoints: list (atom * L.t).
 
 (** The state of the iteration has two components:
 - A mapping from program points to values of type [L.t] representing
@@ -166,7 +181,7 @@
 *)
 
 Record state : Type :=
-  mkstate { st_in: PMap.t L.t; st_wrk: NS.t }.
+  mkstate { st_in: AMap.t L.t; st_wrk: NS.t }.
 
 (** Kildall's algorithm, in pseudo-code, is as follows:
 <<
@@ -192,12 +207,12 @@
   approximations, we actually take the l.u.b. of these approximations.
 - The initial worklist contains all the program points. *)
 
-Fixpoint start_state_in (ep: list (positive * L.t)) : PMap.t L.t :=
+Fixpoint start_state_in (ep: list (atom * L.t)) : AMap.t L.t :=
   match ep with
   | nil =>
-      PMap.init L.bot
+      AMap.init L.bot
   | (n, v) :: rem =>
-      let m := start_state_in rem in PMap.set n (L.lub m!!n v) m
+      let m := start_state_in rem in AMap.set n (L.lub m!!n v) m
   end.
 
 Definition start_state :=
@@ -206,17 +221,17 @@
 (** [propagate_succ] corresponds, in the pseudocode,
   to the body of the [for] loop iterating over all successors. *)
 
-Definition propagate_succ (s: state) (out: L.t) (n: positive) :=
+Definition propagate_succ (s: state) (out: L.t) (n: atom) :=
   let oldl := s.(st_in)!!n in
   let newl := L.lub oldl out in
   if L.beq oldl newl
   then s
-  else mkstate (PMap.set n newl s.(st_in)) (NS.add n s.(st_wrk)).
+  else mkstate (AMap.set n newl s.(st_in)) (NS.add n s.(st_wrk)).
 
 (** [propagate_succ_list] corresponds, in the pseudocode,
   to the [for] loop iterating over all successors. *)
 
-Fixpoint propagate_succ_list (s: state) (out: L.t) (succs: list positive)
+Fixpoint propagate_succ_list (s: state) (out: L.t) (succs: list atom)
                              {struct succs} : state :=
   match succs with
   | nil => s
@@ -226,9 +241,9 @@
 (** [step] corresponds to the body of the outer [while] loop in the
   pseudocode. *)
 
-Definition step (s: state) : PMap.t L.t + state :=
+Definition step (s: state) : AMap.t L.t + state :=
   match NS.pick s.(st_wrk) with
-  | None => 
+  | None =>
       inl _ s.(st_in)
   | Some(n, rem) =>
       inr _ (propagate_succ_list
@@ -240,7 +255,7 @@
 (** The whole fixpoint computation is the iteration of [step] from
   the start state. *)
 
-Definition fixpoint : option (PMap.t L.t) :=
+Definition fixpoint : option (AMap.t L.t) :=
   PrimIter.iterate _ _ step start_state.
 
 (** ** Monotonicity properties *)
@@ -249,7 +264,7 @@
   at each step, the values of the [st_in[n]] either remain the same or
   increase with respect to the [L.ge] ordering. *)
 
-Definition in_incr (in1 in2: PMap.t L.t) : Prop :=
+Definition in_incr (in1 in2: AMap.t L.t) : Prop :=
   forall n, L.ge in2!!n in1!!n.
 
 Lemma in_incr_refl:
@@ -271,9 +286,9 @@
   unfold in_incr, propagate_succ; simpl; intros.
   case (L.beq st.(st_in)!!n (L.lub st.(st_in)!!n out)).
   apply L.ge_refl. apply L.eq_refl.
-  simpl. case (peq n n0); intro.
-  subst n0. rewrite PMap.gss. apply L.ge_lub_left.
-  rewrite PMap.gso; auto. apply L.ge_refl. apply L.eq_refl.
+  simpl. case (eq_atom_dec n n0); intro.
+  subst n0. rewrite AMap.gss. apply L.ge_lub_left.
+  rewrite AMap.gso; auto. apply L.ge_refl. apply L.eq_refl.
 Qed.
 
 Lemma propagate_succ_list_incr:
@@ -282,9 +297,9 @@
 Proof.
   induction scs; simpl; intros.
   apply in_incr_refl.
-  apply in_incr_trans with (propagate_succ st out a).(st_in). 
+  apply in_incr_trans with (propagate_succ st out a).(st_in).
   apply propagate_succ_incr. auto.
-Qed. 
+Qed.
 
 Lemma fixpoint_incr:
   forall res,
@@ -298,10 +313,10 @@
 
   intros st INCR. unfold step.
   destruct (NS.pick st.(st_wrk)) as [ [n rem] | ].
-  apply in_incr_trans with st.(st_in). auto. 
-  change st.(st_in) with (mkstate st.(st_in) rem).(st_in). 
-  apply propagate_succ_list_incr. 
-  auto. 
+  apply in_incr_trans with st.(st_in). auto.
+  change st.(st_in) with (mkstate st.(st_in) rem).(st_in).
+  apply propagate_succ_list_incr.
+  auto.
 
   eauto. apply in_incr_refl.
 Qed.
@@ -330,7 +345,7 @@
   unfold good_state, start_state; intros.
   case_eq (successors!n); intros.
   left; simpl. eapply NS.initial_spec. eauto.
-  unfold successors_list. rewrite H. right; intros. contradiction.
+  unfold XATree.successors_list. rewrite H. right; intros. contradiction.
 Qed.
 
 Lemma propagate_succ_charact:
@@ -344,13 +359,15 @@
            ((st_in st) !! n) (L.lub (st_in st) !! n out).
   split.
   eapply L.ge_trans. apply L.ge_refl. apply H; auto.
-  apply L.ge_lub_right. 
+  eapply L.ge_compat. apply L.lub_commut. apply L.eq_refl.
+  apply L.ge_lub_left.
   auto.
 
   simpl. split.
-  rewrite PMap.gss.
-  apply L.ge_lub_right.
-  intros. rewrite PMap.gso; auto.
+  rewrite AMap.gss.
+  eapply L.ge_compat. apply L.lub_commut. apply L.eq_refl.
+  apply L.ge_lub_left.
+  intros. rewrite AMap.gso; auto.
 Qed.
 
 Lemma propagate_succ_list_charact:
@@ -369,6 +386,7 @@
   subst s.
   apply L.ge_trans with (propagate_succ st out a).(st_in)!!a.
   apply propagate_succ_list_incr. assumption.
+
   apply A. auto.
   transitivity (propagate_succ st out a).(st_in)!!s.
   apply B. tauto.
@@ -379,7 +397,7 @@
   forall st out n x,
   NS.In x st.(st_wrk) -> NS.In x (propagate_succ st out n).(st_wrk).
 Proof.
-  intros. unfold propagate_succ. 
+  intros. unfold propagate_succ.
   case (L.beq (st_in st) !! n (L.lub (st_in st) !! n out)).
   auto.
   simpl. rewrite NS.add_spec. auto.
@@ -399,12 +417,12 @@
   let st' := propagate_succ st out n in
   NS.In s st'.(st_wrk) \/ st'.(st_in)!!s = st.(st_in)!!s.
 Proof.
-  simpl. intros. unfold propagate_succ. 
+  simpl. intros. unfold propagate_succ.
   case (L.beq (st_in st) !! n (L.lub (st_in st) !! n out)).
   right; auto.
-  case (peq s n); intro.
+  case (eq_atom_dec s n); intro.
   subst s. left. simpl. rewrite NS.add_spec. auto.
-  right. simpl. apply PMap.gso. auto.
+  right. simpl. apply AMap.gso. auto.
 Qed.
 
 Lemma propagate_succ_list_records_changes:
@@ -430,12 +448,13 @@
   unfold good_state. intros st n rem WKL GOOD x.
   generalize (NS.pick_some _ _ _ WKL); intro PICK.
   set (out := transf n st.(st_in)!!n).
-  elim (propagate_succ_list_records_changes 
+  elim (propagate_succ_list_records_changes
           out (successors!!!n) (mkstate st.(st_in) rem) x).
   intro; left; auto.
+
   simpl; intros EQ. rewrite EQ.
+  case (eq_atom_dec x n); intro.
   (* Case 1: x = n *)
-  case (peq x n); intro.
   subst x.
   right; intros.
   elim (propagate_succ_list_charact out (successors!!!n)
@@ -448,11 +467,11 @@
   simpl. rewrite PICK in H. elim H; intro. congruence. auto.
   (* Case 2.2: x was not in worklist *)
   right; intros.
-  case (In_dec peq s (successors!!!n)); intro.
+  case (In_dec eq_atom_dec s (successors!!!n)); intro.
   (* Case 2.2.1: s is a successor of n, it may have increased *)
   apply L.ge_trans with st.(st_in)!!s.
   change st.(st_in)!!s with (mkstate st.(st_in) rem).(st_in)!!s.
-  apply propagate_succ_list_incr. 
+  apply propagate_succ_list_incr.
   auto.
   (* Case 2.2.2: s is not a successor of n, it did not change *)
   elim (propagate_succ_list_charact out (successors!!!n)
@@ -476,14 +495,14 @@
           forall n s,
           In s successors!!!n ->
           L.ge res!!s (transf n res!!n)).
-  unfold fixpoint. intros res PI. pattern res. 
+  unfold fixpoint. intros res PI. pattern res.
   eapply (PrimIter.iterate_prop _ _ step good_state).
 
-  intros st GOOD. unfold step. 
-  caseEq (NS.pick st.(st_wrk)). 
-  intros [n rem] PICK. apply step_state_good; auto. 
-  intros. 
-  elim (GOOD n); intro. 
+  intros st GOOD. unfold step.
+  caseEq (NS.pick st.(st_wrk)).
+  intros [n rem] PICK. apply step_state_good; auto.
+  intros.
+  elim (GOOD n); intro.
   elim (NS.pick_none _ n H). auto.
   auto.
 
@@ -503,10 +522,11 @@
   induction ep; simpl; intros.
   elim H.
   elim H; intros.
-  subst a. rewrite PMap.gss.
-  apply L.ge_lub_right.
-  destruct a. rewrite PMap.gsspec. case (peq n p); intro.
-  subst p. apply L.ge_trans with (start_state_in ep)!!n.
+  subst a. rewrite AMap.gss.
+  eapply L.ge_compat. apply L.lub_commut. apply L.eq_refl.
+  apply L.ge_lub_left.
+  destruct a. rewrite AMap.gsspec. case (eq_atom_dec n a); intro.
+  subst a. apply L.ge_trans with (start_state_in ep)!!n.
   apply L.ge_lub_left. auto.
   auto.
 Qed.
@@ -540,16 +560,16 @@
           (forall n v, In (n, v) ep -> P v) ->
           forall pc, P (start_state_in ep)!!pc).
     induction ep; intros; simpl.
-    rewrite PMap.gi. auto.
+    rewrite AMap.gi. auto.
     simpl in H.
-    assert (P (start_state_in ep)!!pc). apply IHep. eauto.  
-    destruct a as [n v]. rewrite PMap.gsspec. destruct (peq pc n).
+    assert (P (start_state_in ep)!!pc). apply IHep. eauto.
+    destruct a as [n v]. rewrite AMap.gsspec. destruct (eq_atom_dec pc n).
     apply P_lub. subst. auto. eapply H. left; reflexivity. auto.
   set (inv := fun st => forall pc, P (st.(st_in)!!pc)).
   assert (forall st v n, inv st -> P v -> inv (propagate_succ st v n)).
-    unfold inv, propagate_succ. intros. 
+    unfold inv, propagate_succ. intros.
     destruct (LAT.beq (st_in st)!!n (LAT.lub (st_in st)!!n v)).
-    auto. simpl. rewrite PMap.gsspec. destruct (peq pc n). 
+    auto. simpl. rewrite AMap.gsspec. destruct (eq_atom_dec pc n).
     apply P_lub. subst n; auto. auto.
     auto.
   assert (forall l st v, inv st -> P v -> inv (propagate_succ_list st v l)).
@@ -561,76 +581,132 @@
     intros. unfold step. destruct (NS.pick (st_wrk a)) as [[n rem] | ].
     apply H1. auto. apply P_transf. apply H2.
     assumption.
-    eauto. 
-    unfold inv, start_state; simpl. auto. 
+    eauto.
+    unfold inv, start_state; simpl. auto.
   intros. auto.
 Qed.
 
 End Kildall.
 
-End Dataflow_Solver.
+Section FixpointInv.
 
-(** * Solving backward dataflow problems using Kildall's algorithm *)
+(* A variant of fixpoint_invariant *)
 
-(** A backward dataflow problem on a given flow graph is a forward
-  dataflow program on the reversed flow graph, where predecessors replace
-  successors.  We exploit this observation to cheaply derive a backward
-  solver from the forward solver. *)
-
-(** ** Construction of the predecessor relation *)
-
-Section Predecessor.
-
-Variable successors: PTree.t (list positive).
-
-Fixpoint add_successors (pred: PTree.t (list positive))
-                        (from: positive) (tolist: list positive)
-                        {struct tolist} : PTree.t (list positive) :=
-  match tolist with
-  | nil => pred
-  | to :: rem => add_successors (PTree.set to (from :: pred!!!to) pred) from rem
-  end.
-
-Lemma add_successors_correct:
-  forall tolist from pred n s,
-  In n pred!!!s \/ (n = from /\ In s tolist) -> 
-  In n (add_successors pred from tolist)!!!s.
+Variable successors: ATree.t (list atom).
+Variable transf: atom -> L.t -> L.t.
+Variable entrypoints: list (atom * L.t).
+
+Variable P: atom -> L.t -> Prop.
+Definition inv := fun st => forall pc, P pc (st.(st_in)!!pc).
+Hypothesis P_bot: forall n, P n L.bot.
+Hypothesis P_lub: forall n x y, P n x -> P n y -> P n (L.lub x y).
+Hypothesis P_transf: 
+  forall pc sc x y (Hin: In sc (successors!!!pc))
+    (HPx: P pc x) (HPy: P sc y), P sc (L.lub y (transf pc x)).
+Hypothesis P_entrypoints: forall n v, In (n, v) entrypoints -> P n v.
+Hypothesis transf_mono: forall p x y,
+  L.ge x y -> L.ge (transf p x) (transf p y).
+Hypothesis ge_lub: forall x y1 y2, 
+  L.ge y1 y2 -> L.ge (L.lub x y1) (L.lub x y2).
+Hypothesis P_ge: forall n x y, L.ge x y -> P n x -> P n y.
+
+Lemma propagate_succ_inv: forall st n sc out
+  (Hin: In sc successors!!!n)
+  (Hge: L.ge (transf n st.(st_in)!!n) out)
+  (Hinv: inv st),
+  inv (propagate_succ st out sc).
 Proof.
-  induction tolist; simpl; intros.
-  tauto.
-  apply IHtolist.
-  unfold successors_list at 1. rewrite PTree.gsspec. destruct (peq s a).
-  subst a. destruct H. auto with coqlib. 
-  destruct H. subst n. auto with coqlib. 
-  fold (successors_list pred s). intuition congruence.
+  unfold inv.
+  intros.
+  destruct (eq_atom_dec sc pc) as [Heq | Hneq]; subst.
+    unfold propagate_succ.
+    destruct (L.beq (st_in st) !! pc (L.lub (st_in st) !! pc out)); auto.
+    simpl.
+    rewrite AMap.gss. 
+    eapply P_transf in Hin; eauto.
+
+    destruct (propagate_succ_charact st out sc) as [J1 J2].
+    rewrite J2; auto.
+Qed.
+
+Lemma propagate_succ_list_inv_aux: forall n scs st out,
+  (forall s, In s scs -> In s successors!!!n) ->
+  L.ge (transf n st.(st_in)!!n) out ->
+  inv st ->
+  inv (propagate_succ_list st out scs).
+Proof.
+  induction scs; simpl; intros; auto.
+    apply IHscs; auto.
+      apply L.ge_trans with (y:=(transf n (st_in st) !! n)); auto.
+        apply transf_mono.
+        apply propagate_succ_incr.
+      eapply propagate_succ_inv; eauto.
+Qed.
+
+Lemma propagate_succ_list_inv: forall n scs st,
+  (forall s, In s scs -> In s successors!!!n) ->
+  inv st ->
+  inv (propagate_succ_list st (transf n st.(st_in)!!n) scs).
+Proof.
+  intros.
+  eapply propagate_succ_list_inv_aux; eauto.
+    apply L.ge_refl. apply L.eq_refl.
 Qed.
 
-Definition make_predecessors : PTree.t (list positive) :=
-  PTree.fold add_successors successors (PTree.empty (list positive)).
+Lemma step_inv: forall st n rem,
+  NS.pick st.(st_wrk) = Some(n, rem) ->
+  inv st ->
+  inv (propagate_succ_list (mkstate st.(st_in) rem)
+                           (transf n st.(st_in)!!n)
+                           (successors!!!n)).
+Proof.
+  intros st n rem WKL GOOD.
+  destruct st. simpl.
+  apply propagate_succ_list_inv; auto.
+Qed.
+
+Lemma entry_inv: inv (start_state successors entrypoints).
+Proof.
+  unfold inv.
+  unfold start_state. simpl.
+  induction entrypoints as [|[n v] ep]; intros; simpl.
+    rewrite AMap.gi. auto.
+
+    simpl in P_entrypoints.
+    assert (P pc (start_state_in ep)!!pc) as J. 
+      apply IHep. eauto.
+    rewrite AMap.gsspec.
+    destruct (eq_atom_dec pc n); subst.
+      apply P_lub. auto. 
+        eapply P_entrypoints. left; reflexivity. 
+      auto.
+Qed.
 
-Lemma make_predecessors_correct:
-  forall n s,
-  In s successors!!!n ->
-  In n make_predecessors!!!s.
+Theorem fixpoint_inv:
+  forall res,
+  fixpoint successors transf entrypoints = Some res ->
+  forall pc, P pc res!!pc.
 Proof.
-  set (P := fun succ pred =>
-          forall n s, In s succ!!!n -> In n pred!!!s).
-  unfold make_predecessors.
-  apply PTree_Properties.fold_rec with (P := P).
-(* extensionality *)
-  unfold P; unfold successors_list; intros.
-  rewrite <- H in H1. auto.
-(* base case *)
-  red; unfold successors_list. intros n s. repeat rewrite PTree.gempty. auto.
-(* inductive case *)
-  unfold P; intros. apply add_successors_correct.
-  unfold successors_list in H2. rewrite PTree.gsspec in H2. 
-  destruct (peq n k).
-  subst k. auto.
-  fold (successors_list m n) in H2. auto.
+  unfold fixpoint. intros res PI. pattern res.
+  eapply (PrimIter.iterate_prop _ _ (step _ _) inv); eauto.
+    intros st GOOD. unfold step.
+    caseEq (NS.pick st.(st_wrk)); auto. 
+    intros [n rem] PICK. 
+    apply step_inv; auto.
+
+    apply entry_inv; auto.
 Qed.
 
-End Predecessor.
+End FixpointInv.
+
+End Dataflow_Solver.
+
+(** * Solving backward dataflow problems using Kildall's algorithm *)
+
+(** A backward dataflow problem on a given flow graph is a forward
+  dataflow program on the reversed flow graph, where predecessors replace
+  successors.  We exploit this observation to cheaply derive a backward
+  solver from the forward solver. *)
 
 (** ** Solving backward dataflow problems *)
 
@@ -641,10 +717,10 @@
   Declare Module L: SEMILATTICE.
 
   Variable fixpoint:
-    PTree.t (list positive) ->
-    (positive -> L.t -> L.t) ->
-    list (positive * L.t) ->
-    option (PMap.t L.t).
+    ATree.t (list atom) ->
+    (atom -> L.t -> L.t) ->
+    list (atom * L.t) ->
+    option (AMap.t L.t).
 
   Hypothesis fixpoint_solution:
     forall successors transf entrypoints res n s,
@@ -683,12 +759,12 @@
 
 Section Kildall.
 
-Variable successors: PTree.t (list positive).
-Variable transf: positive -> L.t -> L.t.
-Variable entrypoints: list (positive * L.t).
+Variable successors: ATree.t (list atom).
+Variable transf: atom -> L.t -> L.t.
+Variable entrypoints: list (atom * L.t).
 
 Definition fixpoint :=
-  DS.fixpoint (make_predecessors successors) transf entrypoints.
+  DS.fixpoint (XATree.make_predecessors successors) transf entrypoints.
 
 Theorem fixpoint_solution:
   forall res n s,
@@ -697,9 +773,9 @@
   L.ge res!!n (transf s res!!s).
 Proof.
   intros. apply DS.fixpoint_solution with
-    (make_predecessors successors) entrypoints.
+    (XATree.make_predecessors successors) entrypoints.
   exact H.
-  apply make_predecessors_correct; auto.
+  apply XATree.make_predecessors_correct; auto.
 Qed.
 
 Theorem fixpoint_entry:
@@ -709,7 +785,7 @@
   L.ge res!!n v.
 Proof.
   intros. apply DS.fixpoint_entry with
-    (make_predecessors successors) transf entrypoints.
+    (XATree.make_predecessors successors) transf entrypoints.
   exact H. auto.
 Qed.
 
@@ -723,8 +799,8 @@
   fixpoint = Some res ->
   P res!!pc.
 Proof.
-  intros. apply DS.fixpoint_invariant with 
-    (make_predecessors successors) transf entrypoints; auto. 
+  intros. apply DS.fixpoint_invariant with
+    (XATree.make_predecessors successors) transf entrypoints; auto.
 Qed.
 
 End Kildall.
@@ -738,7 +814,7 @@
   In other terms, program points with multiple predecessors are mapped
   to [L.top] (the greatest, or coarsest, approximation) and the other
   program points are mapped to [transf p X[p]] where [p] is their unique
-  predecessor. 
+  predecessor.
 
   This analysis applies to any type of approximations equipped with
   an ordering and a greatest element. *)
@@ -755,7 +831,7 @@
 
 (** The interface of the solver is similar to that of Kildall's forward
   solver.  We provide one additional theorem [fixpoint_invariant]
-  stating that any property preserved by the [transf] function 
+  stating that any property preserved by the [transf] function
   holds for the returned solution. *)
 
 Module Type BBLOCK_SOLVER.
@@ -763,10 +839,10 @@
   Declare Module L: ORDERED_TYPE_WITH_TOP.
 
   Variable fixpoint:
-    PTree.t (list positive) ->
-    (positive -> L.t -> L.t) ->
-    positive ->
-    option (PMap.t L.t).
+    ATree.t (list atom) ->
+    (atom -> L.t -> L.t) ->
+    atom ->
+    option (AMap.t L.t).
 
   Hypothesis fixpoint_solution:
     forall successors transf entrypoint res n s,
@@ -780,7 +856,7 @@
     res!!entrypoint = L.top.
 
   Hypothesis fixpoint_invariant:
-    forall successors transf entrypoint 
+    forall successors transf entrypoint
            (P: L.t -> Prop),
     P L.top ->
     (forall pc x, P x -> P (transf pc x)) ->
@@ -800,15 +876,15 @@
 
 Section Solver.
 
-Variable successors: PTree.t (list positive).
-Variable transf: positive -> L.t -> L.t.
-Variable entrypoint: positive.
+Variable successors: ATree.t (list atom).
+Variable transf: atom -> L.t -> L.t.
+Variable entrypoint: atom.
 Variable P: L.t -> Prop.
 Hypothesis Ptop: P L.top.
 Hypothesis Ptransf: forall pc x, P x -> P (transf pc x).
 
-Definition bbmap := positive -> bool.
-Definition result := PMap.t L.t.
+Definition bbmap := atom -> bool.
+Definition result := AMap.t L.t.
 
 (** As in Kildall's solver, the state of the iteration has two components:
 - A mapping from program points to values of type [L.t] representing
@@ -817,7 +893,7 @@
 *)
 
 Record state : Type := mkstate
-  { st_in: result; st_wrk: list positive }.
+  { st_in: result; st_wrk: list atom }.
 
 (** The ``extended basic block'' algorithm, in pseudo-code, is as follows:
 <<
@@ -839,7 +915,7 @@
 **)
 
 Fixpoint propagate_successors
-    (bb: bbmap) (succs: list positive) (l: L.t) (st: state)
+    (bb: bbmap) (succs: list atom) (l: L.t) (st: state)
     {struct succs} : state :=
   match succs with
   | nil => st
@@ -848,7 +924,7 @@
         propagate_successors bb sl l st
       else
         propagate_successors bb sl l
-          (mkstate (PMap.set s1 l st.(st_in))
+          (mkstate (AMap.set s1 l st.(st_in))
                    (s1 :: st.(st_wrk)))
   end.
 
@@ -856,7 +932,7 @@
   match st.(st_wrk) with
   | nil => inl _ st.(st_in)
   | pc :: rem =>
-        inr _ (propagate_successors 
+        inr _ (propagate_successors
                  bb (successors!!!pc)
                  (transf pc st.(st_in)!!pc)
                  (mkstate st.(st_in) rem))
@@ -864,37 +940,37 @@
 
 (** Recognition of program points that have more than one predecessor. *)
 
-Definition is_basic_block_head 
-    (preds: PTree.t (list positive)) (pc: positive) : bool :=
-  if peq pc entrypoint then true else
+Definition is_basic_block_head
+    (preds: ATree.t (list atom)) (pc: atom) : bool :=
+  if eq_atom_dec pc entrypoint then true else
     match preds!!!pc with
     | nil => false
-    | s :: nil => peq s pc
+    | s :: nil => eq_atom_dec s pc
     | _ :: _ :: _ => true
     end.
 
 Definition basic_block_map : bbmap :=
-  is_basic_block_head (make_predecessors successors).
+  is_basic_block_head (XATree.make_predecessors successors).
 
-Definition basic_block_list (bb: bbmap) : list positive :=
-  PTree.fold (fun l pc scs => if bb pc then pc :: l else l)
+Definition basic_block_list (bb: bbmap) : list atom :=
+  ATree.fold (fun l pc scs => if bb pc then pc :: l else l)
              successors nil.
 
 (** The computation of the approximate solution. *)
 
 Definition fixpoint : option result :=
   let bb := basic_block_map in
-  PrimIter.iterate _ _ (step bb) (mkstate (PMap.init L.top) (basic_block_list bb)).
+  PrimIter.iterate _ _ (step bb) (mkstate (AMap.init L.top) (basic_block_list bb)).
 
 (** ** Properties of predecessors and multiple-predecessors nodes *)
 
-Definition predecessors := make_predecessors successors.
+Definition predecessors := XATree.make_predecessors successors.
 
 Lemma predecessors_correct:
   forall n s,
   In s successors!!!n -> In n predecessors!!!s.
 Proof.
-  intros. unfold predecessors. eapply make_predecessors_correct; eauto.
+  intros. unfold predecessors. eapply XATree.make_predecessors_correct; eauto.
 Qed.
 
 Lemma multiple_predecessors:
@@ -904,16 +980,16 @@
   n1 <> n2 ->
   basic_block_map s = true.
 Proof.
-  intros. 
+  intros.
   assert (In n1 predecessors!!!s). apply predecessors_correct; auto.
   assert (In n2 predecessors!!!s). apply predecessors_correct; auto.
   unfold basic_block_map, is_basic_block_head.
-  destruct (peq s entrypoint). auto. 
-  fold predecessors.
-  destruct (predecessors!!!s). 
+  destruct (eq_atom_dec s entrypoint). auto.
+  fold predecessors. change atom with ATree.elt.
+  destruct (predecessors!!!s).
   auto.
   destruct l.
-  simpl in H2. simpl in H3. intuition congruence. 
+  simpl in H2. simpl in H3. intuition congruence.
   auto.
 Qed.
 
@@ -922,19 +998,22 @@
   In n (successors!!!n) -> basic_block_map n = true.
 Proof.
   intros. unfold basic_block_map, is_basic_block_head.
-  destruct (peq n entrypoint). auto. 
-  fold predecessors. 
+  destruct (eq_atom_dec n entrypoint). auto.
+  fold predecessors.
   generalize (predecessors_correct n n H). intro.
-  destruct (predecessors!!!n). auto.
-  destruct l. replace n with p. apply peq_true. simpl in H0. tauto. 
-  auto.
+  change atom with ATree.elt.
+  destruct (predecessors!!!n) as [|a]. auto.
+  destruct l; auto.
+    replace n with a.
+      destruct (eq_atom_dec a a); auto.
+      simpl in H0. tauto.
 Qed.
 
 (** ** Correctness invariant *)
 
 (** The invariant over the state is as follows:
 - Points with several predecessors are mapped to [L.top]
-- Points not in the worklist satisfy their inequations 
+- Points not in the worklist satisfy their inequations
   (as in Kildall's algorithm).
 *)
 
@@ -943,7 +1022,7 @@
 /\
   (forall n,
    In n st.(st_wrk) \/
-   (forall s, In s (successors!!!n) -> 
+   (forall s, In s (successors!!!n) ->
                L.ge st.(st_in)!!s (transf n st.(st_in)!!n))).
 
 Lemma propagate_successors_charact1:
@@ -957,7 +1036,7 @@
   auto.
   apply incl_tran with (a :: st_wrk st).
   apply incl_tl. apply incl_refl.
-  set (st1 := (mkstate (PMap.set a l (st_in st)) (a :: st_wrk st))).
+  set (st1 := (mkstate (AMap.set a l (st_in st)) (a :: st_wrk st))).
   change (a :: st_wrk st) with (st_wrk st1).
   auto.
 Qed.
@@ -975,27 +1054,27 @@
   caseEq (bb a); intro.
   elim (IHsuccs l st n); intros A B.
   split; intros. apply A; auto.
-  elim H0; intro. subst a. congruence. auto. 
-  apply B. tauto. 
-  set (st1 := mkstate (PMap.set a l (st_in st)) (a :: st_wrk st)).
+  elim H0; intro. subst a. congruence. auto.
+  apply B. tauto.
+  set (st1 := mkstate (AMap.set a l (st_in st)) (a :: st_wrk st)).
   elim (IHsuccs l st1 n); intros A B.
   split; intros.
   elim H0; intros.
   subst n. split.
   apply propagate_successors_charact1. simpl. tauto.
-  case (In_dec peq a succs); intro.
+  case (In_dec eq_atom_dec a succs); intro.
   elim (A i H1); auto.
-  rewrite B. unfold st1; simpl. apply PMap.gss. tauto.
+  rewrite B. unfold st1; simpl. apply AMap.gss. tauto.
   apply A; auto.
-  rewrite B. unfold st1; simpl. apply PMap.gso. 
+  rewrite B. unfold st1; simpl. apply AMap.gso.
   red; intro; subst n. elim H0; intro. tauto. congruence.
-  tauto. 
+  tauto.
 Qed.
 
 Lemma propagate_successors_invariant:
   forall pc res rem,
   state_invariant (mkstate res (pc :: rem)) ->
-  state_invariant 
+  state_invariant
     (propagate_successors basic_block_map (successors!!!pc)
                           (transf pc res!!pc)
                           (mkstate res rem)).
@@ -1008,22 +1087,22 @@
                 (successors!!!pc) l (mkstate res rem)).
   set (st1 := propagate_successors basic_block_map
                  (successors!!!pc) l (mkstate res rem)).
-  intros A B. simpl in A. 
+  intros A B. simpl in A.
   (* First part: BB entries remain at top *)
   split; intros.
-  elim (A n); intros C D. rewrite D. simpl. apply INV1. auto. tauto. 
+  elim (A n); intros C D. rewrite D. simpl. apply INV1. auto. tauto.
   (* Second part: monotonicity *)
   (* Case 1: n = pc *)
-  case (peq pc n); intros.
-  subst n. right; intros. 
+  case (eq_atom_dec pc n); intros.
+  subst n. right; intros.
   elim (A s); intros C D.
-  replace (st1.(st_in)!!pc) with res!!pc. fold l. 
+  replace (st1.(st_in)!!pc) with res!!pc. fold l.
   caseEq (basic_block_map s); intro.
-  rewrite D. simpl. rewrite INV1. apply L.top_ge. auto. tauto. 
-  elim (C H H0); intros. rewrite H2. apply L.refl_ge. 
-  elim (A pc); intros E F. rewrite F. reflexivity. 
-  case (In_dec peq pc (successors!!!pc)); intro.
-  right. apply no_self_loop; auto. 
+  rewrite D. simpl. rewrite INV1. apply L.top_ge. auto. tauto.
+  elim (C H H0); intros. rewrite H2. apply L.refl_ge.
+  elim (A pc); intros E F. rewrite F. reflexivity.
+  case (In_dec eq_atom_dec pc (successors!!!pc)); intro.
+  right. apply no_self_loop; auto.
   left; auto.
   (* Case 2: n <> pc *)
   elim (INV2 n); intro.
@@ -1035,31 +1114,31 @@
        they could change is if they were successors of pc as well,
        but that gives them two different predecessors, so
        they are basic block heads, and thus do not change! *)
-    intros. elim (A s); intros C D. rewrite D. reflexivity. 
-    case (In_dec peq s (successors!!!pc)); intro.
+    intros. elim (A s); intros C D. rewrite D. reflexivity.
+    case (In_dec eq_atom_dec s (successors!!!pc)); intro.
     right. apply multiple_predecessors with n pc; auto.
     left; auto.
-  case (In_dec peq n (successors!!!pc)); intro.
+  case (In_dec eq_atom_dec n (successors!!!pc)); intro.
   (* Case 2.2.1: n is a successor of pc. Either it is in the
      worklist or it did not change *)
   caseEq (basic_block_map n); intro.
-  right; intros. 
+  right; intros.
   elim (A n); intros C D. rewrite D. rewrite INV3; auto.
   tauto.
   left. elim (A n); intros C D. elim (C i H0); intros. auto.
   (* Case 2.2.2: n is not a successor of pc. It did not change. *)
   right; intros.
-  elim (A n); intros C D. rewrite D. 
+  elim (A n); intros C D. rewrite D.
   rewrite INV3; auto.
   tauto.
 Qed.
 
 Lemma initial_state_invariant:
-  state_invariant (mkstate (PMap.init L.top) (basic_block_list basic_block_map)).
+  state_invariant (mkstate (AMap.init L.top) (basic_block_list basic_block_map)).
 Proof.
   split; simpl; intros.
-  apply PMap.gi.
-  right. intros. repeat rewrite PMap.gi. apply L.top_ge.
+  apply AMap.gi.
+  right. intros. repeat rewrite AMap.gi. apply L.top_ge.
 Qed.
 
 Lemma analyze_invariant:
@@ -1071,12 +1150,12 @@
   eapply (PrimIter.iterate_prop _ _ (step basic_block_map)
            state_invariant).
 
-  intros st INV. destruct st as [stin stwrk]. 
+  intros st INV. destruct st as [stin stwrk].
   unfold step. simpl. caseEq stwrk.
   intro. congruence.
 
-  intros pc rem WRK. 
-  apply propagate_successors_invariant; auto. congruence. 
+  intros pc rem WRK.
+  apply propagate_successors_invariant; auto. congruence.
 
   eauto. apply initial_state_invariant.
 Qed.
@@ -1089,11 +1168,11 @@
   In s (successors!!!n) ->
   L.ge res!!s (transf n res!!n).
 Proof.
-  intros. 
+  intros.
   assert (state_invariant (mkstate res nil)).
-  eapply analyze_invariant; eauto. 
-  elim H1; simpl; intros. 
-  elim (H3 n); intros. 
+  eapply analyze_invariant; eauto.
+  elim H1; simpl; intros.
+  elim (H3 n); intros.
   contradiction.
   auto.
 Qed.
@@ -1103,13 +1182,13 @@
   fixpoint = Some res ->
   res!!entrypoint = L.top.
 Proof.
-  intros. 
+  intros.
   assert (state_invariant (mkstate res nil)).
-  eapply analyze_invariant; eauto. 
-  elim H0; simpl; intros. 
+  eapply analyze_invariant; eauto.
+  elim H0; simpl; intros.
   apply H1. unfold basic_block_map, is_basic_block_head.
-  fold predecessors. apply peq_true. 
-Qed. 
+  fold predecessors. destruct (eq_atom_dec entrypoint entrypoint); auto.
+Qed.
 
 (** ** Preservation of a property over solutions *)
 
@@ -1125,25 +1204,25 @@
 Proof.
   induction succs; simpl; intros.
   auto.
-  case (bb a). auto. 
-  apply IHsuccs. red; simpl; intros. 
-  rewrite PMap.gsspec. case (peq pc a); intro.
+  case (bb a). auto.
+  apply IHsuccs. red; simpl; intros.
+  rewrite AMap.gsspec. case (eq_atom_dec pc a); intro.
   auto. apply H0.
 Qed.
 
 Theorem fixpoint_invariant:
   forall res pc, fixpoint = Some res -> P res!!pc.
 Proof.
-  unfold fixpoint; intros. pattern res. 
+  unfold fixpoint; intros. pattern res.
   eapply (PrimIter.iterate_prop _ _ (step basic_block_map) Pstate).
 
   intros st PS. unfold step. destruct (st.(st_wrk)).
   apply PS.
   assert (PS2: Pstate (mkstate st.(st_in) l)).
     red; intro; simpl. apply PS.
-  apply propagate_successors_P. auto. auto. eauto. 
+  apply propagate_successors_P. auto. auto. eauto.
 
-  red; intro; simpl. rewrite PMap.gi. apply Ptop.
+  red; intro; simpl. rewrite AMap.gi. apply Ptop.
 Qed.
 
 End Solver.
@@ -1152,6 +1231,118 @@
 
 (** ** Node sets *)
 
+Require Import ListSet.
+
+Module AtomNodeSet <: NODE_SET.
+  Definition t := set atom.
+  Definition add (n: atom) (s: t) : t := set_add eq_atom_dec n s.
+  Definition pick (s: t) :=
+    match s with
+    | n::s' => Some(n, set_remove eq_atom_dec n s')
+    | nil => None
+    end.
+  Definition initial (successors: ATree.t (list atom)) :=
+    ATree.fold (fun s pc scs => add pc s) successors (empty_set atom).
+  Definition In := (@set_In atom).
+
+  Lemma add_spec:
+    forall n n' s, In n' (add n s) <-> n = n' \/ In n' s.
+  Proof.
+    intros.
+    split; intro J.
+      apply (@set_add_elim atom eq_atom_dec n' n s) in J.
+      destruct J; auto.
+
+      apply (@set_add_intro atom eq_atom_dec).
+      destruct J; auto.
+  Qed.
+
+  Lemma pick_none:
+    forall s n, pick s = None -> ~In n s.
+  Proof.
+    intros until n; unfold pick.
+    destruct s; auto.
+      intro J. inversion J.
+  Qed.
+
+  Lemma pick_some:
+    forall s n s', pick s = Some(n, s') ->
+    forall n', In n' s <-> n = n' \/ In n' s'.
+  Proof.
+    intros until s'; unfold pick.
+    destruct s; intro H0; inv H0.
+    intros n'.
+    split; intros.
+      simpl in H.
+      inv H; auto.
+        destruct (eq_atom_dec n n') as [J1 | J2]; subst; auto.
+          right. apply AtomSet.set_remove_spec1; auto.
+
+      destruct H as [H | H]; subst; simpl; auto.
+          right. eapply AtomSet.set_remove_spec2; eauto.
+  Qed.
+
+  Lemma initial_spec:
+    forall successors n s,
+    successors!n = Some s -> In n (initial successors).
+  Proof.
+    intros successors.
+    apply ATree_Properties.fold_rec with
+      (P := fun succ set =>
+              forall n s, succ!n = Some s -> In n set).
+    (* extensionality *)
+    intros. rewrite <- H in H1. eauto.
+    (* base case *)
+    intros. rewrite ATree.gempty in H. congruence.
+    (* inductive case *)
+    intros. rewrite ATree.gsspec in H2. rewrite add_spec.
+    destruct (ATree.elt_eq n k). auto. eauto.
+  Qed.
+
+  Lemma pick_in:
+    forall s n s', pick s = Some(n, s') -> In n s.
+  Proof.
+    intros until s'; unfold pick. 
+    caseEq s; intros; try congruence.
+    inv H0. simpl. auto.
+  Qed.
+  
+  Lemma initial_spec':
+    forall successors n,
+    In n (initial successors) -> 
+    exists s, successors ! n = Some s.
+  Proof.
+    intros successors.
+    apply ATree_Properties.fold_rec with
+      (P := fun succ set =>
+              forall n, In n set -> exists s, succ ! n = Some s).
+    (* extensionality *)
+    intros. rewrite <- H. eauto.
+    (* base case *)
+    intros. inv H.
+    (* inductive case *)
+    intros. rewrite ATree.gsspec. apply add_spec in H2.
+    destruct (ATree.elt_eq n k); eauto.
+      destruct H2 as [H2 | H2]; subst.
+        congruence.
+        eauto.
+  Qed.
+
+  Lemma NoDup__initial: forall successors, NoDup (initial successors).
+  Proof.
+    intro successors.
+    apply ATree_Properties.fold_rec with
+      (P := fun succ set => NoDup set).
+      (* extensionality *)
+      intros. auto.
+      (* base case *)
+      constructor.
+      (* inductive case *)
+      intros. apply AtomSet.set_add_NoDup; auto.
+  Qed.
+
+End AtomNodeSet.
+
 (** We now define implementations of the [NODE_SET] interface
   appropriate for forward and backward dataflow analysis.
   As mentioned earlier, we aim for a traversal of the CFG nodes
@@ -1161,50 +1352,59 @@
   the enumeration [n-1], [n-2], ..., 3, 2, 1 where [n] is the
   top CFG node is a reverse postorder traversal.
   Therefore, for forward analysis, we will use an implementation
-  of [NODE_SET] where the [pick] operation selects the 
+  of [NODE_SET] where the [pick] operation selects the
   greatest node in the working list.  For backward analysis,
   we will similarly pick the smallest node in the working list. *)
 
-Require Import Heaps.
+(*
+Require Import FSets.
+Require Import FSetAVL.
+Require Import Ordered.
+
+Module PositiveSet := FSetAVL.Make(OrderedPositive).
+Module PositiveSetFacts := FSetFacts.Facts(PositiveSet).
 
 Module NodeSetForward <: NODE_SET.
-  Definition t := PHeap.t.
-  Definition add (n: positive) (s: t) : t := PHeap.insert n s.
+  Definition t := PositiveSet.t.
+  Definition add (n: positive) (s: t) : t := PositiveSet.add n s.
   Definition pick (s: t) :=
-    match PHeap.findMax s with
-    | Some n => Some(n, PHeap.deleteMax s)
+    match PositiveSet.max_elt s with
+    | Some n => Some(n, PositiveSet.remove n s)
     | None => None
     end.
   Definition initial (successors: PTree.t (list positive)) :=
-    PTree.fold (fun s pc scs => PHeap.insert pc s) successors PHeap.empty.
-  Definition In := PHeap.In.
+    PTree.fold (fun s pc scs => PositiveSet.add pc s) successors PositiveSet.empty.
+  Definition In := PositiveSet.In.
 
   Lemma add_spec:
     forall n n' s, In n' (add n s) <-> n = n' \/ In n' s.
   Proof.
-    intros. rewrite PHeap.In_insert. unfold In. intuition.
+    intros. exact (PositiveSetFacts.add_iff s n n').
   Qed.
-    
+
   Lemma pick_none:
     forall s n, pick s = None -> ~In n s.
   Proof.
-    intros until n; unfold pick. caseEq (PHeap.findMax s); intros.
+    intros until n; unfold pick. caseEq (PositiveSet.max_elt s); intros.
     congruence.
-    apply PHeap.findMax_empty. auto.
+    apply PositiveSet.max_elt_3. auto.
   Qed.
 
   Lemma pick_some:
     forall s n s', pick s = Some(n, s') ->
     forall n', In n' s <-> n = n' \/ In n' s'.
   Proof.
-    intros until s'; unfold pick. caseEq (PHeap.findMax s); intros.
-    inv H0.
-    generalize (PHeap.In_deleteMax s n n' H). unfold In. intuition.
+    intros until s'; unfold pick. caseEq (PositiveSet.max_elt s); intros.
+    inversion H0; clear H0; subst.
+    split; intros.
+    destruct (peq n n'). auto. right. apply PositiveSet.remove_2; assumption.
+    elim H0; intro. subst n'. apply PositiveSet.max_elt_1. auto.
+    apply PositiveSet.remove_3 with n; assumption.
     congruence.
   Qed.
 
   Lemma initial_spec:
-    forall successors n s, 
+    forall successors n s,
     successors!n = Some s -> In n (initial successors).
   Proof.
     intros successors.
@@ -1222,16 +1422,16 @@
 End NodeSetForward.
 
 Module NodeSetBackward <: NODE_SET.
-  Definition t := PHeap.t.
-  Definition add (n: positive) (s: t) : t := PHeap.insert n s.
+  Definition t := PositiveSet.t.
+  Definition add (n: positive) (s: t) : t := PositiveSet.add n s.
   Definition pick (s: t) :=
-    match PHeap.findMin s with
-    | Some n => Some(n, PHeap.deleteMin s)
+    match PositiveSet.min_elt s with
+    | Some n => Some(n, PositiveSet.remove n s)
     | None => None
     end.
   Definition initial (successors: PTree.t (list positive)) :=
-    PTree.fold (fun s pc scs => PHeap.insert pc s) successors PHeap.empty.
-  Definition In := PHeap.In.
+    PTree.fold (fun s pc scs => PositiveSet.add pc s) successors PositiveSet.empty.
+  Definition In := PositiveSet.In.
 
   Lemma add_spec:
     forall n n' s, In n' (add n s) <-> n = n' \/ In n' s.
@@ -1240,24 +1440,709 @@
   Lemma pick_none:
     forall s n, pick s = None -> ~In n s.
   Proof.
-    intros until n; unfold pick. caseEq (PHeap.findMin s); intros.
+    intros until n; unfold pick. caseEq (PositiveSet.min_elt s); intros.
     congruence.
-    apply PHeap.findMin_empty. auto.
+    apply PositiveSet.min_elt_3. auto.
   Qed.
 
   Lemma pick_some:
     forall s n s', pick s = Some(n, s') ->
     forall n', In n' s <-> n = n' \/ In n' s'.
   Proof.
-    intros until s'; unfold pick. caseEq (PHeap.findMin s); intros.
-    inv H0.
-    generalize (PHeap.In_deleteMin s n n' H). unfold In. intuition.
+    intros until s'; unfold pick. caseEq (PositiveSet.min_elt s); intros.
+    inversion H0; clear H0; subst.
+    split; intros.
+    destruct (peq n n'). auto. right. apply PositiveSet.remove_2; assumption.
+    elim H0; intro. subst n'. apply PositiveSet.min_elt_1. auto.
+    apply PositiveSet.remove_3 with n; assumption.
     congruence.
   Qed.
 
   Lemma initial_spec:
-    forall successors n s, 
+    forall successors n s,
     successors!n = Some s -> In n (initial successors).
   Proof NodeSetForward.initial_spec.
 End NodeSetBackward.
+*)
+
+Module Dataflow_Solver_Var_Top (NS: NODE_SET).
+
+Module L := Dominators.
+
+Section Kildall.
+
+Variable successors: ATree.t (list atom).
+Variable transf: atom -> L.t -> L.t.
+Variable entrypoints: list (atom * L.t).
+
+(** The state of the iteration has two components:
+- A mapping from program points to values of type [L.t] representing
+  the candidate solution found so far.
+- A worklist of program points that remain to be considered.
+*)
+
+Record state : Type :=
+  mkstate { st_in: AMap.t L.t; st_wrk: NS.t }.
+
+(** Kildall's algorithm, in pseudo-code, is as follows:
+<<
+    while st_wrk is not empty, do
+        extract a node n from st_wrk
+        compute out = transf n st_in[n]
+        for each successor s of n:
+            compute in = lub st_in[s] out
+            if in <> st_in[s]:
+                st_in[s] := in
+                st_wrk := st_wrk union {s}
+            end if
+        end for
+    end while
+    return st_in
+>>
+
+The initial state is built as follows:
+- The initial mapping sets all program points to [L.bot], except
+  those mentioned in the [entrypoints] list, for which we take
+  the associated approximation as initial value.  Since a program
+  point can be mentioned several times in [entrypoints], with different
+  approximations, we actually take the l.u.b. of these approximations.
+- The initial worklist contains all the program points. *)
+
+Fixpoint start_state_in (ep: list (atom * L.t)) : AMap.t L.t :=
+  match ep with
+  | nil =>
+      AMap.init L.bot
+  | (n, v) :: rem =>
+      let m := start_state_in rem in AMap.set n (L.lub m!!n v) m
+  end.
+
+Definition start_state :=
+  mkstate (start_state_in entrypoints) (NS.initial successors).
+
+(** [propagate_succ] corresponds, in the pseudocode,
+  to the body of the [for] loop iterating over all successors. *)
+
+Definition propagate_succ (s: state) (out: L.t) (n: atom) :=
+  let oldl := s.(st_in)!!n in
+  let newl := L.lub oldl out in
+  if L.beq oldl newl
+  then s
+  else mkstate (AMap.set n newl s.(st_in)) (NS.add n s.(st_wrk)).
+
+(** [propagate_succ_list] corresponds, in the pseudocode,
+  to the [for] loop iterating over all successors. *)
+
+Fixpoint propagate_succ_list (s: state) (out: L.t) (succs: set atom)
+                             {struct succs} : state :=
+  match succs with
+  | nil => s
+  | n :: rem => propagate_succ_list (propagate_succ s out n) out rem
+  end.
+
+(** [step] corresponds to the body of the outer [while] loop in the
+  pseudocode. *)
+
+Definition step (s: state) : AMap.t L.t + state :=
+  match NS.pick s.(st_wrk) with
+  | None =>
+      inl _ s.(st_in)
+  | Some(n, rem) =>
+      inr _ (propagate_succ_list
+              (mkstate s.(st_in) rem)
+              (transf n s.(st_in)!!n)
+              (successors!!!n))
+  end.
+
+(** The whole fixpoint computation is the iteration of [step] from
+  the start state. *)
+
+Definition fixpoint num_iterations : option (AMap.t L.t) :=
+  PrimIter.iter _ _ step num_iterations start_state.
+
+(** ** Monotonicity properties *)
+
+(** We first show that the [st_in] part of the state evolves monotonically:
+  at each step, the values of the [st_in[n]] either remain the same or
+  increase with respect to the [L.ge] ordering. *)
+
+Definition in_incr (in1 in2: AMap.t L.t) : Prop :=
+  forall n, L.ge in2!!n in1!!n.
+
+Lemma in_incr_refl:
+  forall in1, in_incr in1 in1.
+Proof.
+  unfold in_incr; intros. apply L.ge_refl. apply L.eq_refl.
+Qed.
+
+Lemma in_incr_trans:
+  forall in1 in2 in3, in_incr in1 in2 -> in_incr in2 in3 -> in_incr in1 in3.
+Proof.
+  unfold in_incr; intros. apply L.ge_trans with in2!!n; auto.
+Qed.
+
+Lemma propagate_succ_incr:
+  forall st out n,
+  in_incr st.(st_in) (propagate_succ st out n).(st_in).
+Proof.
+  unfold in_incr, propagate_succ; simpl; intros.
+  case (L.beq st.(st_in)!!n (L.lub st.(st_in)!!n out)).
+  apply L.ge_refl. apply L.eq_refl.
+  simpl. case (eq_atom_dec n n0); intro.
+  subst n0. rewrite AMap.gss. apply L.ge_lub_left.
+  rewrite AMap.gso; auto. apply L.ge_refl. apply L.eq_refl.
+Qed.
+
+Lemma propagate_succ_list_incr:
+  forall out scs st,
+  in_incr st.(st_in) (propagate_succ_list st out scs).(st_in).
+Proof.
+  induction scs; simpl; intros.
+  apply in_incr_refl.
+  apply in_incr_trans with (propagate_succ st out a).(st_in).
+  apply propagate_succ_incr. auto.
+Qed.
+
+Lemma step_incr: forall st st' 
+  (Hstep: step st = inr st'),
+  in_incr (st_in st) (st_in st').
+Proof.
+  unfold step.
+  intros.
+  remember (NS.pick (st_wrk st)) as R.
+  destruct R as [ [n rem] | ]; inv Hstep.
+  change st.(st_in) with (mkstate st.(st_in) rem).(st_in).
+  apply propagate_succ_list_incr; auto.
+Qed.
+
+Lemma fixpoint_incr:
+  forall res ni,
+  fixpoint ni = Some res -> in_incr (start_state_in entrypoints) res.
+Proof.
+  unfold fixpoint; intros.
+  change (start_state_in entrypoints) with start_state.(st_in).
+  eapply (PrimIter.iter_prop _ _ step
+    (fun st => in_incr start_state.(st_in) st.(st_in))
+    (fun res => in_incr start_state.(st_in) res)) in H; eauto.
+
+  intros st INCR. unfold step.
+  destruct (NS.pick st.(st_wrk)) as [ [n rem] | ].
+  apply in_incr_trans with st.(st_in). auto.
+  change st.(st_in) with (mkstate st.(st_in) rem).(st_in).
+  apply propagate_succ_list_incr.
+  auto.
+
+  eauto. apply in_incr_refl.
+Qed.
+
+(** ** Correctness invariant *)
+
+(** The following invariant is preserved at each iteration of Kildall's
+  algorithm: for all program points [n], either
+  [n] is in the worklist, or the inequations associated with [n]
+  ([st_in[s] >= transf n st_in[n]] for all successors [s] of [n])
+  hold.  In other terms, the worklist contains all nodes that do not
+  yet satisfy their inequations. *)
+
+Definition good_state (st: state) : Prop :=
+  forall n,
+  NS.In n st.(st_wrk) \/
+  (forall s, In s (successors!!!n) ->
+             L.ge st.(st_in)!!s (transf n st.(st_in)!!n)).
+
+(** We show that the start state satisfies the invariant, and that
+  the [step] function preserves it. *)
+
+Lemma start_state_good:
+  good_state start_state.
+Proof.
+  unfold good_state, start_state; intros.
+  case_eq (successors!n); intros.
+  left; simpl. eapply NS.initial_spec. eauto.
+  unfold XATree.successors_list. rewrite H. right; intros. contradiction.
+Qed.
+
+Lemma propagate_succ_spec:
+  forall st out n,
+  let st' := propagate_succ st out n in
+  (L.eq st'.(st_in)!!n (L.lub st.(st_in)!!n out)) /\
+  (forall s, n <> s -> st'.(st_in)!!s = st.(st_in)!!s).
+Proof.
+  unfold propagate_succ; intros; simpl.
+  predSpec L.beq L.beq_correct
+           ((st_in st) !! n) (L.lub (st_in st) !! n out).
+  split; auto.
+
+  simpl. split.
+    rewrite AMap.gss. apply L.eq_refl.
+    intros. rewrite AMap.gso; auto.
+Qed.
+
+Lemma propagate_succ_charact:
+  forall st out n,
+  let st' := propagate_succ st out n in
+  L.ge st'.(st_in)!!n out /\
+  (forall s, n <> s -> st'.(st_in)!!s = st.(st_in)!!s).
+Proof.
+  unfold propagate_succ; intros; simpl.
+  predSpec L.beq L.beq_correct
+           ((st_in st) !! n) (L.lub (st_in st) !! n out).
+  split.
+  eapply L.ge_trans. apply L.ge_refl. apply H; auto.
+  eapply L.ge_compat. apply L.lub_commut. apply L.eq_refl.
+  apply L.ge_lub_left.
+  auto.
+
+  simpl. split.
+  rewrite AMap.gss.
+  eapply L.ge_compat. apply L.lub_commut. apply L.eq_refl.
+  apply L.ge_lub_left.
+  intros. rewrite AMap.gso; auto.
+Qed.
+
+Lemma propagate_succ_list_charact:
+  forall out scs st,
+  let st' := propagate_succ_list st out scs in
+  forall s,
+  (In s scs -> L.ge st'.(st_in)!!s out) /\
+  (~(In s scs) -> st'.(st_in)!!s = st.(st_in)!!s).
+Proof.
+  induction scs; simpl; intros.
+  tauto.
+  generalize (IHscs (propagate_succ st out a) s). intros [A B].
+  generalize (propagate_succ_charact st out a). intros [C D].
+  split; intros.
+  elim H; intro.
+  subst s.
+  apply L.ge_trans with (propagate_succ st out a).(st_in)!!a.
+  apply propagate_succ_list_incr. assumption.
+  apply A. auto.
+  transitivity (propagate_succ st out a).(st_in)!!s.
+  apply B. tauto.
+  apply D. tauto.
+Qed.
+
+Lemma propagate_succ_incr_worklist:
+  forall st out n x,
+  NS.In x st.(st_wrk) -> NS.In x (propagate_succ st out n).(st_wrk).
+Proof.
+  intros. unfold propagate_succ.
+  case (L.beq (st_in st) !! n (L.lub (st_in st) !! n out)).
+  auto.
+  simpl. rewrite NS.add_spec. auto.
+Qed.
+
+Lemma propagate_succ_list_incr_worklist:
+  forall out scs st x,
+  NS.In x st.(st_wrk) -> NS.In x (propagate_succ_list st out scs).(st_wrk).
+Proof.
+  induction scs; simpl; intros.
+  auto.
+  apply IHscs. apply propagate_succ_incr_worklist. auto.
+Qed.
+
+Lemma propagate_succ_records_changes:
+  forall st out n s,
+  let st' := propagate_succ st out n in
+  NS.In s st'.(st_wrk) \/ st'.(st_in)!!s = st.(st_in)!!s.
+Proof.
+  simpl. intros. unfold propagate_succ.
+  case (L.beq (st_in st) !! n (L.lub (st_in st) !! n out)).
+  right; auto.
+  case (eq_atom_dec s n); intro.
+  subst s. left. simpl. rewrite NS.add_spec. auto.
+  right. simpl. apply AMap.gso. auto.
+Qed.
+
+Lemma propagate_succ_list_records_changes:
+  forall out scs st s,
+  let st' := propagate_succ_list st out scs in
+  NS.In s st'.(st_wrk) \/ st'.(st_in)!!s = st.(st_in)!!s.
+Proof.
+  induction scs; simpl; intros.
+  right; auto.
+  elim (propagate_succ_records_changes st out a s); intro.
+  left. apply propagate_succ_list_incr_worklist. auto.
+  rewrite <- H. auto.
+Qed.
+
+Lemma step_state_good:
+  forall st n rem,
+  NS.pick st.(st_wrk) = Some(n, rem) ->
+  good_state st ->
+  good_state (propagate_succ_list (mkstate st.(st_in) rem)
+                                  (transf n st.(st_in)!!n)
+                                  (successors!!!n)).
+Proof.
+  unfold good_state. intros st n rem WKL GOOD x.
+  generalize (NS.pick_some _ _ _ WKL); intro PICK.
+  set (out := transf n st.(st_in)!!n).
+  elim (propagate_succ_list_records_changes
+          out (successors!!!n) (mkstate st.(st_in) rem) x).
+  intro; left; auto.
+  simpl; intros EQ. rewrite EQ.
+  (* Case 1: x = n *)
+  case (eq_atom_dec x n); intro.
+  subst x.
+  right; intros.
+  elim (propagate_succ_list_charact out (successors!!!n)
+          (mkstate st.(st_in) rem) s); intros.
+  auto.
+  (* Case 2: x <> n *)
+  elim (GOOD x); intro.
+  (* Case 2.1: x was already in worklist, still is *)
+  left. apply propagate_succ_list_incr_worklist.
+  simpl. rewrite PICK in H. elim H; intro. congruence. auto.
+  (* Case 2.2: x was not in worklist *)
+  right; intros.
+  case (In_dec eq_atom_dec s (successors!!!n)); intro.
+  (* Case 2.2.1: s is a successor of n, it may have increased *)
+  apply L.ge_trans with st.(st_in)!!s.
+  change st.(st_in)!!s with (mkstate st.(st_in) rem).(st_in)!!s.
+  apply propagate_succ_list_incr.
+  auto.
+  (* Case 2.2.2: s is not a successor of n, it did not change *)
+  elim (propagate_succ_list_charact out (successors!!!n)
+          (mkstate st.(st_in) rem) s); intros.
+  rewrite H2. simpl. auto. auto.
+Qed.
+
+(** ** Correctness of the solution returned by [iterate]. *)
+
+(** As a consequence of the [good_state] invariant, the result of
+  [fixpoint], if defined, is a solution of the dataflow inequations,
+  since [st_wrk] is empty when the iteration terminates. *)
+
+Theorem fixpoint_solution:
+  forall res ni n s,
+  fixpoint ni = Some res ->
+  In s (successors!!!n) ->
+  L.ge res!!s (transf n res!!n).
+Proof.
+  assert (forall res ni, fixpoint ni = Some res ->
+          forall n s,
+          In s successors!!!n ->
+          L.ge res!!s (transf n res!!n)).
+    unfold fixpoint. intros res ni PI. pattern res.
+    eapply (PrimIter.iter_prop _ _ step good_state) in PI; eauto.
+      intros st GOOD. unfold step.
+      caseEq (NS.pick st.(st_wrk)); auto.
+        intros [n rem] PICK. apply step_state_good; auto.
+
+        intros.  
+        elim (GOOD n); intro; auto.
+        elim (NS.pick_none _ n H); auto.
+      eauto. apply start_state_good. 
+  eauto.
+Qed.
+
+(** As a consequence of the monotonicity property, the result of
+  [fixpoint], if defined, is pointwise greater than or equal the
+  initial mapping.  Therefore, it satisfies the additional constraints
+  stated in [entrypoints]. *)
+
+Lemma start_state_in_entry:
+  forall ep n v,
+  In (n, v) ep ->
+  L.ge (start_state_in ep)!!n v.
+Proof.
+  induction ep; simpl; intros.
+  elim H.
+  elim H; intros.
+  subst a. rewrite AMap.gss.
+  eapply L.ge_compat. apply L.lub_commut. apply L.eq_refl.
+  apply L.ge_lub_left.
+  destruct a. rewrite AMap.gsspec. case (eq_atom_dec n a); intro.
+  subst a. apply L.ge_trans with (start_state_in ep)!!n.
+  apply L.ge_lub_left. auto.
+  auto.
+Qed.
+
+Theorem fixpoint_entry:
+  forall res ni n v,
+  fixpoint ni = Some res ->
+  In (n, v) entrypoints ->
+  L.ge res!!n v.
+Proof.
+  intros.
+  apply L.ge_trans with (start_state_in entrypoints)!!n.
+    eapply fixpoint_incr. eauto.
+    apply start_state_in_entry. auto.
+Qed.
+
+(** ** Preservation of a property over solutions *)
+
+Variable P: L.t -> Prop.
+Hypothesis P_bot: P L.bot.
+Hypothesis P_lub: forall x y, P x -> P y -> P (L.lub x y).
+Hypothesis P_transf: forall pc x, P x -> P (transf pc x).
+Hypothesis P_entrypoints: forall n v, In (n, v) entrypoints -> P v.
+
+Theorem fixpoint_invariant:
+  forall res ni pc,
+  fixpoint ni = Some res ->
+  P res!!pc.
+Proof.
+  assert (forall ep,
+          (forall n v, In (n, v) ep -> P v) ->
+          forall pc, P (start_state_in ep)!!pc).
+    induction ep; intros; simpl.
+    rewrite AMap.gi. auto.
+    simpl in H.
+    assert (P (start_state_in ep)!!pc). apply IHep. eauto.
+    destruct a as [n v]. rewrite AMap.gsspec. destruct (eq_atom_dec pc n).
+    apply P_lub. subst. auto. eapply H. left; reflexivity. auto.
+  set (inv := fun st => forall pc, P (st.(st_in)!!pc)).
+  assert (forall st v n, inv st -> P v -> inv (propagate_succ st v n)).
+    unfold inv, propagate_succ. intros.
+    destruct (L.beq (st_in st)!!n (L.lub (st_in st)!!n v)).
+    auto. simpl. rewrite AMap.gsspec. destruct (eq_atom_dec pc n).
+    apply P_lub. subst n; auto. auto.
+    auto.
+  assert (forall l0 st v, inv st -> P v -> inv (propagate_succ_list st v l0)).
+    induction l0; intros; simpl. auto.
+    apply IHl0; auto.
+  assert (forall res ni, fixpoint ni = Some res -> forall pc, P res!!pc).
+    unfold fixpoint. intros res0 ni0 RES0. pattern res0.
+    eapply (PrimIter.iter_prop _ _ step inv); eauto.
+      intros. unfold step. 
+      destruct (NS.pick (st_wrk a)) as [[n rem] | ].
+        apply H1. auto. apply P_transf. apply H2.
+        assumption.
+      unfold inv, start_state; simpl. auto.
+  intros. eauto.
+Qed.
+
+(** ** Another invariant for unreachable nodes *)
+
+Definition good_unreach (res: AMap.t L.t) : Prop :=
+  forall n,
+  ((XATree.make_predecessors successors)!!!n = nil ->
+    res!!n = (start_state_in entrypoints)!!n).
+
+(** We show that the start state satisfies the invariant, and that
+  the [step] function preserves it. *)
+
+Lemma propagate_succ_good_unreach: forall st n out,
+  (XATree.make_predecessors successors)!!!n <> nil ->
+  good_unreach st.(st_in) -> good_unreach (propagate_succ st out n).(st_in).
+Proof.
+  unfold good_unreach.
+  intros.
+  destruct (@propagate_succ_spec st out n) as [J1 J2].
+  destruct (eq_atom_dec n n0); subst.
+    contradict H; auto.
+    apply H0 in H1. rewrite <- H1. auto.
+Qed.
+
+Lemma propagate_succ_list_good_unreach:
+  forall scs st out,
+  (forall s, In s scs -> (XATree.make_predecessors successors)!!!s <> nil) ->
+  good_unreach st.(st_in) ->
+  good_unreach (propagate_succ_list st out scs).(st_in).
+Proof.
+  induction scs; simpl; intros; auto.
+    apply IHscs; auto.
+      eapply propagate_succ_good_unreach; eauto.
+Qed.
+
+Lemma step_unreach_good:
+  forall st n rem,
+  NS.pick st.(st_wrk) = Some(n, rem) ->
+  good_unreach st.(st_in) ->
+  good_unreach (propagate_succ_list (mkstate st.(st_in) rem)
+                                    (transf n st.(st_in)!!n)
+                                    (successors!!!n)).(st_in).
+Proof.
+  intros st n rem WKL GOOD.
+  destruct st. simpl.
+  apply propagate_succ_list_good_unreach; auto.
+  intros.
+  apply XATree.make_predecessors_correct in H. intro J. rewrite J in H. inv H.
+Qed.
+
+Theorem fixpoint_good_unreach: forall res ni,
+  fixpoint ni = Some res -> good_unreach res.
+Proof.
+  unfold fixpoint. intros res ni PI. pattern res.
+  eapply (PrimIter.iter_prop _ _ step
+    (fun st => good_unreach st.(st_in))); eauto.
+  intros st GOOD. unfold step.
+  caseEq (NS.pick st.(st_wrk)); auto.
+  intros [n rem] PICK. apply step_unreach_good; auto.
+  intros x J. unfold start_state. simpl. auto.
+Qed.
+
+End Kildall.
+
+Section FixpointInvariant2.
+
+Variable successors: ATree.t (list atom).
+Variable transf1: atom -> L.t -> L.t.
+Variable transf2: atom -> L.t -> L.t.
+Variable entrypoints1: list (atom * L.t).
+Variable entrypoints2: list (atom * L.t).
+
+Variable P: L.t -> L.t -> Prop.
+Hypothesis P_bot: P L.bot L.bot.
+Hypothesis P_lub: forall x1 x2 y1 y2,
+  P x1 x2 -> P y1 y2 -> P (L.lub x1 y1) (L.lub x2 y2).
+Hypothesis P_transf: forall pc x1 x2,
+  P x1 x2 -> P (transf1 pc x1) (transf2 pc x2).
+Definition P_entrypoints_aux (ep1: list (atom * L.t)) (ep2: list (atom * L.t))
+  := Forall2 (fun el1 el2 =>
+           match el1, el2 with
+           | (n1,v1), (n2,v2) => n1 = n2 /\ P v1 v2
+           end) ep1 ep2.
+Hypothesis P_entrypoints: P_entrypoints_aux entrypoints1 entrypoints2.
+Hypothesis P_beq : forall x1 x2 y1 y2,
+  P x1 x2 -> P y1 y2 ->
+  L.beq y1 (L.lub y1 x1) =
+  L.beq y2 (L.lub y2 x2).
+
+Lemma start_state_in_invariant2 : forall ep1 ep2
+  (H:P_entrypoints_aux ep1 ep2) pc,
+  P (start_state_in ep1)!!pc (start_state_in ep2)!!pc.
+Proof.
+  induction ep1; destruct ep2; intros; simpl; inv H.
+    repeat rewrite AMap.gi. auto.
+
+    destruct a as [n1 v1]. destruct p as [n2 v2].
+    destruct H3 as [Heq H3]; subst.
+    assert (P (start_state_in ep1)!!pc
+              (start_state_in ep2)!!pc).
+      apply IHep1. eauto.
+    repeat rewrite AMap.gsspec.
+    destruct (eq_atom_dec pc n2); subst; auto.
+Qed.
+
+Hint Resolve start_state_in_invariant2.
+
+Definition invariant2 := fun st1 st2 =>
+    st1.(st_wrk) = st2.(st_wrk) /\
+    forall pc, P (st1.(st_in)!!pc) (st2.(st_in)!!pc).
+
+Lemma propagate_succ_invariant2 : forall st1 st2 v1 v2 n
+  (H:invariant2 st1 st2) (H0:P v1 v2),
+  invariant2 (propagate_succ st1 v1 n) (propagate_succ st2 v2 n).
+Proof.
+  unfold invariant2, propagate_succ. intros.
+  destruct H as [J1 J2].
+  case_eq (L.beq (st_in st1)!!n (L.lub (st_in st1)!!n v1)).
+    intros Hbeq.
+    erewrite P_beq in Hbeq; eauto. rewrite Hbeq. auto.
+
+    intros Hbeq.
+    erewrite P_beq in Hbeq; eauto. rewrite Hbeq.
+    simpl. rewrite J1. split; auto.
+    intro pc. repeat rewrite AMap.gsspec.
+    destruct (eq_atom_dec pc n); subst; auto.
+Qed.
+
+Hint Resolve propagate_succ_invariant2.
+
+Lemma propagate_succ_list_invariant2 : forall l0 st1 st2 v1 v2,
+  invariant2 st1 st2 -> P v1 v2 ->
+  invariant2 (propagate_succ_list st1 v1 l0)
+             (propagate_succ_list st2 v2 l0).
+Proof.
+  induction l0; intros; simpl. auto.
+  apply IHl0; auto.
+Qed.
+
+Hint Resolve propagate_succ_list_invariant2.
+
+Theorem fixpoint_some2:
+  forall res1 res2 ni pc,
+  fixpoint successors transf1 entrypoints1 ni = Some res1 ->
+  fixpoint successors transf2 entrypoints2 ni = Some res2 ->
+  P res1!!pc res2!!pc.
+Proof.
+  intros res1 res2 ni pc Hinter1 Hinter2.
+  revert pc.
+  unfold fixpoint. pattern res1, res2.
+  eapply (PrimIter.iter_some2 _ _ _ _
+    (step successors transf1)
+    (step successors transf2) invariant2); eauto.
+    intros a1 a2 H2. unfold step.
+    destruct H2 as [J1 J2]. rewrite J1.
+    destruct (NS.pick (st_wrk a2))
+      as [[n rem] | ]; eauto.
+      apply propagate_succ_list_invariant2; auto.
+        split; auto.
+    unfold invariant2, start_state; simpl. auto.
+Qed.
+
+Theorem fixpoint_none2_right: forall ni,
+  fixpoint successors transf2 entrypoints2 ni = None ->
+  fixpoint successors transf1 entrypoints1 ni = None.
+Proof.
+  unfold fixpoint.
+  intros Hinter2.
+  eapply (PrimIter.iter_none2_right _ _ _ _
+    (step successors transf1)
+    (step successors transf2) invariant2); eauto.
+    intros a1 a2 H2. unfold step.
+    destruct H2 as [J1 J2]. rewrite J1.
+    destruct (NS.pick (st_wrk a2))
+      as [[n rem] | ]; eauto.
+      apply propagate_succ_list_invariant2; auto.
+        split; auto.
+    unfold invariant2, start_state; simpl. auto.
+Qed.
+
+Theorem fixpoint_none2_left: forall ni,
+  fixpoint successors transf1 entrypoints1 ni = None ->
+  fixpoint successors transf2 entrypoints2 ni = None.
+Proof.
+  unfold fixpoint.
+  intros Hinter1.
+  eapply (PrimIter.iter_none2_left _ _ _ _
+    (step successors transf1)
+    (step successors transf2) invariant2); eauto.
+    intros a1 a2 H2. unfold step.
+    destruct H2 as [J1 J2]. rewrite J1.
+    destruct (NS.pick (st_wrk a2))
+      as [[n rem] | ]; eauto.
+      apply propagate_succ_list_invariant2; auto.
+        split; auto.
+    unfold invariant2, start_state; simpl. auto.
+Qed.
+
+Theorem fixpoint_some2_right:
+  forall res2 ni pc,
+  fixpoint successors transf2 entrypoints2 ni = Some res2 ->
+  exists res1,
+    fixpoint successors transf1 entrypoints1 ni = Some res1 /\
+    P res1!!pc res2!!pc.
+Proof.
+  intros res2 ni pc Hfix2.
+  case_eq (fixpoint successors transf1 entrypoints1 ni).
+    intros res1 Hfix1.
+    exists res1. split; eauto using fixpoint_some2.
+
+    intros Hfix1.
+    eapply fixpoint_none2_left in Hfix1; eauto.
+    rewrite Hfix1 in Hfix2. congruence.
+Qed.
+
+Theorem fixpoint_some2_left:
+  forall res1 ni pc,
+  fixpoint successors transf1 entrypoints1 ni = Some res1 ->
+  exists res2,
+    fixpoint successors transf2 entrypoints2 ni = Some res2 /\
+    P res1!!pc res2!!pc.
+Proof.
+  intros res1 ni pc Hfix1.
+  case_eq (fixpoint successors transf2 entrypoints2 ni).
+    intros res2 Hfix2.
+    exists res2. split; eauto using fixpoint_some2.
+
+    intros Hfix2.
+    eapply fixpoint_none2_right in Hfix2; eauto.
+    rewrite Hfix2 in Hfix1. congruence.
+Qed.
+
+End FixpointInvariant2.
+
+End Dataflow_Solver_Var_Top.
 
diff -ruN lib/compcert-1.9/Lattice.v lib.patched/compcert-1.9/Lattice.v
--- lib/compcert-1.9/Lattice.v	2014-08-30 20:09:04.806089049 -0400
+++ lib.patched/compcert-1.9/Lattice.v	2014-08-30 00:29:06.159588829 -0400
@@ -15,11 +15,12 @@
 Require Import Coqlib.
 Require Import Maps.
 Require Import FSets.
+Require Import Metatheory.
 
 (** * Signatures of semi-lattices *)
 
 (** A semi-lattice is a type [t] equipped with an equivalence relation [eq],
-  a boolean equivalence test [beq], a partial order [ge], a smallest element 
+  a boolean equivalence test [beq], a partial order [ge], a smallest element
   [bot], and an upper bound operation [lub].
   Note that we do not demand that [lub] computes the least upper bound. *)
 
@@ -35,11 +36,12 @@
   Variable ge: t -> t -> Prop.
   Hypothesis ge_refl: forall x y, eq x y -> ge x y.
   Hypothesis ge_trans: forall x y z, ge x y -> ge y z -> ge x z.
+  Hypothesis ge_compat: forall x x' y y', eq x x' -> eq y y' -> ge x y -> ge x' y'.
   Variable bot: t.
   Hypothesis ge_bot: forall x, ge x bot.
   Variable lub: t -> t -> t.
+  Hypothesis lub_commut: forall x y, eq (lub x y) (lub y x).
   Hypothesis ge_lub_left: forall x y, ge (lub x y) x.
-  Hypothesis ge_lub_right: forall x y, ge (lub x y) y.
 
 End SEMILATTICE.
 
@@ -56,47 +58,45 @@
 
 (** * Semi-lattice over maps *)
 
-Set Implicit Arguments.
-
 (** Given a semi-lattice with top [L], the following functor implements
   a semi-lattice structure over finite maps from positive numbers to [L.t].
   The default value for these maps is either [L.top] or [L.bot]. *)
 
 Module LPMap(L: SEMILATTICE_WITH_TOP) <: SEMILATTICE_WITH_TOP.
 
-Inductive t' : Type :=
-  | Bot_except: PTree.t L.t -> t'
-  | Top_except: PTree.t L.t -> t'.
+Inductive t_ : Type :=
+  | Bot_except: ATree'.t L.t -> t_
+  | Top_except: ATree'.t L.t -> t_.
 
-Definition t: Type := t'.
+Definition t: Type := t_.
 
-Definition get (p: positive) (x: t) : L.t :=
+Definition get (p: atom) (x: t) : L.t :=
   match x with
   | Bot_except m =>
-      match m!p with None => L.bot | Some x => x end
+      match ATree'.get p m with None => L.bot | Some x => x end
   | Top_except m =>
-      match m!p with None => L.top | Some x => x end
+      match ATree'.get p m with None => L.top | Some x => x end
   end.
 
-Definition set (p: positive) (v: L.t) (x: t) : t :=
+Definition set (p: atom) (v: L.t) (x: t) : t :=
   match x with
   | Bot_except m =>
-      Bot_except (if L.beq v L.bot then PTree.remove p m else PTree.set p v m)
+      Bot_except (if L.beq v L.bot then ATree'.remove p m else ATree'.set p v m)
   | Top_except m =>
-      Top_except (if L.beq v L.top then PTree.remove p m else PTree.set p v m)
+      Top_except (if L.beq v L.top then ATree'.remove p m else ATree'.set p v m)
   end.
 
 Lemma gss:
   forall p v x,
   L.eq (get p (set p v x)) v.
 Proof.
-  intros. destruct x; simpl. 
+  intros. destruct x; simpl.
   case_eq (L.beq v L.bot); intros.
-  rewrite PTree.grs. apply L.eq_sym. apply L.beq_correct; auto. 
-  rewrite PTree.gss. apply L.eq_refl.
+  rewrite ATree'.grs. apply L.eq_sym. apply L.beq_correct; auto.
+  rewrite ATree'.gss. apply L.eq_refl.
   case_eq (L.beq v L.top); intros.
-  rewrite PTree.grs. apply L.eq_sym. apply L.beq_correct; auto. 
-  rewrite PTree.gss. apply L.eq_refl.
+  rewrite ATree'.grs. apply L.eq_sym. apply L.beq_correct; auto.
+  rewrite ATree'.gss. apply L.eq_refl.
 Qed.
 
 Lemma gso:
@@ -104,8 +104,8 @@
   p <> q -> get p (set q v x) = get p x.
 Proof.
   intros. destruct x; simpl.
-  destruct (L.beq v L.bot). rewrite PTree.gro; auto. rewrite PTree.gso; auto.
-  destruct (L.beq v L.top). rewrite PTree.gro; auto. rewrite PTree.gso; auto.
+  destruct (L.beq v L.bot). rewrite ATree'.gro; auto. rewrite ATree'.gso; auto.
+  destruct (L.beq v L.top). rewrite ATree'.gro; auto. rewrite ATree'.gso; auto.
 Qed.
 
 Definition eq (x y: t) : Prop :=
@@ -128,8 +128,8 @@
 
 Definition beq (x y: t) : bool :=
   match x, y with
-  | Bot_except m, Bot_except n => PTree.beq L.beq m n
-  | Top_except m, Top_except n => PTree.beq L.beq m n
+  | Bot_except m, Bot_except n => ATree'.beq L.beq m n
+  | Top_except m, Top_except n => ATree'.beq L.beq m n
   | _, _ => false
   end.
 
@@ -137,11 +137,11 @@
 Proof.
   destruct x; destruct y; simpl; intro; try congruence.
   red; intro; simpl.
-  generalize (PTree.beq_correct L.eq L.beq L.beq_correct t0 t1 H p).
-  destruct (t0!p); destruct (t1!p); intuition. apply L.eq_refl.
+  generalize (@ATree'.beq_correct _ L.eq L.beq L.beq_correct t0 t1 H p).
+  destruct (ATree'.get p t0); destruct (ATree'.get p t1); intuition. apply L.eq_refl.
   red; intro; simpl.
-  generalize (PTree.beq_correct L.eq L.beq L.beq_correct t0 t1 H p).
-  destruct (t0!p); destruct (t1!p); intuition. apply L.eq_refl.
+  generalize (@ATree'.beq_correct _ L.eq L.beq L.beq_correct t0 t1 H p).
+  destruct (ATree'.get p t0); destruct (ATree'.get p t1); intuition. apply L.eq_refl.
 Qed.
 
 Definition ge (x y: t) : Prop :=
@@ -157,11 +157,16 @@
   unfold ge; intros. apply L.ge_trans with (get p y); auto.
 Qed.
 
-Definition bot := Bot_except (PTree.empty L.t).
+Lemma ge_compat: forall x x' y y', eq x x' -> eq y y' -> ge x y -> ge x' y'.
+Proof.
+  unfold eq,ge; intros. eapply L.ge_compat; eauto.
+Qed.
+
+Definition bot := Bot_except (ATree'.empty L.t).
 
 Lemma get_bot: forall p, get p bot = L.bot.
 Proof.
-  unfold bot; intros; simpl. rewrite PTree.gempty. auto.
+  unfold bot; intros; simpl. rewrite ATree'.gempty. auto.
 Qed.
 
 Lemma ge_bot: forall x, ge x bot.
@@ -169,11 +174,11 @@
   unfold ge; intros. rewrite get_bot. apply L.ge_bot.
 Qed.
 
-Definition top := Top_except (PTree.empty L.t).
+Definition top := Top_except (ATree'.empty L.t).
 
 Lemma get_top: forall p, get p top = L.top.
 Proof.
-  unfold top; intros; simpl. rewrite PTree.gempty. auto.
+  unfold top; intros; simpl. rewrite ATree'.gempty. auto.
 Qed.
 
 Lemma ge_top: forall x, ge top x.
@@ -181,232 +186,6 @@
   unfold ge; intros. rewrite get_top. apply L.ge_top.
 Qed.
 
-(** A [combine] operation over the type [PTree.t L.t] that attempts
-  to share its result with its arguments. *)
-
-Section COMBINE.
-
-Variable f: option L.t -> option L.t -> option L.t.
-Hypothesis f_none_none: f None None = None.
-
-Definition opt_eq (ox oy: option L.t) : Prop :=
-  match ox, oy with
-  | None, None => True
-  | Some x, Some y => L.eq x y
-  | _, _ => False
-  end.
-
-Lemma opt_eq_refl: forall ox, opt_eq ox ox.
-Proof.
-  intros. unfold opt_eq. destruct ox. apply L.eq_refl. auto. 
-Qed.
-
-Lemma opt_eq_sym: forall ox oy, opt_eq ox oy -> opt_eq oy ox.
-Proof.
-  unfold opt_eq. destruct ox; destruct oy; auto. apply L.eq_sym. 
-Qed.
-
-Lemma opt_eq_trans: forall ox oy oz, opt_eq ox oy -> opt_eq oy oz -> opt_eq ox oz.
-Proof.
-  unfold opt_eq. destruct ox; destruct oy; destruct oz; intuition. 
-  eapply L.eq_trans; eauto.
-Qed.
-
-Definition opt_beq (ox oy: option L.t) : bool :=
-  match ox, oy with
-  | None, None => true
-  | Some x, Some y => L.beq x y
-  | _, _ => false
-  end.
-
-Lemma opt_beq_correct:
-  forall ox oy, opt_beq ox oy = true -> opt_eq ox oy.
-Proof.
-  unfold opt_beq, opt_eq. destruct ox; destruct oy; try congruence. 
-  intros. apply L.beq_correct; auto. 
-  auto.
-Qed.
-
-Definition tree_eq (m1 m2: PTree.t L.t) : Prop :=
-  forall i, opt_eq (PTree.get i m1) (PTree.get i m2).
-
-Lemma tree_eq_refl: forall m, tree_eq m m.
-Proof. intros; red; intros; apply opt_eq_refl. Qed.
-
-Lemma tree_eq_sym: forall m1 m2, tree_eq m1 m2 -> tree_eq m2 m1.
-Proof. intros; red; intros; apply opt_eq_sym; auto. Qed.
-
-Lemma tree_eq_trans: forall m1 m2 m3, tree_eq m1 m2 -> tree_eq m2 m3 -> tree_eq m1 m3.
-Proof. intros; red; intros; apply opt_eq_trans with (PTree.get i m2); auto. Qed.
-
-Lemma tree_eq_node: 
-  forall l1 o1 r1 l2 o2 r2,
-  tree_eq l1 l2 -> tree_eq r1 r2 -> opt_eq o1 o2 ->
-  tree_eq (PTree.Node l1 o1 r1) (PTree.Node l2 o2 r2).
-Proof.
-  intros; red; intros. destruct i; simpl; auto.
-Qed.
-
-Lemma tree_eq_node': 
-  forall l1 o1 r1 l2 o2 r2,
-  tree_eq l1 l2 -> tree_eq r1 r2 -> opt_eq o1 o2 ->
-  tree_eq (PTree.Node l1 o1 r1) (PTree.Node' l2 o2 r2).
-Proof.
-  intros; red; intros. rewrite PTree.gnode'. apply tree_eq_node; auto. 
-Qed.
-
-Lemma tree_eq_node'': 
-  forall l1 o1 r1 l2 o2 r2,
-  tree_eq l1 l2 -> tree_eq r1 r2 -> opt_eq o1 o2 ->
-  tree_eq (PTree.Node' l1 o1 r1) (PTree.Node' l2 o2 r2).
-Proof.
-  intros; red; intros. repeat rewrite PTree.gnode'. apply tree_eq_node; auto. 
-Qed.
-
-Hint Resolve opt_beq_correct opt_eq_refl opt_eq_sym 
-             tree_eq_refl tree_eq_sym
-             tree_eq_node tree_eq_node' tree_eq_node'' : combine.
-
-Inductive changed: Type := Unchanged | Changed (m: PTree.t L.t).
-
-Fixpoint combine_l (m : PTree.t L.t) {struct m} : changed :=
-  match m with
-  | PTree.Leaf =>
-      Unchanged
-  | PTree.Node l o r =>
-      let o' := f o None in
-      match combine_l l, combine_l r with
-      | Unchanged, Unchanged => if opt_beq o' o then Unchanged else Changed (PTree.Node' l o' r)
-      | Unchanged, Changed r' => Changed (PTree.Node' l o' r')
-      | Changed l', Unchanged => Changed (PTree.Node' l' o' r)
-      | Changed l', Changed r' => Changed (PTree.Node' l' o' r')
-      end
-  end.
-
-Lemma combine_l_eq:
-  forall m,
-  tree_eq (match combine_l m with Unchanged => m | Changed m' => m' end)
-          (PTree.xcombine_l f m).
-Proof.
-  induction m; simpl.
-  auto with combine.
-  destruct (combine_l m1) as [ | l']; destruct (combine_l m2) as [ | r'];
-  auto with combine.
-  case_eq (opt_beq (f o None) o); auto with combine.
-Qed.
-
-Fixpoint combine_r (m : PTree.t L.t) {struct m} : changed :=
-  match m with
-  | PTree.Leaf =>
-      Unchanged
-  | PTree.Node l o r =>
-      let o' := f None o in
-      match combine_r l, combine_r r with
-      | Unchanged, Unchanged => if opt_beq o' o then Unchanged else Changed (PTree.Node' l o' r)
-      | Unchanged, Changed r' => Changed (PTree.Node' l o' r')
-      | Changed l', Unchanged => Changed (PTree.Node' l' o' r)
-      | Changed l', Changed r' => Changed (PTree.Node' l' o' r')
-      end
-  end.
-
-Lemma combine_r_eq:
-  forall m,
-  tree_eq (match combine_r m with Unchanged => m | Changed m' => m' end)
-          (PTree.xcombine_r f m).
-Proof.
-  induction m; simpl.
-  auto with combine.
-  destruct (combine_r m1) as [ | l']; destruct (combine_r m2) as [ | r'];
-  auto with combine.
-  case_eq (opt_beq (f None o) o); auto with combine.
-Qed.
-
-Inductive changed2 : Type :=
-  | Same
-  | Same1
-  | Same2
-  | CC(m: PTree.t L.t).
-
-Fixpoint xcombine (m1 m2 : PTree.t L.t) {struct m1} : changed2 :=
-    match m1, m2 with
-    | PTree.Leaf, PTree.Leaf => 
-        Same
-    | PTree.Leaf, _ =>
-        match combine_r m2 with
-        | Unchanged => Same2
-        | Changed m => CC m
-        end
-    | _, PTree.Leaf =>
-        match combine_l m1 with
-        | Unchanged => Same1
-        | Changed m => CC m
-        end
-    | PTree.Node l1 o1 r1, PTree.Node l2 o2 r2 =>
-        let o := f o1 o2 in
-        match xcombine l1 l2, xcombine r1 r2 with
-        | Same, Same =>
-            match opt_beq o o1, opt_beq o o2 with
-            | true, true => Same
-            | true, false => Same1
-            | false, true => Same2
-            | false, false => CC(PTree.Node' l1 o r1)
-            end
-        | Same1, Same | Same, Same1 | Same1, Same1 =>
-            if opt_beq o o1 then Same1 else CC(PTree.Node' l1 o r1)
-        | Same2, Same | Same, Same2 | Same2, Same2 =>
-            if opt_beq o o2 then Same2 else CC(PTree.Node' l2 o r2)
-        | Same1, Same2 => CC(PTree.Node' l1 o r2)
-        | (Same|Same1), CC r => CC(PTree.Node' l1 o r)
-        | Same2, Same1 => CC(PTree.Node' l2 o r1)
-        | Same2, CC r => CC(PTree.Node' l2 o r)
-        | CC l, (Same|Same1) => CC(PTree.Node' l o r1)
-        | CC l, Same2 => CC(PTree.Node' l o r2)
-        | CC l, CC r => CC(PTree.Node' l o r)
-        end
-    end.
-
-Lemma xcombine_eq:
-  forall m1 m2, 
-  match xcombine m1 m2 with
-  | Same => tree_eq m1 (PTree.combine f m1 m2) /\ tree_eq m2 (PTree.combine f m1 m2)
-  | Same1 => tree_eq m1 (PTree.combine f m1 m2)
-  | Same2 => tree_eq m2 (PTree.combine f m1 m2)
-  | CC m => tree_eq m (PTree.combine f m1 m2)
-  end.
-Proof.
-Opaque combine_l combine_r PTree.xcombine_l PTree.xcombine_r.
-  induction m1; destruct m2; simpl.
-  split; apply tree_eq_refl.
-  generalize (combine_r_eq (PTree.Node m2_1 o m2_2)).
-  destruct (combine_r (PTree.Node m2_1 o m2_2)); auto.
-  generalize (combine_l_eq (PTree.Node m1_1 o m1_2)).
-  destruct (combine_l (PTree.Node m1_1 o m1_2)); auto.
-  generalize (IHm1_1 m2_1) (IHm1_2 m2_2). 
-  destruct (xcombine m1_1 m2_1);
-  destruct (xcombine m1_2 m2_2); auto with combine;
-  intuition; case_eq (opt_beq (f o o0) o); case_eq (opt_beq (f o o0) o0); auto with combine.
-Qed.
-
-Definition combine (m1 m2: PTree.t L.t) : PTree.t L.t :=
-  match xcombine m1 m2 with
-  | Same|Same1 => m1
-  | Same2 => m2
-  | CC m => m
-  end.
-
-Lemma gcombine:
-  forall m1 m2 i, opt_eq (PTree.get i (combine m1 m2)) (f (PTree.get i m1) (PTree.get i m2)).
-Proof.
-  intros.
-  assert (tree_eq (combine m1 m2) (PTree.combine f m1 m2)).
-  unfold combine.
-  generalize (xcombine_eq m1 m2).
-  destruct (xcombine m1 m2); tauto.
-  eapply opt_eq_trans. apply H. rewrite PTree.gcombine; auto. apply opt_eq_refl.
-Qed.
-
-End COMBINE.
-
 Definition opt_lub (x y: L.t) : option L.t :=
   let z := L.lub x y in
   if L.beq z L.top then None else Some z.
@@ -415,7 +194,7 @@
   match x, y with
   | Bot_except m, Bot_except n =>
       Bot_except
-        (combine
+        (ATree'.combine
            (fun a b =>
               match a, b with
               | Some u, Some v => Some (L.lub u v)
@@ -425,27 +204,27 @@
            m n)
   | Bot_except m, Top_except n =>
       Top_except
-        (combine
+        (ATree'.combine
            (fun a b =>
               match a, b with
               | Some u, Some v => opt_lub u v
               | None, _ => b
               | _, None => None
               end)
-        m n)             
+        m n)
   | Top_except m, Bot_except n =>
       Top_except
-        (combine
+        (ATree'.combine
            (fun a b =>
               match a, b with
               | Some u, Some v => opt_lub u v
               | None, _ => None
               | _, None => a
               end)
-        m n)             
+        m n)
   | Top_except m, Top_except n =>
       Top_except
-        (combine
+        (ATree'.combine
            (fun a b =>
               match a, b with
               | Some u, Some v => opt_lub u v
@@ -454,26 +233,29 @@
            m n)
   end.
 
-Lemma gcombine_top:
-  forall f t1 t2 p,
-  f None None = None ->
-  L.eq (get p (Top_except (combine f t1 t2)))
-       (match f t1!p t2!p with Some x => x | None => L.top end).
-Proof.
-  intros. simpl. generalize (gcombine f H t1 t2 p). unfold opt_eq. 
-  destruct ((combine f t1 t2)!p); destruct (f t1!p t2!p).
-  auto. contradiction. contradiction. intros; apply L.eq_refl.
-Qed.
-
-Lemma gcombine_bot:
-  forall f t1 t2 p,
-  f None None = None ->
-  L.eq (get p (Bot_except (combine f t1 t2)))
-       (match f t1!p t2!p with Some x => x | None => L.bot end).
-Proof.
-  intros. simpl. generalize (gcombine f H t1 t2 p). unfold opt_eq. 
-  destruct ((combine f t1 t2)!p); destruct (f t1!p t2!p).
-  auto. contradiction. contradiction. intros; apply L.eq_refl.
+Lemma lub_commut:
+  forall x y, eq (lub x y) (lub y x).
+Proof.
+  intros x y p.
+  assert (forall u v,
+    L.eq (match opt_lub u v with
+          | Some x => x
+          | None => L.top end)
+         (match opt_lub v u with
+         | Some x => x
+         | None => L.top
+         end)).
+  intros. unfold opt_lub.
+  case_eq (L.beq (L.lub u v) L.top);
+  case_eq (L.beq (L.lub v u) L.top); intros.
+  apply L.eq_refl.
+  eapply L.eq_trans. apply L.eq_sym. apply L.beq_correct; eauto. apply L.lub_commut.
+  eapply L.eq_trans. apply L.lub_commut. apply L.beq_correct; auto.
+  apply L.lub_commut.
+  destruct x; destruct y; simpl;
+  repeat rewrite ATree'.gcombine; auto;
+  destruct (ATree'.get p t0); destruct (ATree'.get p t1);
+  auto; apply L.eq_refl || apply L.lub_commut.
 Qed.
 
 Lemma ge_lub_left:
@@ -481,73 +263,34 @@
 Proof.
   assert (forall u v,
     L.ge (match opt_lub u v with Some x => x | None => L.top end) u).
-  intros; unfold opt_lub. 
+  intros; unfold opt_lub.
   case_eq (L.beq (L.lub u v) L.top); intros. apply L.ge_top. apply L.ge_lub_left.
 
-  unfold ge, lub; intros. destruct x; destruct y.
+  unfold ge, get, lub; intros; destruct x; destruct y.
 
-  eapply L.ge_trans. apply L.ge_refl. apply gcombine_bot. auto. 
-  simpl. destruct t0!p; destruct t1!p.
+  rewrite ATree'.gcombine; auto.
+  destruct (ATree'.get p t0); destruct (ATree'.get p t1).
   apply L.ge_lub_left.
-  apply L.ge_refl. apply L.eq_refl. 
-  apply L.ge_bot.
   apply L.ge_refl. apply L.eq_refl.
-
-  eapply L.ge_trans. apply L.ge_refl. apply gcombine_top. auto. 
-  simpl. destruct t0!p; destruct t1!p.
-  auto.
-  apply L.ge_top.
   apply L.ge_bot.
-  apply L.ge_top.
-
-  eapply L.ge_trans. apply L.ge_refl. apply gcombine_top. auto. 
-  simpl. destruct t0!p; destruct t1!p.
-  auto.
   apply L.ge_refl. apply L.eq_refl.
-  apply L.ge_top.
-  apply L.ge_top.
 
-  eapply L.ge_trans. apply L.ge_refl. apply gcombine_top. auto. 
-  simpl. destruct t0!p; destruct t1!p.
+  rewrite ATree'.gcombine; auto.
+  destruct (ATree'.get p t0); destruct (ATree'.get p t1).
   auto.
   apply L.ge_top.
-  apply L.ge_top.
-  apply L.ge_top.
-Qed.
-
-Lemma ge_lub_right:
-  forall x y, ge (lub x y) y.
-Proof.
-  assert (forall u v,
-    L.ge (match opt_lub u v with Some x => x | None => L.top end) v).
-  intros; unfold opt_lub. 
-  case_eq (L.beq (L.lub u v) L.top); intros. apply L.ge_top. apply L.ge_lub_right.
-
-  unfold ge, lub; intros. destruct x; destruct y.
-
-  eapply L.ge_trans. apply L.ge_refl. apply gcombine_bot. auto. 
-  simpl. destruct t0!p; destruct t1!p.
-  apply L.ge_lub_right.
   apply L.ge_bot.
-  apply L.ge_refl. apply L.eq_refl. 
-  apply L.ge_refl. apply L.eq_refl.
-
-  eapply L.ge_trans. apply L.ge_refl. apply gcombine_top. auto. 
-  simpl. destruct t0!p; destruct t1!p.
-  auto.
-  apply L.ge_top.
-  apply L.ge_refl. apply L.eq_refl.
   apply L.ge_top.
 
-  eapply L.ge_trans. apply L.ge_refl. apply gcombine_top. auto. 
-  simpl. destruct t0!p; destruct t1!p.
+  rewrite ATree'.gcombine; auto.
+  destruct (ATree'.get p t0); destruct (ATree'.get p t1).
   auto.
-  apply L.ge_bot.
+  apply L.ge_refl. apply L.eq_refl.
   apply L.ge_top.
   apply L.ge_top.
 
-  eapply L.ge_trans. apply L.ge_refl. apply gcombine_top. auto. 
-  simpl. destruct t0!p; destruct t1!p.
+  rewrite ATree'.gcombine; auto.
+  destruct (ATree'.get p t0); destruct (ATree'.get p t1).
   auto.
   apply L.ge_top.
   apply L.ge_top.
@@ -561,7 +304,7 @@
 (** Given a set [S: FSetInterface.S], the following functor
     implements a semi-lattice over these sets, ordered by inclusion. *)
 
-Module LFSet (S: FSetInterface.WS) <: SEMILATTICE.
+Module LFSet (S: FSetInterface.S) <: SEMILATTICE.
 
   Definition t := S.t.
 
@@ -575,12 +318,16 @@
   Definition ge (x y: t) := S.Subset y x.
   Lemma ge_refl: forall x y, eq x y -> ge x y.
   Proof.
-    unfold eq, ge, S.Equal, S.Subset; intros. firstorder. 
+    unfold eq, ge, S.Equal, S.Subset; intros. firstorder.
   Qed.
   Lemma ge_trans: forall x y z, ge x y -> ge y z -> ge x z.
   Proof.
     unfold ge, S.Subset; intros. eauto.
   Qed.
+  Lemma ge_compat: forall x x' y y', eq x x' -> eq y y' -> ge x y -> ge x' y'.
+  Proof.
+    unfold ge, eq, S.Subset, S.Equal; intros. firstorder.
+  Qed.
 
   Definition  bot: t := S.empty.
   Lemma ge_bot: forall x, ge x bot.
@@ -589,15 +336,16 @@
   Qed.
 
   Definition lub: t -> t -> t := S.union.
-
-  Lemma ge_lub_left: forall x y, ge (lub x y) x.
+  Lemma lub_commut: forall x y, eq (lub x y) (lub y x).
   Proof.
-    unfold lub, ge, S.Subset; intros. apply S.union_2; auto. 
+    unfold lub, eq, S.Equal; intros. split; intro.
+    destruct (S.union_1 H). apply S.union_3; auto. apply S.union_2; auto.
+    destruct (S.union_1 H). apply S.union_3; auto. apply S.union_2; auto.
   Qed.
 
-  Lemma ge_lub_right: forall x y, ge (lub x y) y.
+  Lemma ge_lub_left: forall x y, ge (lub x y) x.
   Proof.
-    unfold lub, ge, S.Subset; intros. apply S.union_3; auto. 
+    unfold lub, ge, S.Subset; intros. apply S.union_2; auto.
   Qed.
 
 End LFSet.
@@ -607,16 +355,16 @@
 (** Given a type with decidable equality [X], the following functor
   returns a semi-lattice structure over [X.t] complemented with
   a top and a bottom element.  The ordering is the flat ordering
-  [Bot < Inj x < Top]. *) 
+  [Bot < Inj x < Top]. *)
 
 Module LFlat(X: EQUALITY_TYPE) <: SEMILATTICE_WITH_TOP.
 
-Inductive t' : Type :=
-  | Bot: t'
-  | Inj: X.t -> t'
-  | Top: t'.
+Inductive t_ : Type :=
+  | Bot: t_
+  | Inj: X.t -> t_
+  | Top: t_.
 
-Definition t : Type := t'.
+Definition t : Type := t_.
 
 Definition eq (x y: t) := (x = y).
 Definition eq_refl: forall x, eq x x := (@refl_equal t).
@@ -656,6 +404,11 @@
   transitivity t1; auto.
 Qed.
 
+Lemma ge_compat: forall x x' y y', eq x x' -> eq y y' -> ge x y -> ge x' y'.
+Proof.
+  unfold eq; intros; congruence.
+Qed.
+
 Definition bot: t := Bot.
 
 Lemma ge_bot: forall x, ge x bot.
@@ -679,20 +432,20 @@
   | Inj a, Inj b => if X.eq a b then Inj a else Top
   end.
 
-Lemma ge_lub_left: forall x y, ge (lub x y) x.
+Lemma lub_commut: forall x y, eq (lub x y) (lub y x).
 Proof.
-  destruct x; destruct y; simpl; auto.
-  case (X.eq t0 t1); simpl; auto.
+  unfold eq; destruct x; destruct y; simpl; auto.
+  case (X.eq t0 t1); case (X.eq t1 t0); intros; congruence.
 Qed.
 
-Lemma ge_lub_right: forall x y, ge (lub x y) y.
+Lemma ge_lub_left: forall x y, ge (lub x y) x.
 Proof.
   destruct x; destruct y; simpl; auto.
   case (X.eq t0 t1); simpl; auto.
 Qed.
 
 End LFlat.
-  
+
 (** * Boolean semi-lattice *)
 
 (** This semi-lattice has only two elements, [bot] and [top], trivially
@@ -720,6 +473,11 @@
 Lemma ge_trans: forall x y z, ge x y -> ge y z -> ge x z.
 Proof. unfold ge; intuition congruence. Qed.
 
+Lemma ge_compat: forall x x' y y', eq x x' -> eq y y' -> ge x y -> ge x' y'.
+Proof.
+  unfold eq; intros; congruence.
+Qed.
+
 Definition bot := false.
 
 Lemma ge_bot: forall x, ge x bot.
@@ -732,10 +490,345 @@
 
 Definition lub (x y: t) := x || y.
 
+Lemma lub_commut: forall x y, eq (lub x y) (lub y x).
+Proof. intros; unfold eq, lub. apply orb_comm. Qed.
+
 Lemma ge_lub_left: forall x y, ge (lub x y) x.
 Proof. destruct x; destruct y; compute; tauto. Qed.
 
-Lemma ge_lub_right: forall x y, ge (lub x y) y.
-Proof. destruct x; destruct y; compute; tauto. Qed.
+Lemma ge_lub: forall x y1 y2, ge y1 y2 -> ge (lub x y1) (lub x y2).
+Proof. unfold ge. intros. destruct x, y1, y2; tauto. Qed.
 
 End LBoolean.
+(** * Domination analysis *)
+
+(** The type [Dominators] of compile-time approximations of domination. *)
+
+(** We equip this type of approximations with a semi-lattice structure.
+  The ordering is inclusion between the sets of values denoted by
+  the approximations. *)
+
+Module Dominators <: SEMILATTICE_WITH_TOP.
+
+  Require Import ListSet.
+  Export AtomSet.
+
+  Definition t := option (set atom).
+
+  Definition eq (x y: t) :=
+    match x, y with
+    | Some cx, Some cy => set_eq cx cy
+    | None, None => True
+    | _, _ => False
+    end.
+
+  Definition eq_refl: forall x, eq x x.
+  Proof.
+    unfold eq. intro x. destruct x; auto with atomset.
+  Qed.
+
+  Definition eq_sym: forall x y, eq x y -> eq y x.
+  Proof.
+    unfold eq. intros x y J. destruct x; destruct y; auto with atomset.
+  Qed.
+
+  Definition eq_trans: forall x y z, eq x y -> eq y z -> eq x z.
+  Proof.
+    unfold eq. intros x y z J1 J2. 
+    destruct x; destruct y; destruct z; eauto with atomset. tauto.
+  Qed.
+
+  Lemma eq_dec: forall (x y: t), {eq x y} + {~ eq x y}.
+  Proof.
+    unfold eq. destruct x; destruct y; auto.
+    apply set_eq_dec. apply eq_atom_dec.
+  Qed.
+
+  Definition beq (x y: t) := if eq_dec x y then true else false.
+
+  Lemma beq_correct: forall x y, beq x y = true -> eq x y.
+  Proof.
+    unfold beq; intros.  destruct (eq_dec x y). auto. congruence.
+  Qed.
+
+  Definition sub (x y: t) :=
+    match x, y with
+    | Some cx, Some cy => incl cx cy
+    | _, None => True
+    | _, _ => False
+    end.
+
+  Definition top : t := Some (empty_set atom).
+
+  Definition bot : t := None.
+
+  Definition ge (x y: t) : Prop := sub x y.
+
+  Lemma ge_refl: forall x y, eq x y -> ge x y.
+  Proof.
+    unfold ge, eq. destruct x, y; simpl; auto. 
+    intro J. destruct J; auto.
+  Qed.
+
+  Lemma ge_trans: forall x y z, ge x y -> ge y z -> ge x z.
+  Proof.
+    unfold ge. 
+    destruct x, y, z; simpl; eauto 2 with datatypes v62.
+      tauto.
+  Qed.
+
+  Lemma ge_compat: forall x x' y y', eq x x' -> eq y y' -> ge x y -> ge x' y'.
+  Proof.
+    unfold ge, eq. 
+    destruct x, x', y, y'; simpl; try solve [eauto 2 with atomset | tauto].
+  Qed.
+
+  Lemma ge_bot: forall x, ge x bot.
+  Proof.
+    unfold ge, eq, sub. destruct x; simpl; auto with atomset.
+  Qed.
+
+  Lemma ge_top: forall x, ge top x.
+  Proof.
+    unfold ge, eq, sub. destruct x; simpl; auto with atomset.
+  Qed.
+
+  Definition lub (x y: t) : t :=
+    match x, y with
+    | Some cx, Some cy => Some (set_inter eq_atom_dec cx cy)
+    | None, _ => y
+    | _, None => x
+    end.
+
+  Lemma lub_commut: forall x y, eq (lub x y) (lub y x).
+  Proof.
+    unfold lub, eq. destruct x, y; auto with atomset.
+  Qed.
+
+  Lemma ge_lub_left: forall x y, ge (lub x y) x.
+  Proof.
+    unfold lub, ge, sub. destruct x, y; simpl; auto with datatypes v62.
+    intros a J.
+    apply set_inter_elim in J. destruct J. auto.
+  Qed.
+
+  Lemma ge_lub_right:
+    forall x y, ge (lub x y) y.
+  Proof.
+    intros.
+    apply ge_compat with (x:=lub y x)(y:=y).
+      apply lub_commut.
+      apply eq_refl.
+      apply ge_lub_left.
+  Qed.
+
+  Lemma lub_preserves_ge : forall x y, ge x y -> eq (lub x y) x.
+  Proof.
+    unfold lub, ge, eq. destruct x, y; simpl; auto with atomset.
+  Qed.
+
+  Lemma lub_compat : forall x y x' y',
+    ge x x' -> ge y y' -> ge (lub x y) (lub x' y').
+  Proof.
+    unfold lub, ge, eq. 
+    destruct x, y, x', y'; simpl; try solve [
+      tauto | eauto 2 with atomset | 
+      intros; eapply incl_tran; eauto; eauto 2 with atomset
+    ].
+  Qed.
+
+  Lemma lub_refl : forall x, eq x (lub x x).
+  Proof.
+    unfold eq, lub. destruct x; auto with atomset.
+  Qed.
+
+  Lemma ge_top_inv : forall x, ge x top -> eq x top.
+  Proof.
+    unfold ge, top. destruct x; simpl; auto.
+    intros J.
+    apply incl_empty_inv in J. subst. auto with atomset.
+  Qed.
+
+  Lemma ge_antisym : forall x y, ge x y -> ge y x -> eq x y.
+  Proof.
+    destruct x, y; simpl; auto.
+    intros J1 J2. split; auto.
+  Qed.
+
+  Lemma lub_compat' : forall x y1 y2, ge x y1 -> ge x y2 -> ge x (lub y1 y2).
+  Proof.
+    intros.
+    apply ge_trans with (y:=lub x x).
+      apply ge_refl. apply lub_refl.
+      apply lub_compat; auto.
+  Qed.
+
+  Lemma ge_lub_left' : forall a p1 p2, ge p2 p1 -> ge (lub p2 a) p1.
+  Proof.
+    intros.
+    apply ge_trans with (y:=p2); auto.
+    apply ge_lub_left.
+  Qed.
+
+  Lemma ge_refl' : forall x, ge x x.
+  Proof.
+    intros. apply ge_refl. apply eq_refl.
+  Qed.
+
+  Definition add (x:t) (a:atom) : t :=
+    match x with
+    | Some cx => Some (a::cx)
+    | None => None
+    end.
+
+  Lemma add_mono: forall a x y, ge x y -> ge (add x a) (add y a).
+  Proof.
+    unfold ge, add, eq, sub. destruct x, y; simpl; auto.
+    intros.
+    intros x J. simpl in J.
+    destruct J as [J | J]; subst; simpl; auto.
+  Qed.
+
+  Definition member (a:atom) (x: t) :=
+    match x with
+    | Some cx => In a cx
+    | None => True
+    end.
+
+  Lemma add_member1: forall a x,
+    member a (add x a).
+  Proof.
+    unfold member, add. destruct x; simpl; auto.
+  Qed.
+
+  Lemma add_member2: forall a b x,
+    member a x -> member a (add x b).
+  Proof.
+    unfold member, add. destruct x; simpl; auto.
+  Qed.
+
+  Lemma member_eq : forall a x1 x2, eq x1 x2 -> member a x2 -> member a x1.
+  Proof.
+    unfold member, eq. destruct x1, x2; simpl; try solve [auto | tauto].
+    intros H H1. destruct H. auto.
+  Qed.
+
+  Lemma member_lub : forall a x1 x2,
+    member a x2 -> member a x1 -> member a (lub x1 x2).
+  Proof.
+    unfold member, lub. destruct x1, x2; simpl; auto.
+    intros. apply set_inter_intro; auto.
+  Qed.
+
+  Lemma ge_elim : forall a x y, ge x y -> member a x -> member a y.
+  Proof.
+    unfold member, ge. destruct x, y; simpl; try solve [auto | tauto].
+  Qed.
+
+  Lemma member_dec: forall a x, member a x \/ ~ member a x.
+  Proof.
+    unfold member. destruct x; simpl; auto.
+    destruct (in_dec eq_atom_dec a s); auto.
+  Qed.
+
+  Lemma lub_compat_eq : forall x y x' y',
+    eq x x' -> eq y y' -> eq (lub x y) (lub x' y').
+  Proof.
+    unfold lub, eq. destruct x, y, x', y'; simpl; try solve [auto | tauto].
+    intros J1 J2. auto with atomset.
+  Qed.
+
+  Lemma add_bot: forall a, eq (add bot a) bot.
+  Proof.
+    unfold eq, add, bot. intros. auto.
+  Qed.
+
+  Lemma add_eq: forall a x y, eq x y -> eq (add x a) (add y a).
+  Proof.
+    unfold eq, add. destruct x, y; simpl; auto.
+    intros [H1 H2].
+    split; intros x J; simpl in *; destruct J; subst; auto.
+  Qed.
+
+  Lemma lub_intro: forall a x y, member a x -> member a y -> member a (lub x y).
+  Proof.
+    unfold member, lub. destruct x, y; simpl; auto.
+    intros. apply set_inter_intro; auto.
+  Qed.
+
+  Definition lubs (pds: list t) : t :=
+    fold_left (fun acc => fun p => lub acc p) pds bot.
+
+  Lemma lubs_spec1: forall pds p2 p1,
+    ge p2 p1 -> ge (fold_left (fun acc => fun p => lub acc p) pds p2) p1.
+  Proof.
+    induction pds; simpl; intros; auto.
+      apply IHpds. apply ge_lub_left'; auto.
+  Qed.
+
+  Lemma lubs_spec2_aux: forall pds p2 p1, In p1 pds ->
+    ge (fold_left (fun acc => fun p => lub acc p) pds p2) p1.
+  Proof.
+    induction pds; simpl; intros.
+      inversion H.
+      destruct H as [H | H]; subst.
+        apply lubs_spec1.
+          apply ge_lub_right; auto.
+        apply IHpds; auto.
+  Qed.
+
+  Lemma lubs_spec2: forall pds p1, In p1 pds ->
+    ge (lubs pds) p1.
+  Proof.
+    unfold lubs. intros. apply lubs_spec2_aux; auto.
+  Qed.
+
+  Lemma lubs_spec3_aux: forall p0 pds p2,
+    ge p0 p2 ->
+    (forall p, In p pds -> ge p0 p) ->
+    ge p0 (fold_left (fun acc => fun p => lub acc p) pds p2).
+  Proof.
+    induction pds; simpl; intros; auto.
+      apply IHpds; auto.
+        apply lub_compat'; auto.
+  Qed.
+
+  Lemma lubs_spec3: forall pds p1,
+    (forall p, In p pds -> ge p1 p) -> ge p1 (lubs pds).
+  Proof.
+    unfold lubs. intros. apply lubs_spec3_aux; auto.
+      apply ge_bot.
+  Qed.
+
+  Definition gt (x y: t) : Prop := 
+  match x, y with
+  | Some _, None => True
+  | Some x', Some y' => incl x' y' /\ exists a, In a y' /\ ~ In a x'
+  | _, _ => False
+  end.
+
+  Lemma beq_correct': forall x y, beq x y = false -> ~ eq x y.
+  Proof.
+    unfold beq; intros. 
+    destruct (eq_dec x y). 
+      congruence.
+      auto. 
+  Qed.
+
+  Lemma ge__gt_or_eq: forall x y (Hge: ge x y), eq x y \/ gt x y.
+  Proof.
+    unfold ge, gt.
+    intros.
+    destruct x as [x|].
+      destruct y as [y|]; auto.
+        simpl in Hge. assert (J:=Hge). 
+        apply incl__eq_or_exact in J; auto.
+        destruct J as [EQ | [e [Hin Hnotin]]]; subst; auto.
+          right. split; eauto.
+      left.
+      destruct y as [y|]; try tauto.
+  Qed.
+
+End Dominators.
+
+
diff -ruN lib/compcert-1.9/Maps.v lib.patched/compcert-1.9/Maps.v
--- lib/compcert-1.9/Maps.v	2014-08-30 20:09:04.806089049 -0400
+++ lib.patched/compcert-1.9/Maps.v	2014-08-30 00:29:06.159588829 -0400
@@ -33,17 +33,206 @@
 *)
 
 Require Import Coqlib.
+Require Import Metatheory.
+
+Lemma in_fst_map__in_dom: forall A x (E : list (atom * A))
+  (Hin: In x (List.map fst E)), x `in` dom E.
+Proof.
+  induction E as [|[]]; simpl; intros.
+    tauto.
+    destruct Hin as [Hin | Hin]; subst; auto.
+Qed.
+
+Lemma uniq__list_norepet: forall A (l1:list (atom*A)) (Huniq: uniq l1), 
+  list_norepet (List.map fst l1).
+Proof.
+  induction 1; simpl; intros.
+    constructor.
+    constructor; auto using in_fst_map__in_dom.
+Qed.
+
+(*************************************************)
+
+Module InsertSort. Section InsertSort.
+
+Variable atom:Type.
+Variable atom_lt: atom -> atom -> bool.
+Hypothesis eq_atom_dec: forall (x y:atom), {x = y} + {x <> y}.
+Hypothesis tom_lt_irrefl: forall a0, atom_lt a0 a0 = false.
+Hypothesis atom_lt_trans: forall a1 a2 a3, 
+  atom_lt a1 a2 = true -> atom_lt a2 a3 = true -> atom_lt a1 a3 = true.
+Hypothesis atom_lt_gt: forall a1 a2, 
+  atom_lt a1 a2 = false -> a1 <> a2 -> atom_lt a2 a1 = true.
+
+Fixpoint insert_sort_aux (l0:atom)(prefix suffix:list atom) 
+  : list atom :=
+match suffix with
+| nil => List.rev (l0 :: prefix)
+| l1::suffix' =>
+    if atom_lt l0 l1 then (List.rev (l0 :: prefix) ++ suffix)
+    else if eq_atom_dec l0 l1 then (List.rev prefix) ++ suffix
+    else insert_sort_aux l0 (l1::prefix) suffix'
+end.
+
+Definition insert_sort (l0:atom)(ls2:list atom) : list atom :=
+insert_sort_aux l0 nil ls2.
+
+Lemma insert_sort_aux_safe: forall l0 suffix l1 prefix,
+  (In l0 (prefix ++ suffix) \/ l0 = l1) <->
+  In l0 (insert_sort_aux l1 prefix suffix).
+Proof.
+  induction suffix; simpl; intros.
+  (*1*)
+    split; intro J.
+      apply in_or_app.
+      destruct J as [J | J]; subst.
+        left. simpl_env in J. apply in_rev in J; auto.
+        right. simpl. auto.
+
+      apply in_app_or in J. simpl in J. simpl_env.
+      destruct J as [J | [J | J]]; subst; auto.
+        left. apply in_rev in J; auto.
+        tauto.
+  (*2*)
+    simpl_env. simpl.
+    split; intro J.
+    (*2.1*)
+      destruct (atom_lt l1 a).
+      (*2.1.1*)
+        destruct J as [J | J]; subst.
+          apply in_app_or in J. simpl in J.
+          apply in_or_app. simpl.
+          destruct J as [J | [J | J]]; subst; auto.
+            apply in_rev in J; auto.
+
+          apply in_or_app. simpl. auto.
+
+      (*2.1.2*)
+        destruct (eq_atom_dec l1 a); subst.
+        (*2.1.2.1*)
+          destruct J as [J | J]; subst.
+            apply in_or_app. 
+            apply in_app_or in J. simpl in J. 
+            destruct J as [J | [J | J]]; subst; simpl; auto.
+              left. apply in_rev in J; auto.
+  
+            apply in_or_app. simpl. auto.
+
+        (*2.1.2.2*)
+          apply IHsuffix.
+            destruct J as [J | J]; auto.
+            left. simpl.
+            apply in_app_or in J. simpl in J.
+            destruct J as [J | [J | J]]; subst; auto.
+              right. apply in_or_app; auto.
+              right. apply in_or_app; auto.
+
+    (*2.2*)
+      destruct (atom_lt l1 a).
+      (*2.2.1*)
+        apply in_app_or in J. simpl in J.
+        destruct J as [J | [J | [J | J]]]; subst; auto.
+          left. apply in_or_app. simpl.
+          apply in_rev in J; auto.
+
+          left. apply in_or_app. simpl. auto.
+          left. apply in_or_app. simpl. auto.
+      (*2.2.2*)
+      destruct (eq_atom_dec l1 a); subst.
+        (*2.2.2.1*)
+          left. 
+          apply in_or_app. simpl. 
+          apply in_app_or in J. simpl in J. 
+          destruct J as [J | [J | J]]; subst; simpl; auto.
+            apply in_rev in J; auto.
+        (*2.2.2.2*)
+        apply IHsuffix in J.
+          destruct J as [J | J]; auto.
+          left. apply in_or_app. simpl.
+          apply in_app_or in J. simpl in J.
+          destruct J as [[J | J] | J]; subst; auto.
+Qed.
+
+Lemma insert_sort_safe: forall l0 l1 ls2,
+  (In l0 ls2 \/ l0 = l1) <-> In l0 (insert_sort l1 ls2).
+Proof.
+  intros.
+  unfold insert_sort.  
+  assert (J:=insert_sort_aux_safe l0 ls2 l1 nil).
+  simpl in J. auto.
+Qed.
+
+Definition atom_lt_prop (a1 a2:atom) : Prop := atom_lt a1 a2 = true.
+
+Lemma insert_sort_aux_sorted: forall l0 suffix prefix,
+  Sorted atom_lt_prop (List.rev prefix ++ suffix) ->
+  (forall l1 prefix', prefix = l1 :: prefix' -> atom_lt_prop l1 l0) ->
+  Sorted atom_lt_prop (insert_sort_aux l0 prefix suffix).
+Proof.
+  induction suffix; simpl; intros.
+  Case "1".
+    simpl_env in *.
+    apply sorted_append; auto.
+      intros.
+      apply H0 with (prefix':=rev l1'); auto.
+        rewrite <- rev_involutive at 1.
+        rewrite H1. rewrite rev_unit. auto.
+  Case "2".
+    remember (atom_lt l0 a) as R.
+    destruct R.
+    SCase "2.1".
+      simpl_env. simpl.
+      apply sorted_insert; auto.
+        intros.
+        apply H0 with (prefix':=rev l1'); auto.
+          rewrite <- rev_involutive at 1.
+          rewrite H1. rewrite rev_unit. auto.
+
+        intros.
+        inv H1.
+        unfold atom_lt_prop. auto.
+
+    SCase "2.2".
+      destruct (eq_atom_dec l0 a); subst; auto.
+      apply IHsuffix.
+        simpl. simpl_env. simpl. auto.
+
+        intros. inv H1.
+        apply atom_lt_gt; auto.
+Qed.
+
+Lemma insert_sort_sorted: forall l0 ls1,
+  Sorted atom_lt_prop ls1 ->
+  Sorted atom_lt_prop (insert_sort l0 ls1).
+Proof.
+  unfold insert_sort.
+  intros.
+  apply insert_sort_aux_sorted; auto.
+    congruence.
+Qed.
+
+Lemma insert_sort_strongly_sorted: forall l0 ls1
+  (Hsort: StronglySorted atom_lt_prop ls1),
+  StronglySorted atom_lt_prop (insert_sort l0 ls1).
+Proof.
+  intros.
+  apply StronglySorted_Sorted in Hsort.
+  apply insert_sort_sorted with (l0:=l0) in Hsort.
+  apply Sorted_StronglySorted; auto.
+Qed.
+
+End InsertSort. End InsertSort.
+
+(*************************************************)
 
 Set Implicit Arguments.
 
 (** * The abstract signatures of trees *)
 
 Module Type TREE.
-  Variable elt: Type.
+  Variable elt: Set.
   Variable elt_eq: forall (a b: elt), {a = b} + {a <> b}.
   Variable t: Type -> Type.
-  Variable eq: forall (A: Type), (forall (x y: A), {x=y} + {x<>y}) ->
-                forall (a b: t A), {a = b} + {a <> b}.
   Variable empty: forall (A: Type), t A.
   Variable get: forall (A: Type), elt -> t A -> option A.
   Variable set: forall (A: Type), elt -> A -> t A -> t A.
@@ -61,9 +250,6 @@
   Hypothesis gsspec:
     forall (A: Type) (i j: elt) (x: A) (m: t A),
     get i (set j x m) = if elt_eq i j then Some x else get i m.
-  Hypothesis gsident:
-    forall (A: Type) (i: elt) (m: t A) (v: A),
-    get i m = Some v -> set i v m = m.
   (* We could implement the following, but it's not needed for the moment.
     Hypothesis grident:
       forall (A: Type) (i: elt) (m: t A) (v: A),
@@ -78,6 +264,43 @@
     forall (A: Type) (i j: elt) (m: t A),
     get i (remove j m) = if elt_eq i j then None else get i m.
 
+  (** Applying a function to all data of a tree. *)
+  Variable map:
+    forall (A B: Type), (elt -> A -> B) -> t A -> t B.
+  Hypothesis gmap:
+    forall (A B: Type) (f: elt -> A -> B) (i: elt) (m: t A),
+    get i (map f m) = option_map (f i) (get i m).
+
+  (** Enumerating the bindings of a tree. *)
+  Variable elements:
+    forall (A: Type), t A -> list (elt * A).
+  Hypothesis elements_correct:
+    forall (A: Type) (m: t A) (i: elt) (v: A),
+    get i m = Some v -> In (i, v) (elements m).
+  Hypothesis elements_complete:
+    forall (A: Type) (m: t A) (i: elt) (v: A),
+    In (i, v) (elements m) -> get i m = Some v.
+  Hypothesis elements_keys_norepet:
+    forall (A: Type) (m: t A),
+    list_norepet (List.map (@fst elt A) (elements m)).
+
+  (** Folding a function over all bindings of a tree. *)
+  Variable fold:
+    forall (A B: Type), (B -> elt -> A -> B) -> t A -> B -> B.
+  Hypothesis fold_spec:
+    forall (A B: Type) (f: B -> elt -> A -> B) (v: B) (m: t A),
+    fold f m v =
+    List.fold_left (fun a p => f a (fst p) (snd p)) (elements m) v.
+End TREE.
+
+Module Type TREE'.
+  Include Type TREE.
+  Variable eq: forall (A: Type), (forall (x y: A), {x=y} + {x<>y}) ->
+                forall (a b: t A), {a = b} + {a <> b}.
+  Hypothesis gsident:
+    forall (A: Type) (i: elt) (m: t A) (v: A),
+    get i m = Some v -> set i v m = m.
+
   (** Extensional equality between trees. *)
   Variable beq: forall (A: Type), (A -> A -> bool) -> t A -> t A -> bool.
   Hypothesis beq_correct:
@@ -91,20 +314,6 @@
     | _, _ => False
     end.
 
-  (** Applying a function to all data of a tree. *)
-  Variable map:
-    forall (A B: Type), (elt -> A -> B) -> t A -> t B.
-  Hypothesis gmap:
-    forall (A B: Type) (f: elt -> A -> B) (i: elt) (m: t A),
-    get i (map f m) = option_map (f i) (get i m).
-
-  (** Same as [map], but the function does not receive the [elt] argument. *)
-  Variable map1:
-    forall (A B: Type), (A -> B) -> t A -> t B.
-  Hypothesis gmap1:
-    forall (A B: Type) (f: A -> B) (i: elt) (m: t A),
-    get i (map1 f m) = option_map f (get i m).
-
   (** Applying a function pairwise to all data of two trees. *)
   Variable combine:
     forall (A: Type), (option A -> option A -> option A) -> t A -> t A -> t A.
@@ -113,24 +322,15 @@
     f None None = None ->
     forall (m1 m2: t A) (i: elt),
     get i (combine f m1 m2) = f (get i m1) (get i m2).
+End TREE'.
+
+Module Type SORTED_TREE.
+  Include Type TREE'.
   Hypothesis combine_commut:
     forall (A: Type) (f g: option A -> option A -> option A),
     (forall (i j: option A), f i j = g j i) ->
     forall (m1 m2: t A),
     combine f m1 m2 = combine g m2 m1.
-
-  (** Enumerating the bindings of a tree. *)
-  Variable elements:
-    forall (A: Type), t A -> list (elt * A).
-  Hypothesis elements_correct:
-    forall (A: Type) (m: t A) (i: elt) (v: A),
-    get i m = Some v -> In (i, v) (elements m).
-  Hypothesis elements_complete:
-    forall (A: Type) (m: t A) (i: elt) (v: A),
-    In (i, v) (elements m) -> get i m = Some v.
-  Hypothesis elements_keys_norepet:
-    forall (A: Type) (m: t A), 
-    list_norepet (List.map (@fst elt A) (elements m)).
   Hypothesis elements_canonical_order:
     forall (A B: Type) (R: A -> B -> Prop) (m: t A) (n: t B),
     (forall i x, get i m = Some x -> exists y, get i n = Some y /\ R x y) ->
@@ -142,15 +342,7 @@
     forall (A: Type) (m n: t A),
     (forall i, get i m = get i n) ->
     elements m = elements n.
-
-  (** Folding a function over all bindings of a tree. *)
-  Variable fold:
-    forall (A B: Type), (B -> elt -> A -> B) -> t A -> B -> B.
-  Hypothesis fold_spec:
-    forall (A B: Type) (f: B -> elt -> A -> B) (v: B) (m: t A),
-    fold f m v =
-    List.fold_left (fun a p => f a (fst p) (snd p)) (elements m) v.
-End TREE.
+End SORTED_TREE.
 
 (** * The abstract signatures of maps *)
 
@@ -181,7 +373,7 @@
 
 (** * An implementation of trees over type [positive] *)
 
-Module PTree <: TREE.
+Module PTree <: SORTED_TREE.
   Definition elt := positive.
   Definition elt_eq := peq.
 
@@ -386,9 +578,9 @@
     Lemma bempty_correct:
       forall m, bempty m = true -> forall x, get x m = None.
     Proof.
-      induction m; simpl; intros. 
+      induction m; simpl; intros.
       change (@Leaf A) with (empty A). apply gempty.
-      destruct o. congruence. destruct (andb_prop _ _ H). 
+      destruct o. congruence. destruct (andb_prop _ _ H).
       destruct x; simpl; auto.
     Qed.
 
@@ -409,19 +601,19 @@
       forall m1 m2, beq m1 m2 = true -> exteq m1 m2.
     Proof.
       induction m1; destruct m2; simpl.
-      intros; red; intros. change (@Leaf A) with (empty A). 
+      intros; red; intros. change (@Leaf A) with (empty A).
       repeat rewrite gempty. auto.
-      destruct o; intro. congruence. 
+      destruct o; intro. congruence.
       red; intros. change (@Leaf A) with (empty A). rewrite gempty.
-      rewrite bempty_correct. auto. assumption. 
-      destruct o; intro. congruence. 
+      rewrite bempty_correct. auto. assumption.
+      destruct o; intro. congruence.
       red; intros. change (@Leaf A) with (empty A). rewrite gempty.
-      rewrite bempty_correct. auto. assumption. 
+      rewrite bempty_correct. auto. assumption.
       destruct o; destruct o0; simpl; intro; try congruence.
-      destruct (andb_prop _ _ H). destruct (andb_prop _ _ H0). 
+      destruct (andb_prop _ _ H). destruct (andb_prop _ _ H0).
       red; intros. destruct x; simpl.
-      apply IHm1_2; auto. apply IHm1_1; auto. 
-      apply beqA_correct; auto. 
+      apply IHm1_2; auto. apply IHm1_1; auto.
+      apply beqA_correct; auto.
       destruct (andb_prop _ _ H).
       red; intros. destruct x; simpl.
       apply IHm1_2; auto. apply IHm1_1; auto.
@@ -499,19 +691,6 @@
     rewrite append_neutral_l; auto.
   Qed.
 
-  Fixpoint map1 (A B: Type) (f: A -> B) (m: t A) {struct m} : t B :=
-    match m with
-    | Leaf => Leaf
-    | Node l o r => Node (map1 f l) (option_map f o) (map1 f r)
-    end.
-
-  Theorem gmap1:
-    forall (A B: Type) (f: A -> B) (i: elt) (m: t A),
-    get i (map1 f m) = option_map f (get i m).
-  Proof.
-    induction i; intros; destruct m; simpl; auto.
-  Qed.
-
   Definition Node' (A: Type) (l: t A) (x: option A) (r: t A): t A :=
     match l, x, r with
     | Leaf, None, Leaf => Leaf
@@ -522,7 +701,7 @@
     forall (A: Type) (l r: t A) (x: option A) (i: positive),
     get i (Node' l x r) = get i (Node l x r).
   Proof.
-    intros. unfold Node'. 
+    intros. unfold Node'.
     destruct l; destruct x; destruct r; auto.
     destruct i; simpl; auto; rewrite gleaf; auto.
   Qed.
@@ -580,7 +759,7 @@
     induction m1; intros; simpl.
     rewrite gleaf. apply xgcombine_r.
     destruct m2; simpl.
-    rewrite gleaf. rewrite <- xgcombine_l. auto. 
+    rewrite gleaf. rewrite <- xgcombine_l. auto.
     repeat rewrite gnode'. destruct i; simpl; auto.
   Qed.
 
@@ -613,7 +792,7 @@
       auto.
      rewrite IHm1_1.
      rewrite IHm1_2.
-     auto. 
+     auto.
   Qed.
 
     Fixpoint xelements (A : Type) (m : t A) (i : positive) {struct m}
@@ -865,7 +1044,7 @@
     In k (xkeys m i) ->
     exists j, k = append i j.
   Proof.
-    unfold xkeys; intros. 
+    unfold xkeys; intros.
     elim (list_in_map_inv _ _ _ H). intros [k1 v1] [EQ IN].
     simpl in EQ; subst k1. apply in_xelements with A m v1. auto.
   Qed.
@@ -878,7 +1057,7 @@
   Proof.
     intros. apply list_norepet_append_commut. simpl; constructor.
     red; intros. elim (in_app_or _ _ _ H4); intro; tauto.
-    apply list_norepet_append; auto. 
+    apply list_norepet_append; auto.
     apply list_disjoint_sym; auto.
   Qed.
 
@@ -898,17 +1077,17 @@
     induction m; unfold xkeys; simpl; fold xkeys; intros.
     constructor.
     assert (list_disjoint (xkeys m1 (append i 2)) (xkeys m2 (append i 3))).
-      red; intros; red; intro. subst y. 
+      red; intros; red; intro. subst y.
       elim (in_xkeys _ _ _ H); intros j1 EQ1.
       elim (in_xkeys _ _ _ H0); intros j2 EQ2.
-      rewrite EQ1 in EQ2. 
-      rewrite <- append_assoc_0 in EQ2. 
-      rewrite <- append_assoc_1 in EQ2. 
+      rewrite EQ1 in EQ2.
+      rewrite <- append_assoc_0 in EQ2.
+      rewrite <- append_assoc_1 in EQ2.
       generalize (append_injective _ _ _ EQ2). congruence.
     assert (forall (m: t A) j,
             j = 2%positive \/ j = 3%positive ->
             ~In i (xkeys m (append i j))).
-      intros; red; intros. 
+      intros; red; intros.
       elim (in_xkeys _ _ _ H1); intros k EQ.
       assert (EQ1: append i xH = append (append i j) k).
         rewrite append_neutral_r. auto.
@@ -921,12 +1100,12 @@
       with (xkeys m1 (append i 2));
     change (List.map (@fst positive A) (xelements m2 (append i 3)))
       with (xkeys m2 (append i 3)).
-    apply list_append_cons_norepet; auto. 
+    apply list_append_cons_norepet; auto.
     apply list_norepet_append; auto.
   Qed.
 
   Theorem elements_keys_norepet:
-    forall (A: Type) (m: t A), 
+    forall (A: Type) (m: t A),
     list_norepet (List.map (@fst elt A) (elements m)).
   Proof.
     intros. change (list_norepet (xkeys m 1)). apply xelements_keys_norepet.
@@ -967,16 +1146,16 @@
     apply IHm2.
     intros. exploit (H (xI i)). simpl; eauto. rewrite gleaf. intros [y [P Q]]. congruence.
     intros. rewrite gleaf in H1. congruence.
-    exploit (IHm1 n1 (append j 2)). 
+    exploit (IHm1 n1 (append j 2)).
     intros. exploit (H (xO i)). simpl; eauto. simpl. auto.
     intros. exploit (H0 (xO i)). simpl; eauto. simpl; auto.
     intro REC1.
-    exploit (IHm2 n2 (append j 3)). 
+    exploit (IHm2 n2 (append j 3)).
     intros. exploit (H (xI i)). simpl; eauto. simpl. auto.
     intros. exploit (H0 (xI i)). simpl; eauto. simpl; auto.
     intro REC2.
     destruct o; destruct o0.
-    apply list_forall2_app; auto. constructor; auto. 
+    apply list_forall2_app; auto. constructor; auto.
     simpl; split; auto. exploit (H xH). simpl; eauto. simpl. intros [y [P Q]]. congruence.
     exploit (H xH). simpl; eauto. simpl. intros [y [P Q]]; congruence.
     exploit (H0 xH). simpl; eauto. simpl. intros [x [P Q]]; congruence.
@@ -990,14 +1169,19 @@
     (forall i, get i m = get i n) ->
     elements m = elements n.
   Proof.
-    intros. 
-    exploit (elements_canonical_order (fun (x y: A) => x = y) m n). 
+    intros.
+    exploit (elements_canonical_order (fun (x y: A) => x = y) m n).
     intros. rewrite H in H0. exists x; auto.
     intros. rewrite <- H in H0. exists y; auto.
     induction 1. auto. destruct a1 as [a2 a3]; destruct b1 as [b2 b3]; simpl in *.
     destruct H0. congruence.
   Qed.
 
+(*
+  Definition fold (A B : Type) (f: B -> positive -> A -> B) (tr: t A) (v: B) :=
+     List.fold_left (fun a p => f a (fst p) (snd p)) (elements tr) v.
+*)
+
   Fixpoint xfold (A B: Type) (f: B -> positive -> A -> B)
                  (i: positive) (m: t A) (v: B) {struct m} : B :=
     match m with
@@ -1024,8 +1208,8 @@
     induction m; intros.
     simpl. auto.
     simpl. destruct o.
-    rewrite fold_left_app. simpl. 
-    rewrite IHm1. apply IHm2. 
+    rewrite fold_left_app. simpl.
+    rewrite IHm1. apply IHm2.
     rewrite fold_left_app. simpl.
     rewrite IHm1. apply IHm2.
   Qed.
@@ -1035,153 +1219,1035 @@
     fold f m v =
     List.fold_left (fun a p => f a (fst p) (snd p)) (elements m) v.
   Proof.
-    intros. unfold fold, elements. apply xfold_xelements. 
+    intros. unfold fold, elements. apply xfold_xelements.
   Qed.
 
 End PTree.
 
-(** * An implementation of maps over type [positive] *)
+(** * An implementation of trees over type [atom] using list *)
 
-Module PMap <: MAP.
-  Definition elt := positive.
-  Definition elt_eq := peq.
+Require Import alist.
 
-  Definition t (A : Type) : Type := (A * PTree.t A)%type.
+Module ATree' <: TREE'.
+  Definition elt := atom.
+  Definition elt_eq := eq_atom_dec.
 
-  Definition eq: forall (A: Type), (forall (x y: A), {x=y} + {x<>y}) ->
-                 forall (a b: t A), {a = b} + {a <> b}.
+  Definition tree (A : Type) : Type := list (atom*A).
+
+  Definition t := tree.
+
+  Theorem eq: forall (A: Type), (forall (x y: A), {x=y} + {x<>y}) ->
+                forall (a b: t A), {a = b} + {a <> b}.
   Proof.
-    intros. 
-    generalize (PTree.eq X). intros. 
+    intros A eqA.
     decide equality.
+    destruct a0, p. decide equality.
   Qed.
 
-  Definition init (A : Type) (x : A) :=
-    (x, PTree.empty A).
+  Definition empty (A: Type) : t A := nil.
 
-  Definition get (A : Type) (i : positive) (m : t A) :=
-    match PTree.get i (snd m) with
-    | Some x => x
-    | None => fst m
-    end.
+  Definition get (A: Type) (i: atom) (m: t A) : option A :=
+    lookupAL _ m i.
 
-  Definition set (A : Type) (i : positive) (x : A) (m : t A) :=
-    (fst m, PTree.set i x (snd m)).
+  Definition set (A: Type) (i: atom) (v: A) (m: t A) : t A :=
+    updateAddAL _ m i v.
 
-  Theorem gi:
-    forall (A: Type) (i: positive) (x: A), get i (init x) = x.
-  Proof.
-    intros. unfold init. unfold get. simpl. rewrite PTree.gempty. auto.
-  Qed.
+  Definition remove (A: Type) (i: atom) (m: t A) : t A :=
+    deleteAL _ m i.
+
+  (** The ``good variables'' properties for trees, expressing
+    commutations between [get], [set] and [remove]. *)
+  Theorem gempty:
+    forall (A: Type) (i: elt), get i (empty A) = None.
+  Proof. auto. Qed.
 
   Theorem gss:
-    forall (A: Type) (i: positive) (x: A) (m: t A), get i (set i x m) = x.
-  Proof.
-    intros. unfold get. unfold set. simpl. rewrite PTree.gss. auto.
-  Qed.
+    forall (A: Type) (i: elt) (x: A) (m: t A), get i (set i x m) = Some x.
+  Proof. intros. apply lookupAL_updateAddAL_eq; auto. Qed.
 
   Theorem gso:
-    forall (A: Type) (i j: positive) (x: A) (m: t A),
+    forall (A: Type) (i j: elt) (x: A) (m: t A),
     i <> j -> get i (set j x m) = get i m.
   Proof.
-    intros. unfold get. unfold set. simpl. rewrite PTree.gso; auto.
+    intros. unfold get, set.
+    rewrite <- lookupAL_updateAddAL_neq; auto.
   Qed.
 
   Theorem gsspec:
-    forall (A: Type) (i j: positive) (x: A) (m: t A),
-    get i (set j x m) = if peq i j then x else get i m.
+    forall (A: Type) (i j: elt) (x: A) (m: t A),
+    get i (set j x m) = if elt_eq i j then Some x else get i m.
   Proof.
-    intros. destruct (peq i j).
-     rewrite e. apply gss. auto.
-     apply gso. auto.
+    intros.
+    destruct (elt_eq i j); [ rewrite e; apply gss | apply gso; auto ].
   Qed.
 
   Theorem gsident:
-    forall (A: Type) (i j: positive) (m: t A),
-    get j (set i (get i m) m) = get j m.
+    forall (A: Type) (i: elt) (m: t A) (v: A),
+    get i m = Some v -> set i v m = m.
+  Proof. intros. apply lookupAL_updateAddAL_ident; auto. Qed.
+
+  Theorem grs:
+    forall (A: Type) (i: elt) (m: t A), get i (remove i m) = None.
+  Proof. intros. apply lookupAL_deleteAL_eq; auto. Qed.
+
+  Theorem gro:
+    forall (A: Type) (i j: elt) (m: t A),
+    i <> j -> get i (remove j m) = get i m.
+  Proof. intros. apply lookupAL_deleteAL_neq; auto. Qed.
+
+  Theorem grspec:
+    forall (A: Type) (i j: elt) (m: t A),
+    get i (remove j m) = if elt_eq i j then None else get i m.
   Proof.
-    intros. destruct (peq i j).
-     rewrite e. rewrite gss. auto.
-     rewrite gso; auto.
+    intros. destruct (elt_eq i j). subst j. apply grs. apply gro; auto.
   Qed.
 
-  Definition map (A B : Type) (f : A -> B) (m : t A) : t B :=
-    (f (fst m), PTree.map1 f (snd m)).
+  (** Extensional equality between trees. *)
+  Fixpoint beq (A: Type) (cmp: A -> A -> bool) (m1 m2: t A): bool :=
+  match m1, m2 with
+  | nil, nil => true
+  | (id1,gv1)::m1', (id2,gv2)::m2' =>
+      if (elt_eq id1 id2) then cmp gv1 gv2 && beq cmp m1' m2' else false
+  | _, _ => false
+  end.
 
-  Theorem gmap:
-    forall (A B: Type) (f: A -> B) (i: positive) (m: t A),
-    get i (map f m) = f(get i m).
+  Theorem beq_correct:
+    forall (A: Type) (P: A -> A -> Prop) (cmp: A -> A -> bool),
+    (forall (x y: A), cmp x y = true -> P x y) ->
+    forall (t1 t2: t A), beq cmp t1 t2 = true ->
+    forall (x: elt),
+    match get x t1, get x t2 with
+    | None, None => True
+    | Some y1, Some y2 => P y1 y2
+    | _, _ => False
+    end.
   Proof.
-    intros. unfold map. unfold get. simpl. rewrite PTree.gmap1.
-    unfold option_map. destruct (PTree.get i (snd m)); auto.
+    induction t1; destruct t2; simpl; intros; auto.
+      congruence.
+      destruct a. congruence.
+      destruct a, p.
+      destruct (elt_eq a a1); subst.
+        apply andb_true_iff in H0. destruct H0 as [J1 J2].
+        destruct (@eq_dec atom (@EqDec_eq_of_EqDec atom EqDec_atom) x a1);
+          subst; auto.
+          apply IHt1; auto.
+        congruence.
   Qed.
 
-End PMap.
-
-(** * An implementation of maps over any type that injects into type [positive] *)
+  (** Applying a function to all data of a tree. *)
+  Fixpoint map (A B: Type) (f: elt -> A -> B) (m: t A) : t B :=
+  match m with
+  | nil => nil
+  | (id0, gv0) :: m' => (id0, (f id0 gv0)) :: map f m'
+  end.
 
-Module Type INDEXED_TYPE.
-  Variable t: Type.
-  Variable index: t -> positive.
-  Hypothesis index_inj: forall (x y: t), index x = index y -> x = y.
-  Variable eq: forall (x y: t), {x = y} + {x <> y}.
-End INDEXED_TYPE.
+  Theorem gmap:
+    forall (A B: Type) (f: elt -> A -> B) (i: elt) (m: t A),
+    get i (map f m) = option_map (f i) (get i m).
+  Proof.
+    induction m; simpl; intros; auto.
+     destruct a. simpl.
+     destruct (@eq_dec atom (@EqDec_eq_of_EqDec atom EqDec_atom) i a); subst;
+       auto.
+  Qed.
 
-Module IMap(X: INDEXED_TYPE).
+  (** Enumerating the bindings of a tree. *)
+  Fixpoint elements_aux (A: Type) (m acc: t A) : list (elt * A) := 
+  match m with
+  | nil => acc
+  | (k,v)::m' => 
+       let acc' := 
+         match lookupAL _ acc k with
+         | None => [(k,v)] ++ acc
+         | _ => acc
+         end in
+       elements_aux m' acc'
+  end.
+
+  Lemma elements_aux_uniq:
+    forall (A: Type) (m: t A) acc (Huniq: uniq acc), 
+    uniq (elements_aux m acc).
+  Proof.
+    induction m as [|[k1 v1]]; simpl; intros; auto.
+      apply IHm.
+        case_eq (lookupAL A acc k1); auto.
+          intros Hgeta. 
+          simpl_env.
+          constructor; eauto using lookupAL_None_notindom.
+  Qed.        
+
+  Lemma in_acc__in_elements_aux:
+    forall (A: Type) (i: elt) (v: A) (m: t A) acc (Huniq: uniq acc)
+    (Hget: get i acc = Some v), 
+    In (i, v) (elements_aux m acc).
+  Proof.
+    induction m as [|[k1 v1]]; simpl; intros.
+      auto using lookupAL_in.
+
+      apply IHm.
+        case_eq (lookupAL A acc k1); auto.
+          intros Hgeta. 
+          simpl_env.
+          constructor; eauto using lookupAL_None_notindom.
+
+        case_eq (lookupAL A acc k1); auto.
+          intros Hgeta. 
+          simpl. 
+          destruct_if; auto.
+            apply lookupAL_Some_indom in Hget.
+            apply lookupAL_None_notindom in Hgeta.
+            tauto.
+  Qed.        
+
+  Lemma elements_aux_correct:
+    forall (A: Type) (i: elt) (v: A) (m: t A) acc (Huniq: uniq acc)
+    (Hget: get i m = Some v), 
+    In (i, v) (elements_aux m acc) \/ i `in` dom acc.
+  Proof.
+    induction m as [|[k1 v1]]; simpl; intros.
+      congruence.
+
+      destruct (@eq_dec atom (@EqDec_eq_of_EqDec atom EqDec_atom) i k1); subst.
+      Case "1".
+        inv Hget.
+        case_eq (lookupAL A acc k1).
+        SCase "1.1".
+          intros a Hgeta.
+          right. 
+          apply lookupAL_Some_indom in Hgeta; auto.
+        SCase "1.2".
+          intros Hgeta. 
+          left.
+          apply in_acc__in_elements_aux; auto.
+          SSCase "1.2.1".
+            simpl_env. 
+            constructor; eauto using lookupAL_None_notindom.
+          SSCase "1.2.2".
+            simpl. destruct_if. congruence.
+      Case "2".
+        case_eq (lookupAL A acc k1).
+        SCase "2.1".
+          intros a Hgeta.
+          apply IHm; auto.
+        SCase "2.2".
+          intros Hgeta.
+          apply IHm with (acc:=(k1, v1) :: acc) in Hget; auto. 
+          SSCase "2.2.1".
+            destruct Hget as [Hget | Hget]; auto.
+              right. simpl in Hget. fsetdec.
+          SSCase "2.2.2".
+            simpl_env. 
+            constructor; eauto using lookupAL_None_notindom.
+  Qed.        
 
-  Definition elt := X.t.
-  Definition elt_eq := X.eq.
-  Definition t : Type -> Type := PMap.t.
-  Definition eq: forall (A: Type), (forall (x y: A), {x=y} + {x<>y}) ->
-                 forall (a b: t A), {a = b} + {a <> b} := PMap.eq.
-  Definition init (A: Type) (x: A) := PMap.init x.
-  Definition get (A: Type) (i: X.t) (m: t A) := PMap.get (X.index i) m.
-  Definition set (A: Type) (i: X.t) (v: A) (m: t A) := PMap.set (X.index i) v m.
-  Definition map (A B: Type) (f: A -> B) (m: t A) : t B := PMap.map f m.
+  Definition elements (A: Type) (m: t A) : list (elt * A) := 
+    elements_aux m nil.
 
-  Lemma gi:
-    forall (A: Type) (x: A) (i: X.t), get i (init x) = x.
+  Theorem elements_correct:
+    forall (A: Type) (m: t A) (i: elt) (v: A),
+    get i m = Some v -> In (i, v) (elements m).
   Proof.
-    intros. unfold get, init. apply PMap.gi. 
-  Qed.
-
-  Lemma gss:
-    forall (A: Type) (i: X.t) (x: A) (m: t A), get i (set i x m) = x.
+    intros.
+    unfold elements.
+    apply elements_aux_correct with (m:=m)(acc:=nil) in H; auto.
+    destruct H as [H | H]; auto.
+       fsetdec.
+  Qed.
+
+  Lemma elements_aux_complete:
+    forall (A: Type) (m: t A) (i: elt) (v: A) acc (Huniq: uniq acc)
+    (Hin: In (i, v) (elements_aux m acc)),
+    get i m = Some v \/ i `in` dom acc.
+  Proof.
+    induction m as [|[k1 v1]]; simpl; intros.
+    Case "base".
+      right. 
+      apply In_lookupAL in Hin; auto.
+      apply lookupAL_Some_indom in Hin; auto.
+    Case "ind".
+      destruct (@eq_dec atom (@EqDec_eq_of_EqDec atom EqDec_atom) i k1); subst.
+      SCase "1.1".
+        case_eq (lookupAL A acc k1).
+        SSCase "1.1.1".
+          intros a Hgeta.
+          rewrite Hgeta in Hin. 
+          right. 
+          eapply lookupAL_Some_indom; eauto.
+        SSCase "1.1.2".
+          intros Hgeta.         
+          rewrite Hgeta in Hin. 
+          assert (Hget: get k1 ((k1,v1)::acc) = Some v1).
+            simpl. 
+            destruct_if. 
+              congruence.
+          assert (uniq ((k1, v1) :: acc)) as Huniq'.
+            simpl_env. 
+            constructor; eauto using lookupAL_None_notindom.
+          apply in_acc__in_elements_aux with (m:=m) in Hget; auto.
+          apply In_lookupAL in Hin; auto using elements_aux_uniq.
+          apply In_lookupAL in Hget; auto using elements_aux_uniq.
+          rewrite Hin in Hget. auto.
+      SCase "1.2".
+        case_eq (lookupAL A acc k1).
+        SSCase "1.1.1".
+          intros a Hgeta.
+          rewrite Hgeta in Hin. auto.
+        SSCase "1.1.2".
+          intros Hgeta.         
+          rewrite Hgeta in Hin. 
+          apply IHm in Hin.
+          SSSCase "1.1.2.1".
+            destruct Hin as [Hin | Hin]; auto.
+              right. simpl in Hin. fsetdec.
+          SSSCase "1.1.2.2".
+            simpl_env. 
+            constructor; eauto using lookupAL_None_notindom.
+  Qed.
+
+  Lemma elements_complete:
+    forall (A: Type) (m: t A) (i: elt) (v: A)
+    (Hin: In (i, v) (elements m)), get i m = Some v.
   Proof.
-    intros. unfold get, set. apply PMap.gss.
+    unfold elements.
+    intros.
+    apply elements_aux_complete in Hin; auto.
+    destruct Hin as [Hin | Hin]; auto.
+       fsetdec.
   Qed.
 
-  Lemma gso:
-    forall (A: Type) (i j: X.t) (x: A) (m: t A),
-    i <> j -> get i (set j x m) = get i m.
+  Lemma elements_uniq:
+    forall (A: Type) (m: t A), uniq (elements m).
   Proof.
-    intros. unfold get, set. apply PMap.gso. 
-    red. intro. apply H. apply X.index_inj; auto. 
+    intros.
+    unfold elements.
+    apply elements_aux_uniq; auto.
   Qed.
 
-  Lemma gsspec:
-    forall (A: Type) (i j: X.t) (x: A) (m: t A),
-    get i (set j x m) = if X.eq i j then x else get i m.
+  Lemma elements_keys_norepet:
+    forall (A: Type) (m: t A),
+    list_norepet (List.map (@fst elt A) (elements m)).
   Proof.
-    intros. unfold get, set. 
-    rewrite PMap.gsspec.
-    case (X.eq i j); intro.
-    subst j. rewrite peq_true. reflexivity.
-    rewrite peq_false. reflexivity. 
-    red; intro. elim n. apply X.index_inj; auto.
+    intros.
+    apply uniq__list_norepet.
+    apply elements_uniq; auto.
   Qed.
 
-  Lemma gmap:
-    forall (A B: Type) (f: A -> B) (i: X.t) (m: t A),
-    get i (map f m) = f(get i m).
+  Lemma get__eq__get_elements: forall (A:Type) (i:atom) (m:t A),
+    get i m = get i (elements m).
   Proof.
-    intros. unfold map, get. apply PMap.gmap. 
+    intros.
+    case_eq (get i m).
+      intros a Hget.
+      apply elements_correct in Hget.
+      apply In_lookupAL in Hget; auto using elements_uniq.
+
+      intros Hget.
+      case_eq (get i (elements m)); auto.
+      intros b Hget'.
+      apply lookupAL_in in Hget'.
+      apply elements_complete in Hget'.
+      congruence.
   Qed.
 
-End IMap.
-
-Module ZIndexed.
-  Definition t := Z.
+(* FIXME: We need a non-duplicated AL to implement elements. 
+  Hypothesis elements_canonical_order:
+    forall (A B: Type) (R: A -> B -> Prop) (m: t A) (n: t B),
+    (forall i x, get i m = Some x -> exists y, get i n = Some y /\ R x y) ->
+    (forall i y, get i n = Some y -> exists x, get i m = Some x /\ R x y) ->
+    list_forall2
+      (fun i_x i_y => fst i_x = fst i_y /\ R (snd i_x) (snd i_y))
+      (elements m) (elements n).
+  Hypothesis elements_extensional:
+    forall (A: Type) (m n: t A),
+    (forall i, get i m = get i n) ->
+    elements m = elements n.
+*)
+
+  Section Combine.
+
+  Variable (A:Type) (f:option A -> option A -> option A).
+
+  Fixpoint combiner (m1 m2: t A)
+    :t A :=
+  match m2 with
+  | nil => nil
+  | (k, v2)::m2' => 
+      let acc := combiner m1 m2' in
+      match get k m1 with
+      | None => 
+          match f None (Some v2) with
+          | Some r => (k, r)::acc
+          | _ => acc
+          end
+      | Some _ => acc
+      end
+  end.
+
+  Fixpoint combinel (m1 m2 init: t A) :t A :=
+  match m1 with
+  | nil => init
+  | (k, v1)::m1' => 
+      let acc := combinel m1' m2 init in
+      match f (Some v1) (get k m2) with
+      | Some r => (k, r)::acc
+      | _ => acc
+      end
+  end.
+
+  Definition combine (m1 m2: t A) :t A :=
+  let m1' := elements m1 in
+  let m2' := elements m2 in
+  combinel m1' m2' (combiner m1' m2').
+
+  Lemma notin_m2__notin_combiner: forall k m1 m2 (Hnotin : k `notin` dom m2),
+    get k (combiner m1 m2) = None.
+  Proof.
+    induction m2 as [|[k2 v2]]; simpl; intros; auto.
+      destruct (get k2 m1); auto.
+      destruct (f None (Some v2)); auto.
+        simpl. 
+        destruct_if.
+          fsetdec.
+  Qed.
+
+  Lemma notin_m1__notin_combinel: forall k m2 init m1 
+    (Hnotin : k `notin` dom m1),
+    get k (combinel m1 m2 init) = get k init.
+  Proof.
+    induction m1 as [|[k1 v1]]; simpl; intros; auto.
+      destruct (f (Some v1) (get k1 m2)); auto.
+        simpl. 
+        destruct_if.
+          fsetdec.
+  Qed.
+
+  Hypothesis (Hnone: f None None = None).
+
+  Lemma gcombiner:
+    forall (i: elt) (m1 m2: t A) (Huniq: uniq m2),
+    (forall (Hget: get i m1 = None), 
+       get i (combiner m1 m2) = f None (get i m2)) /\
+    (forall (Hget: get i m1 <> None), get i (combiner m1 m2) = None).
+  Proof.
+    induction m2 as [|[k v2]]; simpl; intros; auto.
+      inv Huniq.
+      split; intros.   
+      Case "1".
+        destruct (@eq_dec atom (@EqDec_eq_of_EqDec atom EqDec_atom) i k); subst.
+        SCase "1.1".
+          rewrite Hget.
+          destruct (f None (Some v2)).
+            simpl. destruct_if. congruence.
+            apply notin_m2__notin_combiner; auto.
+        SCase "1.2".
+          case_eq (get k m1).
+          SSCase "1.2.1".
+            intros a Hgeta. 
+            apply IHm2; auto.
+          SSCase "1.2.2".
+            intros Hgeta. 
+            destruct (f None (Some v2)).
+            SSSCase "1.2.2.1".
+              simpl. 
+              destruct_if. 
+                congruence.
+                apply IHm2; auto.
+            SSSCase "1.2.2.2".
+              apply IHm2; auto.
+      Case "2".
+          case_eq (get k m1).
+          SSCase "1.2.1".
+            intros a Hgeta. 
+            apply IHm2; auto.
+          SSCase "1.2.2".
+            intros Hgeta. 
+            destruct (f None (Some v2)).
+            SSSCase "1.2.2.1".
+              simpl. 
+              destruct_if. 
+                congruence.
+                apply IHm2; auto.
+            SSSCase "1.2.2.2".
+              apply IHm2; auto.
+  Qed.
+
+  Lemma gcombinel:
+    forall init (i: elt) (m2 m1: t A) (Huniq: uniq m1)
+    (Hinit: forall i, get i m1 <> None -> get i init = None),
+    (forall (Hget: get i m1 = None), get i (combinel m1 m2 init) = get i init) /\
+    (forall (Hget: get i m1 <> None), 
+       get i (combinel m1 m2 init) = f (get i m1) (get i m2)).
+  Proof.
+    induction m1 as [|[k v1]]; simpl; intros.
+      split; auto.
+        congruence.
+
+      inv Huniq.
+      assert (forall i0 : atom, get i0 m1 <> None -> get i0 init = None) 
+        as Hinit'.
+        intros. apply Hinit. destruct_if. congruence.
+      split; intros.   
+      Case "1".
+        destruct (@eq_dec atom (@EqDec_eq_of_EqDec atom EqDec_atom) i k); subst;
+          try congruence.
+        destruct (f (Some v1) (get k m2)).
+        SCase "1.1".
+          simpl. 
+          destruct_if. 
+            congruence.
+            apply IHm1; auto.
+        SCase "1.2.2.2".
+          apply IHm1; auto.
+      Case "2".
+        destruct (@eq_dec atom (@EqDec_eq_of_EqDec atom EqDec_atom) i k); subst.
+        SCase "2.1".
+          destruct (f (Some v1) (get k m2)).
+          SSCase "2.1.1".
+            simpl. 
+            destruct_if. 
+              congruence.
+          SSCase "2.1.2".
+            transitivity (get k init).
+              apply notin_m1__notin_combinel; auto.
+              apply Hinit.
+              destruct_if. 
+        SCase "2.2".
+          destruct (f (Some v1) (get k m2)).
+          SSCase "2.1.1".
+            simpl. 
+            destruct_if. 
+              congruence.
+              apply IHm1; auto.
+          SSCase "2.1.2".
+            apply IHm1; auto.
+  Qed.
+
+  Lemma gcombine:
+    forall (m1 m2: t A) (i: elt),
+    get i (combine m1 m2) = f (get i m1) (get i m2).
+  Proof.
+    unfold combine.
+    intros.
+    assert (get i m1 = get i (elements m1)) as EQ1.
+      apply get__eq__get_elements.
+    assert (get i m2 = get i (elements m2)) as EQ2.
+      apply get__eq__get_elements.
+    rewrite EQ1. rewrite EQ2.
+    assert (forall i0 : atom,
+            get i0 (elements m1) <> None ->
+            get i0 (combiner (elements m1) (elements m2)) = None) as J.
+      intros. apply gcombiner; auto using elements_uniq.
+    case_eq (get i (elements m1)).
+      intros a Hget. rewrite <- Hget.
+      apply gcombinel; try solve [auto using elements_uniq | congruence].
+
+      intros Hget.
+      transitivity (get i (combiner (elements m1) (elements m2))).
+        apply gcombinel; auto using elements_uniq.
+        apply gcombiner; auto using elements_uniq.
+  Qed.
+
+(* 
+  FIXME: We need a sorted AL to prove this.
+  Hypothesis combine_commut:
+    forall (A: Type) (f g: option A -> option A -> option A),
+    (forall (i j: option A), f i j = g j i) ->
+    forall (m1 m2: t A),
+    combine f m1 m2 = combine g m2 m1.
+*)
+
+  End Combine.
+
+  (** Folding a function over all bindings of a tree. *)
+  Fixpoint xfold (A B: Type) (f: B -> elt -> A -> B) (m: t A) (v: B) : B :=
+  match m with
+  | nil => v
+  | (id0, gv0)::m' => xfold f m' (f v id0 gv0)
+  end.
+
+  Definition fold (A B: Type) (f: B -> elt -> A -> B) (m: t A) (v: B) : B :=
+  xfold f (elements m) v.
+
+  Theorem fold_spec:
+    forall (A B: Type) (f: B -> elt -> A -> B) (v: B) (m: t A),
+    fold f m v =
+    List.fold_left (fun a p => f a (fst p) (snd p)) (elements m) v.
+  Proof.
+    unfold fold.
+    intros. generalize dependent v.
+    generalize (elements m) as m'.
+    induction m' as [|[k v]]; simpl; intros; auto.
+  Qed.
+
+  Global Opaque empty.
+
+End ATree'.
+
+(** * An implementation of trees over type [atom] using AVL *)
+
+Module AtomOT <: OrderedType with Definition t := atom.
+
+  Definition t := atom.
+
+  Definition eq := @eq t.
+  Definition eq_refl := @refl_equal t.
+  Definition eq_sym := @sym_eq t.
+  Definition eq_trans := @trans_eq t.
+
+  Definition eq_dec := eq_atom_dec.
+
+  Parameter lt : t -> t -> Prop.
+  
+  Axiom lt_trans : forall x y z : t, lt x y -> lt y z -> lt x z.
+  Axiom lt_not_eq : forall x y : t, lt x y -> ~ eq x y.
+
+  Parameter compare : forall x y : t, Compare lt eq x y.
+
+End AtomOT.
+
+Require Import FMapAVL.
+Require Import FMapFacts.
+Module AtomFMapAVL := FMapAVL.Make (AtomOT).
+Module AVLFacts := WFacts_fun (AtomOT) (AtomFMapAVL).
+
+Module ATree <: TREE.
+
+  Definition elt := atom.
+  Definition elt_eq := AtomOT.eq_dec .
+
+  Definition tree (A : Type) : Type := AtomFMapAVL.t A.
+
+  Definition t := tree.
+
+  Definition empty (A: Type) : t A := AtomFMapAVL.empty A.
+
+  Definition get (A: Type) (i: atom) (m: t A) : option A :=
+    AtomFMapAVL.find i m.
+
+  Definition set (A: Type) (i: atom) (v: A) (m: t A) : t A :=
+    AtomFMapAVL.add i v m.
+
+  Definition remove (A: Type) (i: atom) (m: t A) : t A :=
+    AtomFMapAVL.remove i m.
+
+  (** The ``good variables'' properties for trees, expressing
+    commutations between [get], [set] and [remove]. *)
+  Theorem gempty:
+    forall (A: Type) (i: elt), get i (empty A) = None.
+  Proof. auto. Qed.
+
+  Theorem gss:
+    forall (A: Type) (i: elt) (x: A) (m: t A), get i (set i x m) = Some x.
+  Proof. intros. apply AVLFacts.add_eq_o; auto. Qed.
+
+  Theorem gso:
+    forall (A: Type) (i j: elt) (x: A) (m: t A),
+    i <> j -> get i (set j x m) = get i m.
+  Proof. intros. apply AVLFacts.add_neq_o; auto. Qed.
+
+  Theorem gsspec:
+    forall (A: Type) (i j: elt) (x: A) (m: t A),
+    get i (set j x m) = if elt_eq i j then Some x else get i m.
+  Proof.
+    intros. rewrite AVLFacts.add_o; auto.
+    unfold elt_eq. 
+    destruct (AtomOT.eq_dec i j); subst; auto. 
+      destruct (AtomOT.eq_dec j j); subst; congruence.
+      destruct (AtomOT.eq_dec j i); subst; auto. congruence.
+  Qed.
+
+  Theorem grs:
+    forall (A: Type) (i: elt) (m: t A), get i (remove i m) = None.
+  Proof. intros. apply AVLFacts.remove_eq_o; auto. Qed.
+
+  Theorem gro:
+    forall (A: Type) (i j: elt) (m: t A),
+    i <> j -> get i (remove j m) = get i m.
+  Proof. intros. apply AVLFacts.remove_neq_o; auto. Qed.
+
+  Theorem grspec:
+    forall (A: Type) (i j: elt) (m: t A),
+    get i (remove j m) = if elt_eq i j then None else get i m.
+  Proof.
+    intros. rewrite AVLFacts.remove_o; auto.
+    unfold elt_eq. 
+    destruct (AtomOT.eq_dec i j); subst; auto. 
+      destruct (AtomOT.eq_dec j j); subst; congruence.
+      destruct (AtomOT.eq_dec j i); subst; auto. congruence.
+  Qed.
+
+  (** Applying a function to all data of a tree. *)
+  Definition map (A B: Type) (f: elt -> A -> B) (m: t A) : t B :=
+    AtomFMapAVL.mapi f m.
+
+  Theorem gmap:
+    forall (A B: Type) (f: elt -> A -> B) (i: elt) (m: t A),
+    get i (map f m) = option_map (f i) (get i m).
+  Proof.
+    intros.
+    apply AVLFacts.mapi_o; congruence.
+  Qed.
+
+  (** Enumerating the bindings of a tree. *)
+  Definition elements (A: Type) (m: t A) : list (elt * A) := 
+    AtomFMapAVL.elements m.
+
+  Theorem elements_correct:
+    forall (A: Type) (m: t A) (i: elt) (v: A),
+    get i m = Some v -> In (i, v) (elements m).
+  Proof.
+    intros.
+    apply AVLFacts.find_mapsto_iff in H.
+    apply AVLFacts.elements_mapsto_iff in H.
+    apply InA_alt in H.
+    destruct H as [[i' v'] [[EQ1 EQ2] Hin]]; simpl in *; subst. auto.
+  Qed.
+
+  Lemma elements_complete:
+    forall (A: Type) (m: t A) (i: elt) (v: A)
+    (Hin: In (i, v) (elements m)), get i m = Some v.
+  Proof.
+    intros.
+    apply AVLFacts.find_mapsto_iff.
+    apply AVLFacts.elements_mapsto_iff.
+    apply InA_alt.
+    exists (i, v). 
+    repeat split; auto.
+  Qed.
+
+  Lemma NoDupA_keys_norepet:
+    forall (A: Type) (m: list (elt * A)) 
+    (Huniq: NoDupA (@AtomFMapAVL.eq_key A) m),
+    list_norepet (List.map (@fst elt A) m).
+  Proof.
+    induction 1; simpl.
+      constructor.
+
+      constructor; auto.
+        intro Hin. apply H. apply InA_alt.
+        apply list_in_map_inv in Hin.
+        destruct Hin as [[i0 v0] [EQ Hin]].
+        destruct x as [i v].
+        simpl in EQ; inv EQ.
+        exists (i0, v0).
+        repeat split; auto.
+  Qed.
+
+  Lemma elements_keys_norepet:
+    forall (A: Type) (m: t A),
+    list_norepet (List.map (@fst elt A) (elements m)).
+  Proof.
+    intros.
+    apply NoDupA_keys_norepet.
+      apply AtomFMapAVL.elements_3w.
+  Qed.
+
+  Definition fold (A B: Type) (f: B -> elt -> A -> B) (m: t A) (v: B) : B :=
+    AtomFMapAVL.fold (fun key v acc => f acc key v) m v.
+
+  Theorem fold_spec:
+    forall (A B: Type) (f: B -> elt -> A -> B) (v: B) (m: t A),
+    fold f m v =
+    List.fold_left (fun a p => f a (fst p) (snd p)) (elements m) v.
+  Proof.
+    intros. apply AtomFMapAVL.fold_1; auto.
+  Qed.
+
+  Global Opaque empty.
+
+End ATree.
+
+(** * An implementation of maps over type [positive] *)
+
+Module PMap <: MAP.
+  Definition elt := positive.
+  Definition elt_eq := peq.
+
+  Definition t (A : Type) : Type := (A * PTree.t A)%type.
+
+  Definition eq: forall (A: Type), (forall (x y: A), {x=y} + {x<>y}) ->
+                 forall (a b: t A), {a = b} + {a <> b}.
+  Proof.
+    intros A H.
+    generalize (PTree.eq H). intros.
+    decide equality.
+  Qed.
+
+  Definition init (A : Type) (x : A) :=
+    (x, PTree.empty A).
+
+  Definition get (A : Type) (i : positive) (m : t A) :=
+    match PTree.get i (snd m) with
+    | Some x => x
+    | None => fst m
+    end.
+
+  Definition set (A : Type) (i : positive) (x : A) (m : t A) :=
+    (fst m, PTree.set i x (snd m)).
+
+  Theorem gi:
+    forall (A: Type) (i: positive) (x: A), get i (init x) = x.
+  Proof.
+    intros. unfold init. unfold get. simpl. rewrite PTree.gempty. auto.
+  Qed.
+
+  Theorem gss:
+    forall (A: Type) (i: positive) (x: A) (m: t A), get i (set i x m) = x.
+  Proof.
+    intros. unfold get. unfold set. simpl. rewrite PTree.gss. auto.
+  Qed.
+
+  Theorem gso:
+    forall (A: Type) (i j: positive) (x: A) (m: t A),
+    i <> j -> get i (set j x m) = get i m.
+  Proof.
+    intros. unfold get. unfold set. simpl. rewrite PTree.gso; auto.
+  Qed.
+
+  Theorem gsspec:
+    forall (A: Type) (i j: positive) (x: A) (m: t A),
+    get i (set j x m) = if peq i j then x else get i m.
+  Proof.
+    intros. destruct (peq i j).
+     rewrite e. apply gss. auto.
+     apply gso. auto.
+  Qed.
+
+  Theorem gsident:
+    forall (A: Type) (i j: positive) (m: t A),
+    get j (set i (get i m) m) = get j m.
+  Proof.
+    intros. destruct (peq i j).
+     rewrite e. rewrite gss. auto.
+     rewrite gso; auto.
+  Qed.
+
+  Definition map (A B : Type) (f : A -> B) (m : t A) : t B :=
+    (f (fst m), PTree.map (fun _ => f) (snd m)).
+
+  Theorem gmap:
+    forall (A B: Type) (f: A -> B) (i: positive) (m: t A),
+    get i (map f m) = f(get i m).
+  Proof.
+    intros. unfold map. unfold get. simpl. rewrite PTree.gmap.
+    unfold option_map. destruct (PTree.get i (snd m)); auto.
+  Qed.
+
+End PMap.
+
+(** * An implementation of maps over type [atom] using list *)
+
+Module AMap' <: MAP.
+  Definition elt := atom.
+  Definition elt_eq := eq_atom_dec.
+
+  Definition t (A : Type) : Type := (A * ATree'.t A)%type.
+
+  Definition eq: forall (A: Type), (forall (x y: A), {x=y} + {x<>y}) ->
+                 forall (a b: t A), {a = b} + {a <> b}.
+  Proof.
+    intros A H.
+    generalize (ATree'.eq H). intros.
+    decide equality.
+  Qed.
+
+  Definition init (A : Type) (x : A) :=
+    (x, ATree'.empty A).
+
+  Definition get (A : Type) (i : atom) (m : t A) :=
+    match ATree'.get i (snd m) with
+    | Some x => x
+    | None => fst m
+    end.
+
+  Definition set (A : Type) (i : atom) (x : A) (m : t A) :=
+    (fst m, ATree'.set i x (snd m)).
+
+  Theorem gi:
+    forall (A: Type) (i: atom) (x: A), get i (init x) = x.
+  Proof.
+    intros. unfold init. unfold get. simpl. rewrite ATree'.gempty. auto.
+  Qed.
+
+  Theorem gss:
+    forall (A: Type) (i: atom) (x: A) (m: t A), get i (set i x m) = x.
+  Proof.
+    intros. unfold get. unfold set. simpl. rewrite ATree'.gss. auto.
+  Qed.
+
+  Theorem gso:
+    forall (A: Type) (i j:atom) (x: A) (m: t A),
+    i <> j -> get i (set j x m) = get i m.
+  Proof.
+    intros. unfold get. unfold set. simpl. rewrite ATree'.gso; auto.
+  Qed.
+
+  Theorem gsspec:
+    forall (A: Type) (i j: atom) (x: A) (m: t A),
+    get i (set j x m) = if eq_atom_dec i j then x else get i m.
+  Proof.
+    intros. destruct (eq_atom_dec i j).
+     rewrite e. apply gss. auto.
+     apply gso. auto.
+  Qed.
+
+  Theorem gsident:
+    forall (A: Type) (i j: atom) (m: t A),
+    get j (set i (get i m) m) = get j m.
+  Proof.
+    intros. destruct (eq_atom_dec i j).
+     rewrite e. rewrite gss. auto.
+     rewrite gso; auto.
+  Qed.
+
+  Definition map (A B : Type) (f : A -> B) (m : t A) : t B :=
+    (f (fst m), ATree'.map (fun _ => f) (snd m)).
+
+  Theorem gmap:
+    forall (A B: Type) (f: A -> B) (i: atom) (m: t A),
+    get i (map f m) = f(get i m).
+  Proof.
+    intros. unfold map. unfold get. simpl. rewrite ATree'.gmap.
+    unfold option_map. destruct (ATree'.get i (snd m)); auto.
+  Qed.
+
+End AMap'.
+
+(** * An implementation of maps over type [atom] using AVL *)
+
+Module AMap <: MAP.
+
+  Definition elt := atom.
+  Definition elt_eq := AtomOT.eq_dec .
+
+  Definition t (A : Type) : Type := (A * ATree.t A)%type.
+
+  Definition init (A : Type) (x : A) :=
+    (x, ATree.empty A).
+
+  Definition get (A : Type) (i : atom) (m : t A) :=
+    match ATree.get i (snd m) with
+    | Some x => x
+    | None => fst m
+    end.
+
+  Definition set (A : Type) (i : atom) (x : A) (m : t A) :=
+    (fst m, ATree.set i x (snd m)).
+
+  Theorem gi:
+    forall (A: Type) (i: atom) (x: A), get i (init x) = x.
+  Proof.
+    intros. unfold init. unfold get. simpl. rewrite ATree.gempty. auto.
+  Qed.
+
+  Theorem gss:
+    forall (A: Type) (i: atom) (x: A) (m: t A), get i (set i x m) = x.
+  Proof.
+    intros. unfold get. unfold set. simpl. rewrite ATree.gss. auto.
+  Qed.
+
+  Theorem gso:
+    forall (A: Type) (i j:atom) (x: A) (m: t A),
+    i <> j -> get i (set j x m) = get i m.
+  Proof.
+    intros. unfold get. unfold set. simpl. rewrite ATree.gso; auto.
+  Qed.
+
+  Theorem gsspec:
+    forall (A: Type) (i j: atom) (x: A) (m: t A),
+    get i (set j x m) = if eq_atom_dec i j then x else get i m.
+  Proof.
+    intros. destruct (eq_atom_dec i j).
+     rewrite e. apply gss. auto.
+     apply gso. auto.
+  Qed.
+
+  Theorem gsident:
+    forall (A: Type) (i j: atom) (m: t A),
+    get j (set i (get i m) m) = get j m.
+  Proof.
+    intros. destruct (eq_atom_dec i j).
+     rewrite e. rewrite gss. auto.
+     rewrite gso; auto.
+  Qed.
+
+  Definition map (A B : Type) (f : A -> B) (m : t A) : t B :=
+    (f (fst m), ATree.map (fun _ => f) (snd m)).
+
+  Theorem gmap:
+    forall (A B: Type) (f: A -> B) (i: atom) (m: t A),
+    get i (map f m) = f(get i m).
+  Proof.
+    intros. unfold map. unfold get. simpl. rewrite ATree.gmap.
+    unfold option_map. destruct (ATree.get i (snd m)); auto.
+  Qed.
+
+End AMap.
+
+(** * An implementation of maps over any type that injects into type [positive] *)
+
+Module Type INDEXED_TYPE.
+  Variable t: Type.
+  Variable index: t -> positive.
+  Hypothesis index_inj: forall (x y: t), index x = index y -> x = y.
+  Variable eq: forall (x y: t), {x = y} + {x <> y}.
+End INDEXED_TYPE.
+
+Module IMap(X: INDEXED_TYPE).
+
+  Definition elt := X.t.
+  Definition elt_eq := X.eq.
+  Definition t : Type -> Type := PMap.t.
+  Definition eq: forall (A: Type), (forall (x y: A), {x=y} + {x<>y}) ->
+                 forall (a b: t A), {a = b} + {a <> b} := PMap.eq.
+  Definition init (A: Type) (x: A) := PMap.init x.
+  Definition get (A: Type) (i: X.t) (m: t A) := PMap.get (X.index i) m.
+  Definition set (A: Type) (i: X.t) (v: A) (m: t A) := PMap.set (X.index i) v m.
+  Definition map (A B: Type) (f: A -> B) (m: t A) : t B := PMap.map f m.
+
+  Lemma gi:
+    forall (A: Type) (x: A) (i: X.t), get i (init x) = x.
+  Proof.
+    intros. unfold get, init. apply PMap.gi.
+  Qed.
+
+  Lemma gss:
+    forall (A: Type) (i: X.t) (x: A) (m: t A), get i (set i x m) = x.
+  Proof.
+    intros. unfold get, set. apply PMap.gss.
+  Qed.
+
+  Lemma gso:
+    forall (A: Type) (i j: X.t) (x: A) (m: t A),
+    i <> j -> get i (set j x m) = get i m.
+  Proof.
+    intros. unfold get, set. apply PMap.gso.
+    red. intro. apply H. apply X.index_inj; auto.
+  Qed.
+
+  Lemma gsspec:
+    forall (A: Type) (i j: X.t) (x: A) (m: t A),
+    get i (set j x m) = if X.eq i j then x else get i m.
+  Proof.
+    intros. unfold get, set.
+    rewrite PMap.gsspec.
+    case (X.eq i j); intro.
+    subst j. rewrite peq_true. reflexivity.
+    rewrite peq_false. reflexivity.
+    red; intro. elim n. apply X.index_inj; auto.
+  Qed.
+
+  Lemma gmap:
+    forall (A B: Type) (f: A -> B) (i: X.t) (m: t A),
+    get i (map f m) = f(get i m).
+  Proof.
+    intros. unfold map, get. apply PMap.gmap.
+  Qed.
+
+End IMap.
+
+Module ZIndexed.
+  Definition t := Z.
   Definition index (z: Z): positive :=
     match z with
     | Z0 => xH
@@ -1296,7 +2362,7 @@
   (forall x, T.get x m = T.get x m') ->
   P m a -> P m' a.
 
-Hypothesis H_base: 
+Hypothesis H_base:
   P (T.empty _) init.
 
 Hypothesis H_rec:
@@ -1324,23 +2390,23 @@
   P' l a ->
   P' (l ++ (k, v) :: nil) (f a k v).
 Proof.
-  unfold P'; intros.  
-  set (m0 := T.remove k m). 
+  unfold P'; intros.
+  set (m0 := T.remove k m).
   apply P_compat with (T.set k v m0).
     intros. unfold m0. rewrite T.gsspec. destruct (T.elt_eq x k).
     symmetry. apply T.elements_complete. rewrite <- (H2 (x, v)).
     apply in_or_app. simpl. intuition congruence.
     apply T.gro. auto.
-  apply H_rec. unfold m0. apply T.grs. apply T.elements_complete. auto. 
-  apply H1. red. intros [k' v']. 
-  split; intros. 
-  apply T.elements_correct. unfold m0. rewrite T.gro. apply T.elements_complete. 
-  rewrite <- (H2 (k', v')). apply in_or_app. auto. 
+  apply H_rec. unfold m0. apply T.grs. apply T.elements_complete. auto.
+  apply H1. red. intros [k' v'].
+  split; intros.
+  apply T.elements_correct. unfold m0. rewrite T.gro. apply T.elements_complete.
+  rewrite <- (H2 (k', v')). apply in_or_app. auto.
   red; intro; subst k'. elim H. change k with (fst (k, v')). apply in_map. auto.
   assert (T.get k' m0 = Some v'). apply T.elements_complete. auto.
   unfold m0 in H4. rewrite T.grspec in H4. destruct (T.elt_eq k' k). congruence.
   assert (In (k', v') (T.elements m)). apply T.elements_correct; auto.
-  rewrite <- (H2 (k', v')) in H5. destruct (in_app_or _ _ _ H5). auto. 
+  rewrite <- (H2 (k', v')) in H5. destruct (in_app_or _ _ _ H5). auto.
   simpl in H6. intuition congruence.
 Qed.
 
@@ -1353,10 +2419,10 @@
 Proof.
   induction l1; intros; simpl.
   rewrite <- List.app_nil_end. auto.
-  destruct a as [k v]; simpl in *. inv H1. 
+  destruct a as [k v]; simpl in *. inv H1.
   change ((k, v) :: l1) with (((k, v) :: nil) ++ l1). rewrite <- List.app_ass. apply IHl1.
   rewrite app_ass. auto.
-  red; intros. rewrite map_app in H3. destruct (in_app_or _ _ _ H3). apply H0; auto with coqlib. 
+  red; intros. rewrite List.map_app in H3. destruct (in_app_or _ _ _ H3). apply H0; auto with coqlib.
   simpl in H4. intuition congruence.
   auto.
   unfold f'. simpl. apply H_rec'; auto. eapply list_disjoint_notin; eauto with coqlib.
@@ -1371,8 +2437,8 @@
     apply fold_rec_aux.
     simpl. red; intros; tauto.
     simpl. red; intros. elim H0.
-    apply T.elements_keys_norepet. 
-    apply H_base'. 
+    apply T.elements_keys_norepet.
+    apply H_base'.
   simpl in H. red in H. apply H. red; intros. tauto.
 Qed.
 
@@ -1380,11 +2446,479 @@
 
 End Tree_Properties.
 
+Module More_Tree_Properties(T: TREE).
+
+Module TProp := Tree_Properties(T).
+
+Notation "a ! b" := (T.get b a) (at level 1).
+Notation "a !! b" := (T.get b a) (at level 1).
+
+Definition successors_list A (successors: T.t (list A)) (pc: T.elt) 
+  : list A :=
+  match successors!pc with None => nil | Some l => l end.
+
+Implicit Arguments successors_list [A].
+
+Notation "a !!! b" := (successors_list a b) (at level 1).
+
+Lemma successors_list_spec: forall A (a:A) scss l0,
+  In a (scss!!!l0) -> exists scs, scss!l0 = Some scs /\ In a scs.
+Proof.
+  unfold successors_list.
+  intros.
+  destruct (scss!l0); [eauto | inv H].
+Qed.
+
+Section Predecessor. 
+
+Variable successors: T.t (list T.elt).
+
+Fixpoint add_successors (pred: T.t (list T.elt))
+                        (from: T.elt) (tolist: list T.elt)
+                        {struct tolist} : T.t (list T.elt) :=
+  match tolist with
+  | nil => pred
+  | to :: rem => add_successors (T.set to (from :: pred!!!to) pred) from rem
+  end.
+
+Lemma add_successors_correct:
+  forall tolist from pred n s,
+  In n pred!!!s \/ (n = from /\ In s tolist) ->
+  In n (add_successors pred from tolist)!!!s.
+Proof.
+  induction tolist; simpl; intros.
+  tauto.
+  apply IHtolist.
+  unfold successors_list at 1. rewrite T.gsspec.
+  destruct (T.elt_eq s a).
+    subst a. 
+    destruct H. 
+      auto with coqlib.
+      destruct H.
+        subst n. auto with coqlib.
+    fold (successors_list pred s). intuition congruence.
+Qed.
+
+Lemma add_successors_correct':
+  forall tolist from pred n s,
+  In n (add_successors pred from tolist)!!!s ->
+  In n pred!!!s \/ (n = from /\ In s tolist).
+Proof.
+  induction tolist; simpl; intros.
+  tauto.
+  apply IHtolist in H.
+  unfold successors_list at 1 in H.
+  rewrite T.gsspec in H.
+  destruct (T.elt_eq s a); subst.
+    simpl in H.
+    destruct H.
+      destruct H; subst; auto.
+      destruct H as [H1 H2]; subst; auto.
+
+      fold (successors_list pred s) in H. intuition congruence.
+Qed.
+
+Lemma add_successors_correct'': forall (m a : T.t (list T.elt)) 
+  (k : T.elt) (v : list T.elt)
+  (Herr : m ! k = None) (l1 l2 : T.elt)
+  (Hinc: In l1 a !!! l2 -> In l2 m !!! l1)
+  (Hin: In l1 (add_successors a k v) !!! l2), In l2 (T.set k v m) !!! l1.
+Proof.
+  intros.
+  apply add_successors_correct' in Hin. 
+  unfold successors_list.
+  rewrite T.gsspec.
+  destruct (T.elt_eq l1 k).
+    destruct Hin as [Hin | [EQ Hin]]; subst; auto.
+      apply Hinc in Hin.
+      unfold successors_list in Hin.
+      rewrite Herr in Hin. inv Hin.
+ 
+    destruct Hin as [Hin | [EQ Hin]]; subst; try congruence.
+      apply Hinc in Hin. 
+      unfold successors_list in Hin.
+      auto.    
+Qed.
+
+Definition make_predecessors : T.t (list T.elt) :=
+  T.fold add_successors successors (T.empty (list T.elt)).
+
+Lemma make_predecessors_correct:
+  forall n s,
+  In s successors!!!n ->
+  In n make_predecessors!!!s.
+Proof.
+  set (P := fun succ pred =>
+          forall n s, In s succ!!!n -> In n pred!!!s).
+  unfold make_predecessors.
+  apply TProp.fold_rec with (P := P).
+(* extensionality *)
+  unfold P; unfold successors_list; intros.
+  rewrite <- H in H1. auto.
+(* base case *)
+  red; unfold successors_list. intros n s. repeat rewrite T.gempty. auto.
+(* inductive case *)
+  unfold P; intros. apply add_successors_correct.
+  unfold successors_list in H2. rewrite T.gsspec in H2.
+  destruct (T.elt_eq n k).
+  subst k. auto.
+  fold (successors_list m n) in H2. auto.
+Qed.
+
+Lemma make_predecessors_correct':
+  forall n s,
+  In n make_predecessors!!!s ->
+  In s successors!!!n.
+Proof.
+  set (P := fun succ pred =>
+          forall n s, In n pred!!!s -> In s succ!!!n).
+  unfold make_predecessors.
+  apply TProp.fold_rec with (P := P).
+(* extensionality *)
+  unfold P; unfold successors_list; intros.
+  rewrite <- H. auto.
+(* base case *)
+  red; unfold successors_list. intros n s. repeat rewrite T.gempty. auto.
+(* inductive case *)
+  unfold P; intros. apply add_successors_correct' in H2.
+  unfold successors_list in *. rewrite T.gsspec.
+  destruct H2 as [H2 | [Heq H2]]; subst.
+    destruct (T.elt_eq n k); subst; auto.
+      apply H1 in H2. unfold successors_list in H2. rewrite H in H2. inv H2.
+    destruct (T.elt_eq k k); subst; auto.
+      congruence.
+Qed.
+
+Lemma eq_eli__eq_successors_list: forall (m m':T.t (list T.elt)) x
+  (Heq: m ! x = m' ! x), m !!! x = m' !!! x.
+Proof.
+  intros.
+  unfold successors_list.
+  erewrite Heq. auto.
+Qed.
+
+End Predecessor.
+
+Definition children_of_tree A (tree: T.t (list A)) :=
+  flat_map snd (T.elements tree).
+
+Definition parents_of_tree A (tree: T.t A) :=
+  List.map fst (T.elements tree).
+
+Implicit Arguments children_of_tree [A].
+Implicit Arguments parents_of_tree [A].
+
+Require Import Program.Tactics.
+
+Lemma children_in_children_of_tree: forall A (succs:T.t (list A)) l0,
+  incl (succs !!! l0) (children_of_tree succs).
+Proof.
+  intros.
+  intros x Hin.
+  apply in_flat_map.
+  apply successors_list_spec in Hin.
+  destruct_conjs.
+  eauto using T.elements_correct.
+Qed.
+
+Lemma parents_of_tree_spec: forall A l0 (tr: T.t A),
+  In l0 (parents_of_tree tr) <-> exists a, In (l0, a) (T.elements tr).
+Proof.
+  unfold parents_of_tree.
+  intros.
+  split; intro J.
+    apply in_map_iff in J.
+    destruct J as [[x1 x2] [J1 J2]]. subst. eauto.
+
+    apply in_map_iff.
+    destruct J as [y J]. exists (l0, y). auto.
+Qed.
+
+Lemma notin_tree__notin_parents_of_tree: forall (visited : T.t unit)
+  l0 (H0 : visited ! l0 = None),
+  ~ In l0 (parents_of_tree visited).
+Proof.
+  intros.
+  intros Hin'. apply parents_of_tree_spec in Hin'.
+  destruct Hin' as [a Hin'].
+  apply T.elements_complete in Hin'. 
+  congruence.
+Qed.
+
+Lemma in_tree__in_parents_of_tree: forall (visited : T.t unit) a
+  l0 (H0 : visited ! l0 = Some a),
+  In l0 (parents_of_tree visited).
+Proof.
+  intros.
+  apply parents_of_tree_spec. 
+  apply T.elements_correct in H0.  eauto.
+Qed.
+
+Lemma parents_children_of_tree__inc__length_le: forall 
+  (eq_dec : forall x y : T.elt, {x = y}+{x <> y}) (visited:T.t T.elt)
+  succs (Hinc: incl (parents_of_tree visited) (children_of_tree succs)),
+  (length (parents_of_tree visited) <= length (children_of_tree succs))%nat.
+Proof.
+  intros. 
+  apply incl__length_le; auto.
+    apply T.elements_keys_norepet.
+Qed.
+
+Ltac destruct_if :=
+match goal with
+| H: context [(if ?lk then _ else _)] |- _ =>
+   remember lk as R; destruct R; try inv H
+| H: context [if ?lk then _ else _] |- _ =>
+   remember lk as R; destruct R; try inv H
+| |- context [(if ?lk then _ else _)] =>
+   remember lk as R; destruct R; subst; auto
+| |- context [if ?lk then _ else _] => remember lk as R; destruct R; subst; auto
+end.
+
+Lemma parents_of_tree_succ_len: forall (visited : T.t unit)
+  l0 (H0 : visited ! l0 = None),
+  length (parents_of_tree (T.set l0 tt visited)) =
+    (length (parents_of_tree visited) + 1)%nat.
+Proof.
+  intros.
+  unfold parents_of_tree.
+  apply norepet_equiv__length_cons_eq with (a:=l0); 
+    auto using T.elements_keys_norepet.
+    apply notin_tree__notin_parents_of_tree; auto.
+
+    intro x; split; intro Hin.
+      apply parents_of_tree_spec in Hin.
+      destruct_conjs.
+      apply T.elements_complete in H. 
+      rewrite T.gsspec in H.
+      destruct_if.
+        auto with datatypes v62.
+
+        apply in_tree__in_parents_of_tree in H2.
+        auto with datatypes v62.
+
+      apply parents_of_tree_spec.
+      destruct_in Hin.
+        exists tt.
+        apply T.elements_correct.
+        rewrite T.gsspec.
+        destruct_if. 
+          congruence.
+
+        apply parents_of_tree_spec in Hin.
+        destruct_conjs.
+        exists Hin. 
+        apply T.elements_correct.
+        rewrite T.gsspec.
+        destruct_if. 
+          apply T.elements_complete in H.  
+          congruence.
+
+          apply T.elements_complete in H. auto.
+Qed.
+
+Lemma parents_of_empty_tree: forall A,
+  parents_of_tree (T.empty A) = nil.
+Proof. 
+  unfold parents_of_tree. 
+  intros.
+  remember (List.map fst (T.elements (T.empty A))) as R.
+  destruct R as [|e]; auto. 
+  assert (In e (List.map fst (T.elements (T.empty A)))) as Hin.
+    rewrite <- HeqR. auto with coqlib.
+  apply in_map_iff in Hin.
+  destruct_conjs.
+  apply T.elements_complete in H0.
+  rewrite T.gempty in H0.
+  congruence.
+Qed.
+
+Definition in_cfg successors n : Prop :=
+  In n (parents_of_tree successors) \/ 
+  In n (children_of_tree successors).
+
+Lemma in_parents_of_tree__in_cfg: forall scs n,
+  In n (parents_of_tree scs) -> in_cfg scs n.
+Proof. unfold in_cfg. auto. Qed.
+
+Lemma in_succ__in_cfg: forall p scs sc
+  (Hinscs : In sc scs !!! p),
+  in_cfg scs sc.
+Proof.
+  intros. right.
+  apply children_in_children_of_tree in Hinscs. auto.
+Qed.
+
+Lemma parents_of_tree__in_successors: forall A p (successors:T.t A),
+  In p (parents_of_tree successors) <-> exists s, successors ! p = Some s.
+Proof.
+  intros.
+  split; intro J.
+    apply parents_of_tree_spec in J.
+    destruct J as [? J].
+    apply T.elements_complete in J. eauto.
+
+    apply parents_of_tree_spec.
+    destruct J as [? J].
+    apply T.elements_correct in J. eauto.
+Qed.
+
+Lemma in_pred__in_parents: forall p scs n
+  (Hinprds : In p (make_predecessors scs) !!! n),
+  In p (parents_of_tree scs).
+Proof.
+  intros.
+  apply make_predecessors_correct' in Hinprds.
+  apply parents_of_tree_spec.
+  apply successors_list_spec in Hinprds.
+  destruct Hinprds as [scs0 [J1 J2]].
+  apply T.elements_correct in J1. eauto.
+Qed.
+
+Lemma nonleaf_is_parent: forall A succs x (Hnnil : succs !!! x <> @nil A),
+  In x (parents_of_tree succs).
+Proof.
+  intros.
+  apply parents_of_tree_spec.
+  assert (exists a, In a (succs!!!x)) as Hin.
+    destruct (succs!!!x) as [|a].
+      congruence.
+      exists a. simpl. auto.
+  destruct Hin as [a Hin].
+  apply successors_list_spec in Hin.
+  destruct Hin as [scs [J1 J2]].
+  apply T.elements_correct in J1.
+  eauto.
+Qed.
+
+Lemma children_of_tree_spec: forall A (l0:A) tr,
+  In l0 (children_of_tree tr) <-> 
+  exists a, exists scs, In (a, scs) (T.elements tr) /\ In l0 scs.
+Proof.
+  unfold children_of_tree.
+  intros.
+  split; intro J.
+    apply in_flat_map in J.
+    destruct J as [[x1 x2] [J1 J2]]. simpl in *. eauto.
+
+    apply in_flat_map.
+    destruct J as [y [xs J]]. exists (y, xs). auto.
+Qed.
+
+Lemma children_of_tree__in_successors: forall A (s:A) successors,
+  In s (children_of_tree successors) <-> 
+     exists p, exists scs, successors ! p = Some scs /\ In s scs.
+Proof.
+  intros.
+  split; intro J.
+    apply children_of_tree_spec in J.
+    destruct J as [? [? [J Hin]]].
+    apply T.elements_complete in J. eauto.
+
+    apply children_of_tree_spec.
+    destruct J as [? [? [J Hin]]].
+    apply T.elements_correct in J. eauto.
+Qed.
+
+Lemma successors_list_intro: forall (scss:T.t (list T.elt)) l0 scs 
+  (Hget: scss ! l0 = Some scs),
+  scss!!!l0 = scs.
+Proof.
+  unfold successors_list.
+  intros. rewrite Hget. auto.
+Qed.
+
+Lemma in_successors_list_intro: forall (scss:T.t (list T.elt)) l0 
+  sc scs (Hget: scss ! l0 = Some scs) (Hin: In sc scs),
+  In sc (scss!!!l0).
+Proof.
+  unfold successors_list.
+  intros. rewrite Hget. auto.
+Qed.
+
+Lemma has_succ__in_cfg: forall succs n sc 
+  (Hin: In sc (successors_list succs n)),
+  in_cfg succs n.
+Proof.
+  intros.
+  eapply in_parents_of_tree__in_cfg; eauto.
+  apply parents_of_tree__in_successors.
+  apply successors_list_spec in Hin.
+  destruct_conjs. eauto.
+Qed.
+
+Lemma in_cfg_dec: forall (Hdec: forall x y : T.elt, {x = y} + {x <> y})
+  successors n,  
+  in_cfg successors n \/ ~ in_cfg successors n.
+Proof.
+  unfold in_cfg.
+  intros.
+  destruct (In_dec Hdec n (parents_of_tree successors)) as [J1 | J1]; auto.
+  destruct (In_dec Hdec n (children_of_tree successors)) as [J2 | J2]; auto.
+  right. intro J. tauto.
+Qed.
+
+Lemma no_preds__notin_succs: forall successors entrypoint
+  (Hnopred: (make_predecessors successors) !!! entrypoint = nil),
+  forall a0
+    (Hin: In entrypoint (successors_list successors a0)), False.
+Proof.
+  intros. apply make_predecessors_correct in Hin. 
+  rewrite Hnopred in Hin. tauto.
+Qed.
+
+Section ElementsOfCfg.
+
+Variable successors: T.t (list T.elt).
+Hypothesis Hdec: forall x y : T.elt, {x = y} + {x <> y}.
+
+Definition elements_of_cfg: list T.elt :=
+  remove_redundancy Hdec nil 
+    (parents_of_tree successors ++ children_of_tree successors).
+
+Lemma in_elements_of_cfg__in_cfg: forall l0,
+  (In l0 (elements_of_cfg) <-> in_cfg successors l0).
+Proof.
+  intros.
+  split; intro J.
+    unfold elements_of_cfg in J.
+    apply remove_redundancy_in in J; auto.
+    unfold in_cfg.
+    destruct_in J; auto.
+
+    apply remove_redundancy_in; auto.
+    apply in_or_app.
+    destruct J; auto.  
+Qed.
+
+Lemma succs_in_elements_of_cfg: forall n, 
+  incl (successors_list successors n) elements_of_cfg.
+Proof.
+  intros.
+  unfold elements_of_cfg.
+  intros x Hin.
+  apply remove_redundancy_in; auto.
+    apply children_in_children_of_tree in Hin.
+    auto with datatypes v62.
+Qed.
+
+End ElementsOfCfg.
+
+End More_Tree_Properties.
+
+Module XATree := More_Tree_Properties(ATree).
+Module XPTree := More_Tree_Properties(PTree).
+Module ATree_Properties := Tree_Properties(ATree).
 Module PTree_Properties := Tree_Properties(PTree).
 
 (** * Useful notations *)
 
-Notation "a ! b" := (PTree.get b a) (at level 1).
-Notation "a !! b" := (PMap.get b a) (at level 1).
+Notation "a ! b" := (ATree.get b a) (at level 1).
+Notation "a !! b" := (AMap.get b a) (at level 1).
+Notation "a !!! b" := (XATree.successors_list a b) (at level 1).
+
+Notation "a ? b" := (PTree.get b a) (at level 1).
+Notation "a ?? b" := (PMap.get b a) (at level 1).
+Notation "a ??? b" := (XPTree.successors_list a b) (at level 1).
 
 (* $Id: Maps.v,v 1.12.4.4 2006/01/07 11:46:55 xleroy Exp $ *)
diff -ruN lib/compcert-1.9/Memdata.v lib.patched/compcert-1.9/Memdata.v
--- lib/compcert-1.9/Memdata.v	2014-08-30 20:09:04.806089049 -0400
+++ lib.patched/compcert-1.9/Memdata.v	2014-08-30 00:29:06.159588829 -0400
@@ -16,6 +16,7 @@
 
 (** In-memory representation of values. *)
 
+Require Import Znumtheory.
 Require Import Coqlib.
 Require Import AST.
 Require Import Integers.
@@ -28,13 +29,41 @@
   encoding the type, size and signedness of the chunk being addressed.
   The following functions extract the size information from a chunk. *)
 
+Definition Mint32 := Mint 31.
+
+Definition bytesize_chunk (wz:nat) := ZRdiv (Z_of_nat (S wz)) 8.
+Definition bytesize_chunk_nat (wz:nat) := nat_of_Z (bytesize_chunk wz).
+
+Lemma bytesize_chunk_pos:
+  forall wz, bytesize_chunk wz > 0.
+Proof.
+  intros. unfold bytesize_chunk.
+  apply ZRdiv_prop5.
+Qed.
+
+Lemma bytesize_chunk_conv:
+  forall wz, bytesize_chunk wz = Z_of_nat (bytesize_chunk_nat wz).
+Proof.
+  intros.
+  unfold bytesize_chunk, bytesize_chunk_nat, bytesize_chunk.
+  decEq. 
+  rewrite nat_of_Z_eq. auto.
+    apply ZRdiv_prop2; auto with zarith.
+Qed.
+
+Lemma bytesize_chunk_nat_pos:
+  forall wz, exists n, bytesize_chunk_nat wz = S n.
+Proof.
+  intros. 
+  generalize (bytesize_chunk_pos wz). rewrite bytesize_chunk_conv. 
+  destruct (bytesize_chunk_nat wz).
+  simpl; intros; omegaContradiction.
+  intros; exists n; auto.
+Qed.
+
 Definition size_chunk (chunk: memory_chunk) : Z :=
   match chunk with
-  | Mint8signed => 1
-  | Mint8unsigned => 1
-  | Mint16signed => 2
-  | Mint16unsigned => 2
-  | Mint32 => 4
+  | Mint wz => bytesize_chunk wz
   | Mfloat32 => 4
   | Mfloat64 => 8
   end.
@@ -42,7 +71,7 @@
 Lemma size_chunk_pos:
   forall chunk, size_chunk chunk > 0.
 Proof.
-  intros. destruct chunk; simpl; omega.
+  intros. destruct chunk; simpl; try solve [omega | apply bytesize_chunk_pos].
 Qed.
 
 Definition size_chunk_nat (chunk: memory_chunk) : nat :=
@@ -51,7 +80,7 @@
 Lemma size_chunk_conv:
   forall chunk, size_chunk chunk = Z_of_nat (size_chunk_nat chunk).
 Proof.
-  intros. destruct chunk; reflexivity.
+  intros. destruct chunk; try solve [reflexivity | apply bytesize_chunk_conv].
 Qed.
 
 Lemma size_chunk_nat_pos:
@@ -64,43 +93,205 @@
   intros; exists n; auto.
 Qed.
 
+Lemma size_chunk_nat_pos':
+  forall chunk, (size_chunk_nat chunk > 0)%nat.
+Proof.
+  intros.
+  destruct (@size_chunk_nat_pos chunk) as [n J].
+  rewrite J. omega.
+Qed.
+
 (** Memory reads and writes must respect alignment constraints:
   the byte offset of the location being addressed should be an exact
   multiple of the natural alignment for the chunk being addressed.
   This natural alignment is defined by the following 
   [align_chunk] function.  Some target architectures
-  (e.g. PowerPC and x86) have no alignment constraints, which we could
+  (e.g. the PowerPC) have no alignment constraints, which we could
   reflect by taking [align_chunk chunk = 1].  However, other architectures
   have stronger alignment requirements.  The following definition is
-  appropriate for PowerPC, ARM and x86. *)
+  appropriate for PowerPC and ARM. *)
 
 Definition align_chunk (chunk: memory_chunk) : Z := 
   match chunk with
-  | Mint8signed => 1
-  | Mint8unsigned => 1
-  | Mint16signed => 2
-  | Mint16unsigned => 2
+  | Mint wz => 
+    if le_lt_dec wz 31
+    then bytesize_chunk wz
+    else if zeq (bytesize_chunk wz) 8 then 4 else 1
   | _ => 4
   end.
 
 Lemma align_chunk_pos:
   forall chunk, align_chunk chunk > 0.
 Proof.
-  intro. destruct chunk; simpl; omega.
+  intro. destruct chunk; simpl; try omega.
+    destruct (le_lt_dec n 31); try omega.
+      apply bytesize_chunk_pos.
+      destruct (zeq (bytesize_chunk n) 8); omega.
 Qed.
 
+Lemma bytesize_chunk_7_eq_1 : bytesize_chunk 7 = 1.
+Proof. compute. auto. Qed.
+
+Lemma bytesize_chunk_31_eq_4 : bytesize_chunk 31 = 4.
+Proof. compute. auto. Qed.
+
+Lemma bytesize_chunk_63_eq_8 : bytesize_chunk 63 = 8.
+Proof. compute. auto. Qed.
+
 Lemma align_size_chunk_divides:
   forall chunk, (align_chunk chunk | size_chunk chunk).
 Proof.
-  intros. destruct chunk; simpl; try apply Zdivide_refl. exists 2; auto. 
+  intros. destruct chunk; simpl; try solve [
+    apply Zdivide_refl |
+    destruct (le_lt_dec n 31); auto with zarith |
+    exists 2; auto ]. 
+
+    destruct (le_lt_dec n 31); auto with zarith.
+    destruct (zeq (bytesize_chunk n) 8); auto with zarith.
+      rewrite e.
+      assert (8 = 2 * 4) as EQ. auto with zarith.
+      rewrite EQ.
+      apply Zdivide_factor_l.
+Qed.
+
+Lemma bytesize_chunk_le : forall n m,
+  (m <= n)%nat ->
+  bytesize_chunk m <= bytesize_chunk n.  
+Proof.
+  intros n m H.
+  unfold bytesize_chunk, ZRdiv.
+  simpl.
+  assert (Zpos (P_of_succ_nat m) <= Zpos (P_of_succ_nat n)) as A.
+    apply Zpos_P_of_succ_nat_mono; auto.
+
+  remember (Zpos (P_of_succ_nat m)) as z1.
+  remember (Zpos (P_of_succ_nat n)) as z2.
+  assert (z1 > 0) as C. rewrite Heqz1. auto with zarith.
+  clear - A C.
+  assert (z1 / 8 <= z2 / 8) as B.
+    apply Z_div_le; auto with zarith.
+  destruct (zeq (z1 mod 8) 0).
+    destruct (zeq (z2 mod 8) 0); auto with zarith.
+    destruct (zeq (z2 mod 8) 0); auto with zarith.
+      assert (z1 = 8*(z1/8) + (z1 mod 8)) as Z1.
+        apply Z_div_mod_eq; auto with zarith.
+      assert (z2 = 8*(z2/8) + (z2 mod 8)) as Z2.
+        apply Z_div_mod_eq; auto with zarith.
+      rewrite e in Z2.
+      assert (0 <= z1 mod 8 < 8) as D.
+        apply Z_mod_lt; auto with zarith.
+      destruct (Z_le_dec (z1 / 8 + 1) (z2 / 8)); auto.
+        contradict A.
+        rewrite Z1. rewrite Z2.
+        clear Z1 Z2 e. auto with zarith.
+Qed.
+ 
+Lemma bytesize_chunk_le_31 : forall n,
+  (n <= 31)%nat -> bytesize_chunk n <= 4.
+Proof.
+  intros. 
+  rewrite <- bytesize_chunk_31_eq_4.
+  apply bytesize_chunk_le; auto.
+Qed.
+
+Lemma bytesize_chunk_32_eq_5 : bytesize_chunk 32 = 5.
+Proof. compute. auto. Qed.
+
+Lemma bytesize_chunk_gt_31 : forall n,
+  (31 < n)%nat -> bytesize_chunk n > 4.
+Proof.
+  intros. 
+  assert ((32 <= n)%nat) as J. auto with zarith.
+  apply bytesize_chunk_le in J.
+  rewrite bytesize_chunk_32_eq_5 in J.
+  auto with zarith.
+Qed.
+
+Lemma bytesize_chunk_31_neq : forall n1 n2,
+  (n1 <= 31 < n2)%nat ->
+  bytesize_chunk n1 <> bytesize_chunk n2.
+Proof.
+  intros.
+  destruct H.
+  apply bytesize_chunk_le_31 in H.
+  apply bytesize_chunk_gt_31 in H0.
+  omega.
+Qed.
+
+Lemma bytesize_chunk_31_neq' : forall n1 n2,
+  (n1 <= 31 < n2)%nat ->
+  bytesize_chunk n2 <> bytesize_chunk n1.
+Proof.
+  intros.
+  destruct H.
+  apply bytesize_chunk_le_31 in H.
+  apply bytesize_chunk_gt_31 in H0.
+  omega.
+Qed.
+
+Lemma bytesize_chunk_neq : forall n1 n2,
+  (n1 <= 31)%nat -> (n2 > 31)%nat ->
+  bytesize_chunk n1 <> bytesize_chunk n2.
+Proof.
+  intros.
+  apply bytesize_chunk_le_31 in H.
+  apply bytesize_chunk_gt_31 in H0.
+  omega.
 Qed.
 
 Lemma align_chunk_compat:
   forall chunk1 chunk2,
-  size_chunk chunk1 = size_chunk chunk2 -> align_chunk chunk1 = align_chunk chunk2.
+  size_chunk chunk1 = size_chunk chunk2 -> 
+  align_chunk chunk1 = align_chunk chunk2.
 Proof.
   intros chunk1 chunk2. 
-  destruct chunk1; destruct chunk2; simpl; congruence.
+  destruct chunk1; destruct chunk2; simpl; try congruence; auto.
+    destruct (le_lt_dec n 31); auto.
+      destruct (le_lt_dec n0 31); auto.
+        intro. contradict H; auto using bytesize_chunk_31_neq.
+      destruct (le_lt_dec n0 31); auto.
+        intro. contradict H; auto using bytesize_chunk_31_neq'.
+
+    intro J.
+    destruct (zeq (bytesize_chunk n) 8); auto.
+      destruct (zeq (bytesize_chunk n0) 8); auto.
+        rewrite e in J. rewrite J in n1. contradict n1; auto.
+      destruct (zeq (bytesize_chunk n0) 8); auto.
+        rewrite e in J. rewrite J in n1. contradict n1; auto.
+
+    destruct (le_lt_dec n 31); auto.
+      apply bytesize_chunk_gt_31 in l.
+      intro. rewrite H in l. contradict l; omega.
+
+    intro J. rewrite J.
+    destruct (zeq 8 8) as [ | n']; try solve [contradict n'; auto].
+    destruct (le_lt_dec n 31); auto.
+      apply bytesize_chunk_le_31 in l.
+      rewrite J in l. contradict l. omega.
+
+    intro J. rewrite <- J.
+    destruct (zeq 4 8) as [e' | ]; try solve [inversion e'].
+    destruct (le_lt_dec n 31); auto.
+      apply bytesize_chunk_gt_31 in l.
+      rewrite J in l. contradict l. omega.
+
+    intro J. rewrite <- J.
+    destruct (zeq 8 8) as [ | n']; try solve [contradict n'; auto].
+    destruct (le_lt_dec n 31); auto.
+      apply bytesize_chunk_le_31 in l.
+      rewrite <- J in l. contradict l. omega.
+Qed.
+
+Definition chunk_eq (c1 c2:memory_chunk) : Prop :=
+  size_chunk c1 = size_chunk c2 /\
+  match c1, c2 with
+  | Mint wz1, Mint wz2 => wz1 = wz2
+  | _, _ => True
+  end.
+
+Lemma chunk_eq_refl : forall c, chunk_eq c c.
+Proof.
+  destruct c; split; auto.
 Qed.
 
 (** * Memory values *)
@@ -116,8 +307,9 @@
 
 Inductive memval: Type :=
   | Undef: memval
-  | Byte: byte -> memval
-  | Pointer: block -> int -> nat -> memval.
+  | Byte: nat -> byte -> memval
+  | Pointer: block -> int32 -> nat -> memval
+  | IPointer : int32 -> nat -> memval.
 
 (** * Encoding and decoding integers *)
 
@@ -127,13 +319,13 @@
 Fixpoint bytes_of_int (n: nat) (x: Z) {struct n}: list byte :=
   match n with
   | O => nil
-  | S m => Byte.repr x :: bytes_of_int m (x / 256)
+  | S m => Int.repr 7 x :: bytes_of_int m (x / 256)
   end.
 
 Fixpoint int_of_bytes (l: list byte): Z :=
   match l with
   | nil => 0
-  | b :: l' => Byte.unsigned b + int_of_bytes l' * 256
+  | b :: l' => Int.unsigned 7 b + int_of_bytes l' * 256
   end.
 
 Lemma length_bytes_of_int:
@@ -142,13 +334,13 @@
   induction n; simpl; intros. auto. decEq. auto.
 Qed.
 
+
 Lemma int_of_bytes_of_int:
   forall n x,
   int_of_bytes (bytes_of_int n x) = x mod (two_p (Z_of_nat n * 8)).
 Proof.
   induction n; intros.
   simpl. rewrite Zmod_1_r. auto.
-Opaque Byte.wordsize.
   rewrite inj_S. simpl.
   replace (Zsucc (Z_of_nat n) * 8) with (Z_of_nat n * 8 + 8) by omega.
   rewrite two_p_is_exp; try omega. 
@@ -156,14 +348,24 @@
   apply two_p_gt_ZERO. omega. apply two_p_gt_ZERO. omega.
 Qed.
 
+Lemma int_of_bytes_of_int_wz:
+  forall n wz x,
+  0 < Z_of_nat n ->
+  Int.repr wz (int_of_bytes (bytes_of_int n (Int.unsigned wz x))) = 
+  Int.zero_ext wz (Z_of_nat n * 8) x.
+Proof.
+  intros. rewrite int_of_bytes_of_int. 
+  rewrite <- (Int.repr_unsigned wz (Int.zero_ext wz (Z_of_nat n * 8) x)). 
+  decEq. symmetry. apply Int.zero_ext_mod; try solve [omega]. 
+Qed.
+
 Lemma int_of_bytes_of_int_2:
   forall n x,
   (n = 1 \/ n = 2)%nat ->
-  Int.repr (int_of_bytes (bytes_of_int n (Int.unsigned x))) = Int.zero_ext (Z_of_nat n * 8) x.
+  Int.repr 31 (int_of_bytes (bytes_of_int n (Int.unsigned 31 x))) = 
+    Int.zero_ext 31 (Z_of_nat n * 8) x.
 Proof.
-  intros. rewrite int_of_bytes_of_int. 
-  rewrite <- (Int.repr_unsigned (Int.zero_ext (Z_of_nat n * 8) x)). 
-  decEq. symmetry. apply Int.zero_ext_mod.
+  intros. apply int_of_bytes_of_int_wz.
   destruct H; subst n; compute; auto.
 Qed.
 
@@ -180,20 +382,46 @@
   rewrite two_p_is_exp; try omega. 
   intro EQM.
   simpl; decEq. 
-  apply Byte.eqm_samerepr. red. 
+  apply (Int.eqm_samerepr 7). red. 
   eapply Int.eqmod_divides; eauto. apply Zdivide_factor_l.
   apply IHn.
   destruct EQM as [k EQ]. exists k. rewrite EQ. 
   rewrite <- Z_div_plus_full_l. decEq. change (two_p 8) with 256. ring. omega.
 Qed.
 
+Lemma bytes_of_int_mod':
+  forall z x y,
+  z >= 0 ->
+  Int.eqmod (two_p (z * 8)) x y ->
+  bytes_of_int (nat_of_Z z) x =
+  bytes_of_int (nat_of_Z z) y.
+Proof.
+  intros.
+  rewrite <- (@nat_of_Z_eq z) in H0; auto.
+  apply bytes_of_int_mod; auto.
+Qed.
+
+Lemma bytes_of_int_prop1: forall n z,
+  (n > 0)%nat ->
+  exists b, exists bl, 
+    bytes_of_int n z = b::bl.
+Proof. 
+  destruct n; intros.
+    contradict H; omega.
+
+    simpl.
+    exists (Int.repr 7 z).
+    exists (bytes_of_int n (z/256)).
+    auto.
+Qed.
+
 Parameter big_endian: bool.
 
-Definition rev_if_be (l: list byte) : list byte :=
+Definition rev_if_be (A:Type) (l: list A) : list A :=
   if big_endian then List.rev l else l.
 
 Lemma rev_if_be_involutive:
-  forall l, rev_if_be (rev_if_be l) = l.
+  forall A l, rev_if_be A (rev_if_be A l) = l.
 Proof.
   intros; unfold rev_if_be; destruct big_endian. 
   apply List.rev_involutive. 
@@ -201,193 +429,111 @@
 Qed.
 
 Lemma rev_if_be_length:
-  forall l, length (rev_if_be l) = length l.
+  forall A l, length (rev_if_be A l) = length l.
 Proof.
   intros; unfold rev_if_be; destruct big_endian.
   apply List.rev_length.
   auto.
 Qed.
 
-Definition encode_int (c: memory_chunk) (x: int) : list byte :=
-  let n := Int.unsigned x in
-  rev_if_be (match c with
-  | Mint8signed | Mint8unsigned => bytes_of_int 1%nat n
-  | Mint16signed | Mint16unsigned => bytes_of_int 2%nat n
-  | Mint32 => bytes_of_int 4%nat n
+Definition encode_int (c:memory_chunk) (wz:nat) (x: Int.int wz) : list byte :=
+  let n := Int.unsigned wz x in
+  rev_if_be _ (match c with
+  | Mint wz0 => bytes_of_int (nat_of_Z (bytesize_chunk wz0)) 
+                             (Zmod n (Int.modulus wz0))
   | Mfloat32 => bytes_of_int 4%nat 0
   | Mfloat64 => bytes_of_int 8%nat 0
   end).
 
-Definition decode_int (c: memory_chunk) (b: list byte) : int :=
-  let b' := rev_if_be b in
-  match c with
-  | Mint8signed => Int.sign_ext 8 (Int.repr (int_of_bytes b'))
-  | Mint8unsigned => Int.zero_ext 8 (Int.repr (int_of_bytes b'))
-  | Mint16signed => Int.sign_ext 16 (Int.repr (int_of_bytes b'))
-  | Mint16unsigned => Int.zero_ext 16 (Int.repr (int_of_bytes b'))
-  | Mint32 => Int.repr (int_of_bytes b')
-  | Mfloat32 => Int.zero
-  | Mfloat64 => Int.zero
-  end.
+Definition decode_int (wz:nat) (b: list byte) : Int.int wz :=
+  let b' := rev_if_be _ b in Int.repr wz (int_of_bytes b').
+
+Definition decode_float32 (b: list byte) : Int.int 31 := Int.zero 31.
+
+Definition decode_float64 (b: list byte) : Int.int 63 := Int.zero 63.
 
 Lemma encode_int_length:
-  forall chunk n, length(encode_int chunk n) = size_chunk_nat chunk.
+  forall chunk wz x, length (encode_int chunk wz x) = size_chunk_nat chunk.
 Proof.
   intros. unfold encode_int. rewrite rev_if_be_length.
   destruct chunk; rewrite length_bytes_of_int; reflexivity.
 Qed.
 
 Lemma decode_encode_int:
-  forall c x,
-  decode_int c (encode_int c x) =
+  forall c wz x,
   match c with
-  | Mint8signed => Int.sign_ext 8 x
-  | Mint8unsigned => Int.zero_ext 8 x
-  | Mint16signed => Int.sign_ext 16 x
-  | Mint16unsigned => Int.zero_ext 16 x
-  | Mint32 => x
-  | Mfloat32 => Int.zero
-  | Mfloat64 => Int.zero
-  end.
-Proof.
-  intros. unfold decode_int, encode_int; destruct c; auto;
-  rewrite rev_if_be_involutive.
-  rewrite int_of_bytes_of_int_2; auto.
-  apply Int.sign_ext_zero_ext. compute; auto.
-  rewrite int_of_bytes_of_int_2; auto.
-  apply Int.zero_ext_idem. compute; auto.
-  rewrite int_of_bytes_of_int_2; auto.
-  apply Int.sign_ext_zero_ext. compute; auto.
-  rewrite int_of_bytes_of_int_2; auto.
-  apply Int.zero_ext_idem. compute; auto.
-  rewrite int_of_bytes_of_int. 
-  transitivity (Int.repr (Int.unsigned x)). 
-  apply Int.eqm_samerepr. apply Int.eqm_sym. apply Int.eqmod_mod. apply two_p_gt_ZERO. omega. 
-  apply Int.repr_unsigned.
-Qed.
-
-Lemma encode_int8_signed_unsigned: forall n,
-  encode_int Mint8signed n = encode_int Mint8unsigned n.
-Proof.
-  intros; reflexivity.
-Qed.
-
-Remark encode_8_mod:
-  forall x y,
-  Int.eqmod (two_p 8) (Int.unsigned x) (Int.unsigned y) ->
-  encode_int Mint8unsigned x = encode_int Mint8unsigned y.
-Proof.
-  intros. unfold encode_int. decEq. apply bytes_of_int_mod. auto.
-Qed.
-
-Lemma encode_int8_zero_ext:
-  forall x,
-  encode_int Mint8unsigned (Int.zero_ext 8 x) = encode_int Mint8unsigned x.
-Proof.
-  intros. apply encode_8_mod. apply Int.eqmod_zero_ext. compute; auto.
-Qed.
-
-Lemma encode_int8_sign_ext:
-  forall x,
-  encode_int Mint8signed (Int.sign_ext 8 x) = encode_int Mint8signed x.
-Proof.
-  intros. repeat rewrite encode_int8_signed_unsigned. 
-  apply encode_8_mod. eapply Int.eqmod_trans.
-  apply Int.eqm_eqmod_two_p. compute; auto. 
-  apply Int.eqm_sym. apply Int.eqm_signed_unsigned.
-  apply Int.eqmod_sign_ext. compute; auto.
-Qed.
-
-Lemma encode_int16_signed_unsigned: forall n,
-  encode_int Mint16signed n = encode_int Mint16unsigned n.
-Proof.
-  intros; reflexivity.
-Qed.
-
-Remark encode_16_mod:
-  forall x y,
-  Int.eqmod (two_p 16) (Int.unsigned x) (Int.unsigned y) ->
-  encode_int Mint16unsigned x = encode_int Mint16unsigned y.
-Proof.
-  intros. unfold encode_int. decEq. apply bytes_of_int_mod. auto.
-Qed.
-
-Lemma encode_int16_zero_ext:
-  forall x,
-  encode_int Mint16unsigned (Int.zero_ext 16 x) = encode_int Mint16unsigned x.
-Proof.
-  intros. apply encode_16_mod. apply Int.eqmod_zero_ext. compute; auto.
-Qed.
-
-Lemma encode_int16_sign_ext:
-  forall x,
-  encode_int Mint16signed (Int.sign_ext 16 x) = encode_int Mint16signed x.
-Proof.
-  intros. repeat rewrite encode_int16_signed_unsigned. 
-  apply encode_16_mod. eapply Int.eqmod_trans.
-  apply Int.eqm_eqmod_two_p. compute; auto. 
-  apply Int.eqm_sym. apply Int.eqm_signed_unsigned.
-  apply Int.eqmod_sign_ext. compute; auto.
-Qed.
-
-Lemma decode_int8_zero_ext:
-  forall l,
-  Int.zero_ext 8 (decode_int Mint8unsigned l) = decode_int Mint8unsigned l.
-Proof.
-  intros; simpl. apply Int.zero_ext_idem. vm_compute; auto.
-Qed.
-
-Lemma decode_int8_sign_ext:
-  forall l,
-  Int.sign_ext 8 (decode_int Mint8signed l) = decode_int Mint8signed l.
-Proof.
-  intros; simpl. apply Int.sign_ext_idem. vm_compute; auto.
-Qed.
-
-Lemma decode_int16_zero_ext:
-  forall l,
-  Int.zero_ext 16 (decode_int Mint16unsigned l) = decode_int Mint16unsigned l.
-Proof.
-  intros; simpl. apply Int.zero_ext_idem. vm_compute; auto.
-Qed.
-
-Lemma decode_int16_sign_ext:
-  forall l,
-  Int.sign_ext 16 (decode_int Mint16signed l) = decode_int Mint16signed l.
-Proof.
-  intros; simpl. apply Int.sign_ext_idem. vm_compute; auto.
-Qed.
-
-Lemma decode_int8_signed_unsigned:
-  forall l,
-  decode_int Mint8signed l = Int.sign_ext 8 (decode_int Mint8unsigned l).
+  | Mint wz0 => 
+      decode_int wz0 (encode_int c wz x) = Int.repr wz0 (Int.unsigned wz x)
+  | Mfloat32 => decode_float32 (encode_int c wz x) = Int.zero 31
+  | Mfloat64 => decode_float64 (encode_int c wz x) = Int.zero 63
+  end.
 Proof.
-  intros; simpl. rewrite Int.sign_ext_zero_ext; auto. vm_compute; auto.
-Qed.
+  intros. 
+  unfold decode_int, encode_int, decode_float32, decode_float64; destruct c; 
+  auto; rewrite rev_if_be_involutive.
 
-Lemma decode_int16_signed_unsigned:
-  forall l,
-  decode_int Mint16signed l = Int.sign_ext 16 (decode_int Mint16unsigned l).
-Proof.
-  intros; simpl. rewrite Int.sign_ext_zero_ext; auto. vm_compute; auto.
+  rewrite int_of_bytes_of_int.
+  assert (J:=@bytesize_chunk_pos n).
+  rewrite nat_of_Z_eq; try omega.
+  apply Int.eqm_samerepr. 
+  unfold Int.eqm, Int.eqmod.
+  unfold Int.modulus.
+  unfold Int.wordsize.
+  unfold bytesize_chunk.  
+  assert (8 > 0) as J'. omega.
+  assert (J1:=@ZRdiv_prop1 (Z_of_nat (S n)) 8 J').
+  assert (8 * ZRdiv (Z_of_nat (S n)) 8 = ZRdiv (Z_of_nat (S n)) 8 * 8) as EQ.
+    auto with zarith.
+  rewrite EQ in J1. clear EQ.
+  assert (J2:=Z_of_S_gt_O n).
+  assert (two_power_nat (S n) = two_p (Z_of_nat (S n))) as EQ.
+    simpl.
+    rewrite two_power_pos_nat.
+    rewrite S_eq_nat_of_P_o_P_of_succ_nat. auto.
+
+  rewrite EQ. clear EQ.
+  (* 
+     let m1 = ZRdiv (Z_of_nat (S n)) 8 * 8
+     let m2 = S n
+     k1 + k0 % (2^m1) = k * 2^m2 + (2^m2 * k2 + k1)
+     so,
+     k0 % (2^m1) = k * 2^m2 + 2^m2 * k2
+     so (- 2^(m1-m2) * k0 - k2) is the witness
+  *) 
+  remember (ZRdiv (Z_of_nat (S n)) 8 * 8) as m1.
+  remember (Z_of_nat (S n)) as m2.    
+
+  rewrite Zmod_eq with (a:=Int.unsigned wz x mod two_p m2) (b:=two_p m1);
+    try solve [apply two_p_gt_ZERO; auto with zarith].
+  remember (Int.unsigned wz x mod two_p m2) as k1.
+  rewrite Z_div_mod_eq with (a:=Int.unsigned wz x) (b:=two_p m2);
+    try solve [apply two_p_gt_ZERO; auto with zarith].
+  rewrite <- Heqk1.
+  remember (k1 / two_p m1) as k0.
+  remember (Int.unsigned wz x / two_p m2) as k2.
+  exists ( - two_p (m1 - m2) * k0 - k2).
+  ring_simplify.
+  rewrite <- Zmult_assoc.
+  rewrite <- two_p_is_exp; auto with zarith.
+  assert (m1 = m1 - m2 + m2) as EQ. auto with zarith.
+  rewrite <- EQ. clear EQ.
+  auto.
 Qed.
 
 (** * Encoding and decoding floats *)
 
 Definition encode_float (c: memory_chunk) (f: float) : list byte :=
-  rev_if_be (match c with
-  | Mint8signed | Mint8unsigned => bytes_of_int 1%nat 0
-  | Mint16signed | Mint16unsigned => bytes_of_int 2%nat 0
-  | Mint32 => bytes_of_int 4%nat 0
-  | Mfloat32 => bytes_of_int 4%nat (Int.unsigned (Float.bits_of_single f))
-  | Mfloat64 => bytes_of_int 8%nat (Int64.unsigned (Float.bits_of_double f))
+  rev_if_be _ (match c with
+  | Mint wz => bytes_of_int (bytesize_chunk_nat wz) 0
+  | Mfloat32 => bytes_of_int 4%nat (Int.unsigned 31 (Float.bits_of_single f))
+  | Mfloat64 => bytes_of_int 8%nat (Int.unsigned 63 (Float.bits_of_double f))
   end).
 
 Definition decode_float (c: memory_chunk) (b: list byte) : float :=
-  let b' := rev_if_be b in
+  let b' := rev_if_be _ b in
   match c with
-  | Mfloat32 => Float.single_of_bits (Int.repr (int_of_bytes b'))
-  | Mfloat64 => Float.double_of_bits (Int64.repr (int_of_bytes b'))
+  | Mfloat32 => Float.single_of_bits (Int.repr 31 (int_of_bytes b'))
+  | Mfloat64 => Float.double_of_bits (Int.repr 63 (int_of_bytes b'))
   | _ => Float.zero
   end.
 
@@ -396,7 +542,10 @@
 Proof.
   unfold encode_float; intros. 
   rewrite rev_if_be_length. 
-  destruct chunk; apply length_bytes_of_int. 
+  destruct chunk; try solve [
+    apply length_bytes_of_int |
+    unfold size_chunk_nat, size_chunk;
+      rewrite Z_of_nat_eq; apply length_bytes_of_int].
 Qed.
 
 Lemma decode_encode_float32: forall n,
@@ -406,7 +555,7 @@
   rewrite rev_if_be_involutive. 
   rewrite int_of_bytes_of_int. rewrite <- Float.single_of_bits_of_single. 
   decEq. 
-  transitivity (Int.repr (Int.unsigned (Float.bits_of_single n))). 
+  transitivity (Int.repr 31 (Int.unsigned 31 (Float.bits_of_single n))). 
   apply Int.eqm_samerepr. apply Int.eqm_sym. apply Int.eqmod_mod. apply two_p_gt_ZERO. omega. 
   apply Int.repr_unsigned.
 Qed.
@@ -418,22 +567,10 @@
   rewrite rev_if_be_involutive. 
   rewrite int_of_bytes_of_int.
   set (x := Float.bits_of_double n).
-  transitivity (Float.double_of_bits(Int64.repr (Int64.unsigned x))).
+  transitivity (Float.double_of_bits(Int.repr 63 (Int.unsigned 63 x))).
   decEq. 
-  apply Int64.eqm_samerepr. apply Int64.eqm_sym. apply Int64.eqmod_mod. apply two_p_gt_ZERO. omega. 
-  rewrite Int64.repr_unsigned. apply Float.double_of_bits_of_double.
-Qed.
-
-Lemma encode_float8_signed_unsigned: forall n,
-  encode_float Mint8signed n = encode_float Mint8unsigned n.
-Proof.
-  intros. reflexivity. 
-Qed.
-
-Lemma encode_float16_signed_unsigned: forall n,
-  encode_float Mint16signed n = encode_float Mint16unsigned n.
-Proof.
-  intros. reflexivity.
+  apply Int.eqm_samerepr. apply Int.eqm_sym. apply Int.eqmod_mod. apply two_p_gt_ZERO. omega. 
+  rewrite Int.repr_unsigned. apply Float.double_of_bits_of_double.
 Qed.
 
 Lemma encode_float32_cast:
@@ -453,50 +590,59 @@
 
 (** * Encoding and decoding values *)
 
-Definition inj_bytes (bl: list byte) : list memval :=
-  List.map Byte bl.
+Definition inj_bytes (wz:nat) (bl: list byte) : list memval :=
+  List.map (Byte wz) bl.
 
-Fixpoint proj_bytes (vl: list memval) : option (list byte) :=
+Fixpoint proj_bytes (wz:nat) (vl: list memval) : option (list byte) :=
   match vl with
   | nil => Some nil
-  | Byte b :: vl' =>
-      match proj_bytes vl' with None => None | Some bl => Some(b :: bl) end
+  | Byte wz0 b :: vl' =>
+      if eq_nat_dec wz0 wz then
+        match proj_bytes wz vl' with None => None | Some bl => Some(b :: bl) end
+      else None
   | _ => None
   end.
 
 Remark length_inj_bytes:
-  forall bl, length (inj_bytes bl) = length bl.
+  forall wz bl, length (inj_bytes wz bl) = length bl.
 Proof.
-  intros. apply List.map_length. 
+  intros. apply List.map_length.
 Qed.
 
 Remark proj_inj_bytes:
-  forall bl, proj_bytes (inj_bytes bl) = Some bl.
+  forall wz bl, proj_bytes wz (inj_bytes wz bl) = Some bl.
 Proof.
-  induction bl; simpl. auto. rewrite IHbl. auto.
+  induction bl; simpl; auto. 
+    rewrite IHbl.
+    destruct (eq_nat_dec wz wz); auto.
+      contradict n; auto.
 Qed.
 
 Lemma inj_proj_bytes:
-  forall cl bl, proj_bytes cl = Some bl -> cl = inj_bytes bl.
+  forall wz cl bl, proj_bytes wz cl = Some bl -> cl = inj_bytes wz bl.
 Proof.
-  induction cl; simpl; intros. 
+  induction cl; simpl; intros.
   inv H; auto.
-  destruct a; try congruence. destruct (proj_bytes cl); inv H.
+  destruct a; try congruence.
+  destruct (eq_nat_dec n wz); try solve [inv H].
+  destruct (proj_bytes wz cl); inv H.
   simpl. decEq. auto.
 Qed.
 
-Fixpoint inj_pointer (n: nat) (b: block) (ofs: int) {struct n}: list memval :=
+Fixpoint inj_pointer (n: nat) (b: block) (ofs: Int.int 31) {struct n} 
+  : list memval :=
   match n with
   | O => nil
   | S m => Pointer b ofs m :: inj_pointer m b ofs
   end.
 
-Fixpoint check_pointer (n: nat) (b: block) (ofs: int) (vl: list memval) 
+Fixpoint check_pointer (n: nat) (b: block) (ofs: Int.int 31) (vl: list memval) 
                        {struct n} : bool :=
   match n, vl with
   | O, nil => true
   | S m, Pointer b' ofs' m' :: vl' =>
-      eq_block b b' && Int.eq_dec ofs ofs' && beq_nat m m' && check_pointer m b ofs vl'
+      eq_block b b' && Int.eq_dec 31 ofs ofs' && beq_nat m m' && 
+      check_pointer m b ofs vl'
   | _, _ => false
   end.
 
@@ -509,27 +655,94 @@
   | _ => Vundef
   end.
 
+Lemma inj_pointer_length:
+  forall b ofs n, List.length(inj_pointer n b ofs) = n.
+Proof.
+  induction n; simpl; congruence.
+Qed.
+
+Lemma check_inj_pointer:
+  forall b ofs n, check_pointer n b ofs (inj_pointer n b ofs) = true.
+Proof.
+  induction n; simpl. auto. 
+  unfold proj_sumbool. rewrite dec_eq_true. rewrite dec_eq_true.  
+  rewrite <- beq_nat_refl. simpl; auto.
+Qed.
+
+Fixpoint inj_ipointer (n: nat) (i: Int.int 31) {struct n}: list memval :=
+  match n with
+  | O => nil
+  | S m => IPointer i m :: inj_ipointer m i
+  end.
+
+Fixpoint check_ipointer (n: nat) (i: Int.int 31) (vl: list memval) {struct n} 
+  : bool :=
+  match n, vl with
+  | O, nil => true
+  | S m, IPointer i' m':: vl' =>
+      Int.eq_dec 31 i i' && beq_nat m m' && check_ipointer m i vl'
+  | _, _ => false
+  end.
+
+Definition proj_ipointer (vl: list memval) : val :=
+  match vl with
+  | IPointer i n :: vl' =>
+      if check_ipointer (size_chunk_nat Mint32) i vl
+      then Vinttoptr i
+      else Vundef
+  | _ => Vundef
+  end.
+
+Lemma inj_ipointer_length:
+  forall i n, List.length(inj_ipointer n i) = n.
+Proof.
+  induction n; simpl; congruence.
+Qed.
+
+Lemma check_inj_ipointer:
+  forall i n, check_ipointer n i (inj_ipointer n i) = true.
+Proof.
+  induction n; simpl. auto. 
+  unfold proj_sumbool. rewrite dec_eq_true.  
+  rewrite <- beq_nat_refl. simpl; auto.
+Qed.
+
+Definition wz_of_chunk (chunk: memory_chunk) : nat :=
+  match chunk with
+  | Mint wz => wz
+  | Mfloat32 => 31%nat
+  | Mfloat64 => 63%nat
+  end.
+  
 Definition encode_val (chunk: memory_chunk) (v: val) : list memval :=
   match v, chunk with
-  | Vptr b ofs, Mint32 => inj_pointer (size_chunk_nat Mint32) b ofs
-  | Vint n, _ => inj_bytes (encode_int chunk n)
-  | Vfloat f, _ => inj_bytes (encode_float chunk f)
+  | Vptr b ofs, Mint wz => 
+      if (eq_nat_dec wz 31) then inj_pointer (size_chunk_nat (Mint32)) b ofs
+      else list_repeat (size_chunk_nat chunk) Undef
+  | Vinttoptr i, Mint wz => 
+      if (eq_nat_dec wz 31) then inj_ipointer (size_chunk_nat (Mint wz)) i
+      else list_repeat (size_chunk_nat chunk) Undef
+  | Vint wz n, _ => inj_bytes (wz_of_chunk chunk) (encode_int chunk wz n)
+  | Vfloat f, _ => inj_bytes (wz_of_chunk chunk) (encode_float chunk f)
   | _, _ => list_repeat (size_chunk_nat chunk) Undef
   end.
 
 Definition decode_val (chunk: memory_chunk) (vl: list memval) : val :=
-  match proj_bytes vl with
+  match proj_bytes (wz_of_chunk chunk) vl with
   | Some bl =>
       match chunk with
-      | Mint8signed | Mint8unsigned
-      | Mint16signed | Mint16unsigned | Mint32 =>
-          Vint(decode_int chunk bl)
-      | Mfloat32 | Mfloat64 =>
-          Vfloat(decode_float chunk bl)
+      | Mint _ => Vint (wz_of_chunk chunk) (decode_int (wz_of_chunk chunk) bl)
+      | Mfloat32 | Mfloat64 => Vfloat(decode_float chunk bl)
       end
   | None =>
       match chunk with
-      | Mint32 => proj_pointer vl
+      | Mint wz => 
+          if eq_nat_dec wz 31 then
+            match proj_pointer vl with
+            | Vundef => proj_ipointer vl
+            | v => v
+            end
+          else Vundef 
       | _ => Vundef
       end
   end.
@@ -537,116 +750,317 @@
 Lemma encode_val_length:
   forall chunk v, length(encode_val chunk v) = size_chunk_nat chunk.
 Proof.
-  intros. destruct v; simpl. 
+  intros. destruct v; simpl.
   apply length_list_repeat.
   rewrite length_inj_bytes. apply encode_int_length.
   rewrite length_inj_bytes. apply encode_float_length.
-  destruct chunk; try (apply length_list_repeat). reflexivity.
-Qed.
 
-Lemma check_inj_pointer:
-  forall b ofs n, check_pointer n b ofs (inj_pointer n b ofs) = true.
-Proof.
-  induction n; simpl. auto. 
-  unfold proj_sumbool. rewrite dec_eq_true. rewrite dec_eq_true.  
-  rewrite <- beq_nat_refl. simpl; auto.
+  destruct chunk; try (apply length_list_repeat). 
+    destruct (eq_nat_dec n 31); subst; auto.
+      apply length_list_repeat.
+
+  destruct chunk; try (apply length_list_repeat). 
+    destruct (eq_nat_dec n 31); subst; auto.
+      apply length_list_repeat.
 Qed.
 
-Definition decode_encode_val (v1: val) (chunk1 chunk2: memory_chunk) (v2: val) : Prop :=
+Definition decode_encode_val (v1: val) (chunk1 chunk2: memory_chunk) (v2: val) 
+  : Prop :=
   match v1, chunk1, chunk2 with
   | Vundef, _, _ => v2 = Vundef
-  | Vint n, Mint8signed, Mint8signed => v2 = Vint(Int.sign_ext 8 n)
-  | Vint n, Mint8unsigned, Mint8signed => v2 = Vint(Int.sign_ext 8 n)
-  | Vint n, Mint8signed, Mint8unsigned => v2 = Vint(Int.zero_ext 8 n)
-  | Vint n, Mint8unsigned, Mint8unsigned => v2 = Vint(Int.zero_ext 8 n)
-  | Vint n, Mint16signed, Mint16signed => v2 = Vint(Int.sign_ext 16 n)
-  | Vint n, Mint16unsigned, Mint16signed => v2 = Vint(Int.sign_ext 16 n)
-  | Vint n, Mint16signed, Mint16unsigned => v2 = Vint(Int.zero_ext 16 n)
-  | Vint n, Mint16unsigned, Mint16unsigned => v2 = Vint(Int.zero_ext 16 n)
-  | Vint n, Mint32, Mint32 => v2 = Vint n
-  | Vint n, Mint32, Mfloat32 => v2 = Vfloat(decode_float Mfloat32 (encode_int Mint32 n))
-  | Vint n, _, _ => True   (* nothing interesting to say about v2 *)
-  | Vptr b ofs, Mint32, Mint32 => v2 = Vptr b ofs
+  | Vint wz n, Mint wz1, Mint wz2 => 
+      if eq_nat_dec wz1 wz2 then 
+        v2 = Vint wz2 (Int.repr wz2 (Int.unsigned wz n)) 
+      else True
+  | Vint wz n, Mint wz', Mfloat32 => 
+      if eq_nat_dec wz' 31
+      then v2 = Vfloat(decode_float Mfloat32 (encode_int (Mint32) wz n))
+      else True
+  | Vint wz n, _, _ => True   (* nothing interesting to say about v2 *)
+  | Vptr b ofs, Mint wz1, Mint wz2 => 
+      if eq_nat_dec wz1 31 && eq_nat_dec wz2 31 
+      then v2 = Vptr b ofs else v2 = Vundef
   | Vptr b ofs, _, _ => v2 = Vundef
+  | Vinttoptr i, Mint wz1, Mint wz2 => 
+      if eq_nat_dec wz1 31 && eq_nat_dec wz2 31
+      then v2 = Vinttoptr i else v2 = Vundef
+  | Vinttoptr i, _, _ => v2 = Vundef
   | Vfloat f, Mfloat32, Mfloat32 => v2 = Vfloat(Float.singleoffloat f)
-  | Vfloat f, Mfloat32, Mint32 => v2 = Vint(decode_int Mint32 (encode_float Mfloat32 f))
+  | Vfloat f, Mfloat32, Mint wz => 
+      if eq_nat_dec wz 31
+      then v2 = Vint 31 (decode_int 31 (encode_float Mfloat32 f))
+      else True
   | Vfloat f, Mfloat64, Mfloat64 => v2 = Vfloat f
   | Vfloat f, _, _ => True   (* nothing interesting to say about v2 *)
   end.
 
+Lemma proj_bytes_inj_pointer:
+  forall wz n b i, (n > 0)%nat -> proj_bytes wz (inj_pointer n b i) = None.
+Proof.
+  induction n; simpl; auto. 
+    intros. contradict H; omega.
+Qed.
+
+Lemma inj_pointer_inv : forall n b i,
+  (n > 0)%nat -> 
+  exists m, exists tl, inj_pointer n b i = Pointer b i m :: tl /\ n = S m.
+Proof.
+  destruct n; intros.
+    contradict H; omega.
+    simpl. exists n. exists (inj_pointer n b i). auto.
+Qed.
+
+Lemma bytesize_chunk_nat__size_chunk_nat : forall n,
+  size_chunk_nat (Mint n) = bytesize_chunk_nat n.
+Proof.
+  intros. 
+  unfold size_chunk_nat, bytesize_chunk_nat, size_chunk, bytesize_chunk.
+  auto.
+Qed.
+
+Lemma list_repeat_cons_inv : forall A m (a:A) b v,
+  a :: b = list_repeat m v ->
+  a = v /\
+  exists m', S m' = m /\ b = list_repeat m' v.
+Proof.
+  induction m; intros; simpl in *.
+    inversion H.
+
+    inversion H; subst.
+    split; auto.
+    exists m. split; auto.
+Qed.
+
+Lemma nonempty_list_repeat : forall A m (v:A),
+  (m > 0)%nat -> nil <> list_repeat m v.
+Proof.
+  induction m; simpl; intros.
+    contradict H; omega.
+    intro J. inversion J.
+Qed.
+
+Lemma proj_bytes_undef' : forall n m,
+  (m > 0)%nat ->
+  proj_bytes n (list_repeat m Undef) = None.
+Proof.
+  intros.
+  remember (list_repeat m Undef) as L.
+  generalize dependent m.
+  generalize dependent n.
+  induction L; intros; simpl.
+    contradict HeqL.
+    apply nonempty_list_repeat; auto.
+
+    apply list_repeat_cons_inv in HeqL.
+    destruct HeqL as [H1 [m' [H2 H3]]]; subst; auto.
+Qed.
+
+Remark proj_pointer_undef':
+  forall n, proj_pointer (list_repeat n Undef) = Vundef.
+Proof.
+  induction n; simpl; auto.
+Qed.
+
+Remark proj_ipointer_undef':
+  forall n, proj_ipointer (list_repeat n Undef) = Vundef.
+Proof.
+  induction n; simpl; auto.
+Qed.
+
+Lemma proj_pointer_inj_pointer:
+  forall b i, proj_pointer (inj_pointer (size_chunk_nat Mint32) b i) = Vptr b i.
+Proof.
+  intros.
+  Opaque check_pointer. 
+  simpl.
+  rewrite check_inj_pointer. auto.
+  Transparent check_pointer. 
+Qed.
+
+Lemma proj_bytes_inj_ipointer:
+  forall wz n i, (n > 0)%nat -> proj_bytes wz (inj_ipointer n i) = None.
+Proof.
+  induction n; simpl; intros; auto. 
+    contradict H; omega.
+Qed.
+
+Lemma proj_pointer_inj_ipointer:
+  forall i, proj_pointer (inj_ipointer (size_chunk_nat Mint32) i) = Vundef.
+Proof.
+  intros. simpl. auto.
+Qed.
+
+Lemma proj_ipointer_inj_ipointer:
+  forall i, proj_ipointer (inj_ipointer (size_chunk_nat Mint32) i) = Vinttoptr i.
+Proof.
+  intros.
+  Opaque check_ipointer. 
+  simpl.
+  rewrite check_inj_ipointer. auto.
+  Transparent check_ipointer. 
+Qed.
+
 Lemma decode_encode_val_general:
   forall v chunk1 chunk2,
   decode_encode_val v chunk1 chunk2 (decode_val chunk2 (encode_val chunk1 v)).
 Proof.
   intros. destruct v.
 (* Vundef *)
-  simpl. destruct (size_chunk_nat_pos chunk1) as [psz EQ]. 
+  simpl. destruct (size_chunk_nat_pos chunk1) as [psz EQ].
   rewrite EQ. simpl.
-  unfold decode_val. simpl. destruct chunk2; auto.
+  unfold decode_val. simpl. 
+  destruct chunk2; auto.
+  destruct (eq_nat_dec n 31); auto.
 (* Vint *)
   simpl.
-  destruct chunk1; auto; destruct chunk2; auto; unfold decode_val;
-  rewrite proj_inj_bytes.
-  rewrite decode_encode_int. auto.
-  rewrite encode_int8_signed_unsigned. rewrite decode_encode_int. auto.
-  rewrite <- encode_int8_signed_unsigned.  rewrite decode_encode_int. auto.
-  rewrite decode_encode_int. auto.
-  rewrite decode_encode_int. auto.
-  rewrite encode_int16_signed_unsigned. rewrite decode_encode_int. auto.
-  rewrite <- encode_int16_signed_unsigned.  rewrite decode_encode_int. auto.
-  rewrite decode_encode_int. auto.
-  rewrite decode_encode_int. auto.
-  reflexivity. 
+  destruct chunk1; auto; destruct chunk2; auto; unfold decode_val; simpl.
+    destruct (eq_nat_dec n n0); subst; simpl; auto.
+      rewrite proj_inj_bytes.
+      rewrite decode_encode_int with (c:=Mint n0). auto.
+
+    destruct (eq_nat_dec n 31); subst; auto.
+    rewrite proj_inj_bytes. auto.
 (* Vfloat *)
   unfold decode_val, encode_val, decode_encode_val;
-  destruct chunk1; auto; destruct chunk2; auto; unfold decode_val;
-  rewrite proj_inj_bytes.
-  auto.
-  rewrite decode_encode_float32. auto.
-  rewrite decode_encode_float64. auto.
+  destruct chunk1; auto; destruct chunk2; auto; unfold decode_val.
+    destruct (eq_nat_dec n 31); subst; auto.
+    rewrite proj_inj_bytes. auto.
+
+    rewrite proj_inj_bytes. 
+    rewrite decode_encode_float32. auto.
+
+    rewrite proj_inj_bytes. 
+    rewrite decode_encode_float64. auto.
 (* Vptr *)
+  assert (J:=@size_chunk_nat_pos' chunk1).
   unfold decode_val, encode_val, decode_encode_val;
   destruct chunk1; auto; destruct chunk2; auto.
-  simpl. generalize (check_inj_pointer b i (size_chunk_nat Mint32)).
-  simpl. intro. rewrite H. auto.
+    destruct (eq_nat_dec n 31); subst; auto.
+      rewrite proj_bytes_inj_pointer; auto using size_chunk_nat_pos'.
+      rewrite proj_pointer_inj_pointer.
+      destruct (eq_nat_dec n0 31); subst; simpl; auto.
+ 
+      simpl. rewrite proj_bytes_undef'; auto. rewrite proj_pointer_undef'.
+      rewrite proj_ipointer_undef'.
+      destruct (eq_nat_dec n0 31); subst; simpl; auto.
+    destruct (eq_nat_dec n 31); subst; auto.
+       rewrite proj_bytes_undef'; auto. 
+    destruct (eq_nat_dec n 31); subst; auto.
+      rewrite proj_bytes_undef'; auto. 
+    rewrite proj_bytes_undef'; auto.
+    destruct (eq_nat_dec n 31); subst; auto.
+    rewrite proj_bytes_undef'; auto.
+    destruct (eq_nat_dec n 31); subst; auto.
+(* Vint2ptr *)
+  assert (J:=@size_chunk_nat_pos' chunk1).
+  unfold decode_val, encode_val, decode_encode_val;
+  destruct chunk1; auto; destruct chunk2; auto.
+    destruct (eq_nat_dec n 31); subst; auto.
+      rewrite proj_bytes_inj_ipointer; auto using size_chunk_nat_pos'.
+      rewrite proj_pointer_inj_ipointer.
+      rewrite proj_ipointer_inj_ipointer.
+      destruct (eq_nat_dec n0 31); subst; simpl; auto.
+ 
+      simpl. rewrite proj_bytes_undef'; auto. rewrite proj_pointer_undef'.
+      rewrite proj_ipointer_undef'.
+      destruct (eq_nat_dec n0 31); subst; simpl; auto.
+    destruct (eq_nat_dec n 31); subst; auto.
+       rewrite proj_bytes_undef'; auto. 
+    destruct (eq_nat_dec n 31); subst; auto.
+      rewrite proj_bytes_undef'; auto. 
+    rewrite proj_bytes_undef'; auto.
+    destruct (eq_nat_dec n 31); subst; auto.
+    rewrite proj_bytes_undef'; auto.
+    destruct (eq_nat_dec n 31); subst; auto.
 Qed.
 
 Lemma decode_encode_val_similar:
   forall v1 chunk1 chunk2 v2,
   type_of_chunk chunk1 = type_of_chunk chunk2 ->
-  size_chunk chunk1 = size_chunk chunk2 ->
+  chunk_eq chunk1 chunk2 ->
   Val.has_type v1 (type_of_chunk chunk1) ->
   decode_encode_val v1 chunk1 chunk2 v2 ->
   v2 = Val.load_result chunk2 v1.
 Proof.
-  intros. 
+  intros.
   destruct v1.
-  simpl in *. destruct chunk2; simpl; auto. 
+  simpl in *. destruct chunk2; simpl; auto.
+
+  red in H1.
+  destruct chunk1; simpl in H1; try contradiction;
+  destruct chunk2; simpl in *; discriminate || auto.
+  unfold chunk_eq in H0. destruct H0; subst.
+  destruct (eq_nat_dec n0 n0); auto.
+    contradict n; auto.
+
+  unfold chunk_eq in H0. destruct H0.
   red in H1.
   destruct chunk1; simpl in H1; try contradiction;
   destruct chunk2; simpl in *; discriminate || auto.
+
+  unfold chunk_eq in H0. destruct H0.
   red in H1.
   destruct chunk1; simpl in H1; try contradiction;
   destruct chunk2; simpl in *; discriminate || auto.
+  subst. destruct (eq_nat_dec n0 31); auto.
+
+  unfold chunk_eq in H0. destruct H0.
   red in H1.
   destruct chunk1; simpl in H1; try contradiction;
   destruct chunk2; simpl in *; discriminate || auto.
+  subst. destruct (eq_nat_dec n0 31); auto.
 Qed.
 
 Lemma decode_val_type:
   forall chunk cl,
   Val.has_type (decode_val chunk cl) (type_of_chunk chunk).
 Proof.
-  intros. unfold decode_val. 
-  destruct (proj_bytes cl). 
+  intros. unfold decode_val.
+  destruct chunk; simpl; auto. 
+
+    unfold decode_int.    
+    destruct (proj_bytes n cl); simpl; auto.
+      destruct (eq_nat_dec n 31); simpl; auto.
+        unfold proj_pointer. unfold proj_ipointer.
+        destruct cl; try solve [simpl; auto].
+          destruct m; try solve [simpl; auto].
+            destruct (check_pointer (size_chunk_nat Mint32) b i 
+                       (Pointer b i n0::cl)); simpl; auto.            
+            destruct (check_ipointer (size_chunk_nat Mint32) i 
+                       (IPointer i n0::cl)); simpl; auto.
+
+    destruct (proj_bytes 31 cl); simpl; auto.
+    destruct (proj_bytes 63 cl); simpl; auto.
+Qed.
+
+Lemma decode_val_chunk:
+  forall chunk cl,
+  Val.has_chunk (decode_val chunk cl) chunk.
+Proof.
+  intros. unfold decode_val.
   destruct chunk; simpl; auto. 
-  destruct chunk; simpl; auto.
-  unfold proj_pointer. destruct cl; try (exact I).
-  destruct m; try (exact I).
-  destruct (check_pointer (size_chunk_nat Mint32) b i (Pointer b i n :: cl));
-  exact I.
+
+    unfold decode_int.    
+    destruct (proj_bytes n cl); simpl.
+      split; auto.
+      apply Z_mod_lt.
+        apply Int.modulus_pos.       
+
+      destruct (eq_nat_dec n 31); simpl; auto.
+        unfold proj_pointer. unfold proj_ipointer.
+        destruct cl; try solve [simpl; auto].
+          destruct m; try solve [simpl; auto].
+            destruct (check_pointer (size_chunk_nat Mint32) b i 
+                       (Pointer b i n0::cl)); simpl; auto.            
+            destruct (check_ipointer (size_chunk_nat Mint32) i 
+                       (IPointer i n0::cl)); simpl; auto.
+
+    destruct (proj_bytes 31 cl); simpl; auto.
+      rewrite Float.singleoffloat_of_bits. auto.
+    destruct (proj_bytes 63 cl); simpl; auto.
 Qed.
 
+(*
 Lemma encode_val_int8_signed_unsigned:
   forall v, encode_val Mint8signed v = encode_val Mint8unsigned v.
 Proof.
@@ -682,54 +1096,195 @@
 Proof.
   intros; unfold encode_val. rewrite encode_int16_sign_ext. auto.
 Qed.
+*)
 
 Lemma decode_val_int_inv:
   forall chunk cl n,
-  decode_val chunk cl = Vint n ->
+  decode_val chunk cl = Vint (wz_of_chunk chunk) n ->
   type_of_chunk chunk = Tint /\
-  exists bytes, proj_bytes cl = Some bytes /\ n = decode_int chunk bytes.
+  exists bytes, proj_bytes (wz_of_chunk chunk) cl = Some bytes /\ 
+    n = decode_int (wz_of_chunk chunk) bytes.
 Proof.
-  intros until n. unfold decode_val. destruct (proj_bytes cl). 
+  intros until n. unfold decode_val. 
+  destruct (proj_bytes (wz_of_chunk chunk) cl).
 Opaque decode_int.
-  destruct chunk; intro EQ; inv EQ; split; auto; exists l; auto. 
-  destruct chunk; try congruence. unfold proj_pointer. 
-  destruct cl; try congruence. destruct m; try congruence. 
-  destruct (check_pointer (size_chunk_nat Mint32) b i (Pointer b i n0 :: cl));
-  congruence.
+    destruct chunk; intro EQ; inv EQ; split; auto; exists l; auto.
+
+    destruct chunk; try congruence. 
+    destruct (eq_nat_dec n0 31); subst; try congruence. 
+    unfold proj_pointer, proj_ipointer.
+    destruct cl; try congruence. 
+    destruct m; try congruence.
+      destruct (check_pointer (size_chunk_nat Mint32) b i 
+        (Pointer b i n0 :: cl)); congruence.
+      destruct (check_ipointer (size_chunk_nat Mint32) i 
+        (IPointer i n0 :: cl)); congruence.
+Transparent decode_int.
 Qed.
 
 Lemma decode_val_float_inv:
   forall chunk cl f,
   decode_val chunk cl = Vfloat f ->
   type_of_chunk chunk = Tfloat /\
-  exists bytes, proj_bytes cl = Some bytes /\ f = decode_float chunk bytes.
+  exists bytes, proj_bytes (wz_of_chunk chunk) cl = Some bytes /\ 
+    f = decode_float chunk bytes.
 Proof.
-  intros until f. unfold decode_val. destruct (proj_bytes cl). 
-  destruct chunk; intro EQ; inv EQ; split; auto; exists l; auto. 
-  destruct chunk; try congruence. unfold proj_pointer. 
-  destruct cl; try congruence. destruct m; try congruence.
-  destruct (check_pointer (size_chunk_nat Mint32) b i (Pointer b i n :: cl));
-  congruence.
+  intros until f. unfold decode_val. 
+  destruct (proj_bytes (wz_of_chunk chunk) cl).
+    destruct chunk; intro EQ; inv EQ; split; auto; exists l; auto.
+
+    destruct chunk; try congruence.
+    destruct (eq_nat_dec n 31); subst; try congruence.
+    unfold proj_pointer. unfold proj_ipointer.
+    destruct cl; try congruence. 
+    destruct m; try congruence.
+      destruct (check_pointer (size_chunk_nat Mint32) b i (Pointer b i n :: cl));
+        congruence.
+      destruct (check_ipointer (size_chunk_nat Mint32) i (IPointer i n :: cl));
+        congruence.
 Qed.
 
 Lemma decode_val_cast:
   forall chunk l,
   let v := decode_val chunk l in
   match chunk with
-  | Mint8signed => v = Val.sign_ext 8 v
-  | Mint8unsigned => v = Val.zero_ext 8 v
-  | Mint16signed => v = Val.sign_ext 16 v
-  | Mint16unsigned => v = Val.zero_ext 16 v
+  | Mint wz => True
   | Mfloat32 => v = Val.singleoffloat v
   | _ => True
   end.
 Proof.
-  unfold decode_val; intros; destruct chunk; auto; destruct (proj_bytes l); auto.
-  unfold Val.sign_ext. decEq. symmetry. apply decode_int8_sign_ext.
-  unfold Val.zero_ext. decEq. symmetry. apply decode_int8_zero_ext.
-  unfold Val.sign_ext. decEq. symmetry. apply decode_int16_sign_ext.
-  unfold Val.zero_ext. decEq. symmetry. apply decode_int16_zero_ext.
-  unfold Val.singleoffloat. decEq. symmetry. apply decode_float32_cast. 
+  unfold decode_val; intros; destruct chunk; auto.
+  destruct (proj_bytes (wz_of_chunk Mfloat32) l); auto.
+  unfold Val.singleoffloat. decEq. symmetry. apply decode_float32_cast.
+Qed.
+
+Lemma two_p_bytesize_chunk__ge__modulus: forall n,
+  0 < Int.modulus n <= two_p (bytesize_chunk n * 8).
+Proof. 
+  intros.
+  unfold Int.modulus. unfold bytesize_chunk. unfold Int.wordsize. 
+  rewrite two_power_nat_two_p.
+  split.
+    apply Zgt_lt.
+    apply two_p_gt_ZERO; try omega.
+    
+    apply two_p_monotone.
+    split; try omega.
+      assert (8 > 0) as J. omega.
+      apply ZRdiv_prop1 with (a:=Z_of_nat (S n)) in J. omega.
+Qed.
+
+Lemma Zmod_mod_le : forall a b c,
+  0 < b <= c -> a mod b mod c = a mod b.
+Proof.
+  intros.
+  assert (J:=@Z_mod_lt a b).
+  rewrite Zmod_small; auto with zarith.
+Qed.
+
+Lemma encode_decode_encode_val__eq__encode_val: forall v c,
+  encode_val c (decode_val c (encode_val c v)) = encode_val c v.
+Proof.
+  destruct v; destruct c; simpl; auto; unfold decode_val;
+    try (rewrite proj_inj_bytes; simpl).
+
+    rewrite proj_bytes_undef'; auto using size_chunk_nat_pos'.
+    destruct (eq_nat_dec n 31); subst; auto.
+
+Focus.
+    unfold encode_int. simpl.
+    rewrite rev_if_be_involutive.
+    f_equal. f_equal. 
+    rewrite int_of_bytes_of_int.    
+    rewrite nat_of_Z_max.
+    rewrite Zmax_spec.
+    assert (J:=@bytesize_chunk_pos n).
+    destruct (zlt 0 (bytesize_chunk n)); try solve [contradict g; omega].
+    rewrite bytes_of_int_mod' with (y:=Int.unsigned wz i mod Int.modulus n); 
+      try omega; auto.
+    rewrite Zmod_mod_le with (c:=two_p (bytesize_chunk n * 8)); 
+      auto using two_p_bytesize_chunk__ge__modulus.
+      repeat rewrite Zmod_mod.
+      apply Int.eqmod_refl.
+
+    unfold encode_float. unfold encode_int.
+    rewrite rev_if_be_involutive.
+    f_equal. f_equal. 
+    simpl.
+    repeat rewrite Floats.Float.bits_of_single_of_bits. simpl.
+    repeat rewrite Zmod_0_l. auto.
+
+    unfold encode_float. unfold encode_int.
+    rewrite rev_if_be_involutive.
+    f_equal. f_equal. 
+    simpl.
+    repeat rewrite Floats.Float.bits_of_double_of_bits. simpl.
+    repeat rewrite Zmod_0_l. auto.
+
+    unfold encode_float. unfold encode_int. unfold decode_int.
+    rewrite rev_if_be_involutive. simpl.
+    f_equal. f_equal. 
+    rewrite int_of_bytes_of_int.    
+    rewrite Zmod_0_l. auto.
+
+    unfold encode_float.
+    rewrite rev_if_be_involutive. 
+    f_equal. f_equal. 
+    rewrite int_of_bytes_of_int.   
+    rewrite Floats.Float.bits_of_single_of_bits. 
+    erewrite bytes_of_int_mod; eauto. 
+    apply Int.eqmod_trans with 
+      (y:=Int.unsigned 31 (Floats.Float.bits_of_single f) 
+            mod two_p (Z_of_nat 4 * 8)).
+      apply Int.eqm_unsigned_repr_l.
+      apply Int.eqmod_refl.
+
+      apply Int.eqmod_sym.
+      apply Int.eqmod_mod.
+        apply two_p_gt_ZERO; try omega.
+
+    unfold encode_float.
+    rewrite rev_if_be_involutive. 
+    f_equal. f_equal. 
+    rewrite Floats.Float.bits_of_double_of_bits. 
+    rewrite int_of_bytes_of_int.    
+    erewrite bytes_of_int_mod; eauto. 
+    apply Int.eqmod_trans with 
+      (y:=Int.unsigned 63 (Floats.Float.bits_of_double f) 
+            mod two_p (Z_of_nat 8 * 8)).
+      apply Int.eqm_unsigned_repr_l.
+      apply Int.eqmod_refl.
+
+      apply Int.eqmod_sym.
+      apply Int.eqmod_mod.
+        apply two_p_gt_ZERO; try omega.
+
+    destruct (eq_nat_dec n 31); subst.
+      simpl.
+      destruct (eq_block b b); simpl; try congruence.
+      destruct (Int.eq_dec 31 i i); simpl; try congruence.
+      rewrite proj_bytes_undef'; auto using size_chunk_nat_pos'.
+
+    destruct (eq_nat_dec n 31); subst.
+      simpl.
+      destruct (Int.eq_dec 31 i i); simpl; try congruence.
+      rewrite proj_bytes_undef'; auto using size_chunk_nat_pos'.
+Qed.
+
+Lemma rev_if_be_nil: forall A, rev_if_be A nil = nil.
+Proof. unfold rev_if_be. simpl. destruct big_endian; auto. Qed.
+
+Lemma encode_decode_undef: forall c n,
+  (n > 0)%nat ->
+  encode_val c (decode_val c (list_repeat n Undef)) = 
+    list_repeat (size_chunk_nat c) Undef.
+Proof.
+  intros.
+  destruct c; simpl; unfold decode_val; rewrite proj_bytes_undef'; auto.
+    destruct (eq_nat_dec n0 31); subst; auto.
+      rewrite proj_pointer_undef'.
+      rewrite proj_ipointer_undef'.
+      auto.
 Qed.
 
 (** Pointers cannot be forged. *)
@@ -737,12 +1292,14 @@
 Definition memval_valid_first (mv: memval) : Prop :=
   match mv with
   | Pointer b ofs n => n = pred (size_chunk_nat Mint32)
+  | IPointer i n => n = pred (size_chunk_nat Mint32)
   | _ => True
   end.
 
 Definition memval_valid_cont (mv: memval) : Prop :=
   match mv with
-  | Pointer b ofs n => n <> pred (size_chunk_nat Mint32)
+  | Pointer b ofs n => n <> pred (size_chunk_nat Mint32)  
+  | IPointer i n => n <> pred (size_chunk_nat Mint32)  
   | _ => True
   end.
 
@@ -755,23 +1312,32 @@
 Lemma encode_val_shape:
   forall chunk v, encoding_shape (encode_val chunk v).
 Proof.
-  intros. 
+  intros.
   destruct (size_chunk_nat_pos chunk) as [sz1 EQ].
   assert (encoding_shape (list_repeat (size_chunk_nat chunk) Undef)).
-    rewrite EQ; simpl; constructor. exact I. 
+    rewrite EQ; simpl; constructor. exact I.
     intros. replace mv with Undef. exact I. symmetry; eapply in_list_repeat; eauto.
   assert (forall bl, length bl = size_chunk_nat chunk ->
-          encoding_shape (inj_bytes bl)).
-    intros. destruct bl; simpl in *. congruence. 
+          encoding_shape (inj_bytes (wz_of_chunk chunk) bl)).
+    intros. destruct bl; simpl in *. congruence.
     constructor. exact I. unfold inj_bytes. intros.
     exploit list_in_map_inv; eauto. intros [x [A B]]. subst mv. exact I.
-  destruct v; simpl. 
-  auto.
-  apply H0. apply encode_int_length. 
-  apply H0. apply encode_float_length.
-  destruct chunk; auto. 
-  constructor. red. auto.
-  simpl; intros. intuition; subst mv; red; simpl; congruence.
+  destruct v; simpl.
+    auto.
+    apply H0. apply encode_int_length.
+    apply H0. apply encode_float_length.
+
+    destruct chunk; auto.
+    destruct (eq_nat_dec n 31); auto.
+      constructor. 
+        red. auto.
+        simpl; intros. intuition; subst mv; red; simpl; congruence.
+
+    destruct chunk; auto.
+    destruct (eq_nat_dec n 31); subst; simpl; auto. 
+      constructor. 
+        red. auto.
+        simpl; intros. intuition; subst mv; red; simpl; congruence.
 Qed.
 
 Lemma check_pointer_inv:
@@ -791,6 +1357,21 @@
   auto.
 Qed.
 
+Lemma check_ipointer_inv:
+  forall i n mv,
+  check_ipointer n i mv = true -> mv = inj_ipointer n i.
+Proof.
+  induction n; destruct mv; simpl. 
+  auto.
+  congruence.
+  congruence.
+  destruct m; try congruence. intro. 
+  destruct (andb_prop _ _ H). destruct (andb_prop _ _ H0). 
+  decEq. decEq. symmetry; eapply proj_sumbool_true; eauto.
+  symmetry; apply beq_nat_true; auto.
+  auto.
+Qed.
+
 Inductive decoding_shape: list memval -> Prop :=
   | decoding_shape_intro: forall mv1 mvl,
       memval_valid_first mv1 -> mv1 <> Undef ->
@@ -802,35 +1383,91 @@
   List.length mvl = size_chunk_nat chunk ->
   decode_val chunk mvl = Vundef \/ decoding_shape mvl.
 Proof.
-  intros. destruct (size_chunk_nat_pos chunk) as [sz EQ]. 
-  unfold decode_val. 
-  caseEq (proj_bytes mvl).
-  intros bl PROJ. right. exploit inj_proj_bytes; eauto. intros. subst mvl.
-  destruct bl; simpl in H. congruence. simpl. constructor. 
-  red; auto. congruence.
-  unfold inj_bytes; intros. exploit list_in_map_inv; eauto. intros [b [A B]]. 
-  subst mv. split. red; auto. congruence.
-  intros. destruct chunk; auto. unfold proj_pointer.
-  destruct mvl; auto. destruct m; auto. 
-  caseEq (check_pointer (size_chunk_nat Mint32) b i (Pointer b i n :: mvl)); auto.
-  intros. right. exploit check_pointer_inv; eauto. simpl; intros; inv H2.
-  constructor. red. auto. congruence. 
-  simpl; intros. intuition; subst mv; simpl; congruence.
+  intros. destruct (size_chunk_nat_pos chunk) as [sz EQ].
+  unfold decode_val.
+  caseEq (proj_bytes (wz_of_chunk chunk) mvl).
+    intros bl PROJ. right. exploit inj_proj_bytes; eauto. intros. subst mvl.
+    destruct bl; simpl in H. congruence. simpl.
+    constructor.
+      red; auto. 
+      congruence.
+      unfold inj_bytes; intros. exploit list_in_map_inv; eauto. intros [b [A B]].
+      subst mv. 
+      split. 
+        red; auto. 
+        congruence.
+
+    intros. destruct chunk; auto. destruct (eq_nat_dec n 31); subst; auto.
+    unfold proj_pointer, proj_ipointer.
+    destruct mvl; auto. 
+    destruct m; auto.
+      caseEq (check_pointer (size_chunk_nat Mint32) b i (Pointer b i n :: mvl));
+        auto.
+      intros. right. exploit check_pointer_inv; eauto. simpl; intros; inv H2.
+      constructor. 
+        red. auto.  
+        congruence.
+        simpl; intros. intuition; subst mv; simpl; congruence.
+
+      caseEq (check_ipointer (size_chunk_nat Mint32) i (IPointer i n :: mvl));
+        auto.
+      intros. right. exploit check_ipointer_inv; eauto. simpl; intros; inv H2.
+      constructor. 
+        red. auto.  
+        congruence.
+        simpl; intros. intuition; subst mv; simpl; congruence.
 Qed.
 
 Lemma encode_val_pointer_inv:
   forall chunk v b ofs n mvl,
   encode_val chunk v = Pointer b ofs n :: mvl ->
-  chunk = Mint32 /\ v = Vptr b ofs /\ mvl = inj_pointer (pred (size_chunk_nat Mint32)) b ofs.
+  chunk = Mint32 /\ v = Vptr b ofs /\ 
+    mvl = inj_pointer (pred (size_chunk_nat Mint32)) b ofs.
+Proof.
+  intros until mvl.
+  destruct (size_chunk_nat_pos chunk) as [sz SZ].
+  unfold encode_val. rewrite SZ. 
+  destruct v.
+    simpl. congruence.
+
+    generalize (encode_int_length chunk wz i). 
+    destruct (encode_int chunk wz i); simpl; congruence.
+
+    generalize (encode_float_length chunk f). 
+    destruct (encode_float chunk f); simpl; congruence.
+
+    destruct chunk; try (simpl; congruence).
+    destruct (eq_nat_dec n0 31); subst; try (simpl; congruence).
+    simpl. intuition congruence.
+
+    destruct chunk; try (simpl; congruence).
+    destruct (eq_nat_dec n0 31); subst; try (simpl; congruence).
+Qed.
+
+Lemma encode_val_ipointer_inv:
+  forall chunk v i n mvl,
+  encode_val chunk v = IPointer i n :: mvl ->
+  chunk = Mint32 /\ v = Vinttoptr i /\ 
+    mvl = inj_ipointer (pred (size_chunk_nat Mint32)) i.
 Proof.
-  intros until mvl. 
+  intros until mvl.
   destruct (size_chunk_nat_pos chunk) as [sz SZ].
-  unfold encode_val. rewrite SZ. destruct v.
-  simpl. congruence. 
-  generalize (encode_int_length chunk i). destruct (encode_int chunk i); simpl; congruence.
-  generalize (encode_float_length chunk f). destruct (encode_float chunk f); simpl; congruence.
-  destruct chunk; try (simpl; congruence). 
-  simpl. intuition congruence. 
+  unfold encode_val. rewrite SZ. 
+  destruct v.
+    simpl. congruence.
+
+    generalize (encode_int_length chunk wz i0). 
+    destruct (encode_int chunk wz i0); simpl; congruence.
+
+    generalize (encode_float_length chunk f). 
+    destruct (encode_float chunk f); simpl; congruence.
+
+    destruct chunk; try (simpl; congruence).
+    destruct (eq_nat_dec n0 31); subst; try (simpl; congruence).
+
+    destruct chunk; try (simpl; congruence).
+    destruct (eq_nat_dec n0 31); subst; try (simpl; congruence).
+    simpl. intuition congruence.
 Qed.
 
 Lemma decode_val_pointer_inv:
@@ -839,13 +1476,50 @@
   chunk = Mint32 /\ mvl = inj_pointer (size_chunk_nat Mint32) b ofs.
 Proof.
   intros until ofs; unfold decode_val.
-  destruct (proj_bytes mvl). 
-  destruct chunk; congruence.
-  destruct chunk; try congruence.
-  unfold proj_pointer. destruct mvl. congruence. destruct m; try congruence.
-  case_eq (check_pointer (size_chunk_nat Mint32) b0 i (Pointer b0 i n :: mvl)); intros.
-  inv H0. split; auto. apply check_pointer_inv; auto. 
-  congruence.
+  destruct (proj_bytes (wz_of_chunk chunk) mvl).
+    destruct chunk; congruence.
+
+    destruct chunk; try congruence.
+    destruct (eq_nat_dec n 31); subst; try congruence.
+    unfold proj_pointer. 
+    Opaque check_ipointer.
+    destruct mvl; try solve [intro J; inversion J].
+    destruct m; try solve [intro J; inversion J].
+      case_eq (check_pointer (size_chunk_nat Mint32) b0 i 
+        (Pointer b0 i n :: mvl)); intros.
+        inv H0. split; auto. apply check_pointer_inv; auto.
+        inv H0.
+      intro J. simpl in J.
+      destruct (check_ipointer (size_chunk_nat Mint32) i (IPointer i n :: mvl));
+        inversion J.
+    Transparent check_ipointer.
+Qed.
+
+Lemma decode_val_ipointer_inv:
+  forall chunk mvl i,
+  decode_val chunk mvl = Vinttoptr i ->
+  chunk = Mint32 /\ mvl = inj_ipointer (size_chunk_nat Mint32) i.
+Proof.
+  intros until i; unfold decode_val.
+  destruct (proj_bytes (wz_of_chunk chunk) mvl).
+    destruct chunk; congruence.
+
+    destruct chunk; try congruence.
+    destruct (eq_nat_dec n 31); subst; try congruence.
+    unfold proj_ipointer. 
+    unfold proj_pointer.
+    Opaque check_pointer.
+    destruct mvl; try congruence.
+    destruct m; try congruence.
+      case_eq (check_pointer (size_chunk_nat Mint32) b i0 
+        (Pointer b i0 n :: mvl)); intros.
+        inv H0. inv H0.
+
+      case_eq (check_ipointer (size_chunk_nat Mint32) i0 (IPointer i0 n :: mvl));
+        intros.
+        inv H0. split; auto. apply check_ipointer_inv; auto.
+        inv H0.
+    Transparent check_pointer.
 Qed.
 
 Inductive pointer_encoding_shape: list memval -> Prop :=
@@ -857,9 +1531,19 @@
 Lemma encode_pointer_shape:
   forall b ofs, pointer_encoding_shape (encode_val Mint32 (Vptr b ofs)).
 Proof.
-  intros. simpl. constructor.
-  unfold memval_valid_cont. red; intro. elim H. auto. 
-  unfold memval_valid_first. simpl; intros; intuition; subst mv; congruence.
+  intros. simpl. 
+  constructor.
+    unfold memval_valid_cont. red; intro. elim H. auto.
+    unfold memval_valid_first. simpl; intros; intuition; subst mv; congruence.
+Qed.
+
+Lemma encode_ipointer_shape:
+  forall i, pointer_encoding_shape (encode_val Mint32 (Vinttoptr i)).
+Proof.
+  intros. simpl. 
+  constructor.
+    unfold memval_valid_cont. red; intro. elim H. auto.
+    unfold memval_valid_first. simpl; intros; intuition; subst mv; congruence.
 Qed.
 
 Lemma decode_pointer_shape:
@@ -868,7 +1552,22 @@
   chunk = Mint32 /\ pointer_encoding_shape mvl.
 Proof.
   intros. exploit decode_val_pointer_inv; eauto. intros [A B].
-  split; auto. subst mvl. apply encode_pointer_shape. 
+  split; auto. subst mvl. 
+  assert (J:=@encode_pointer_shape b ofs).
+  unfold encode_val in J.
+  simpl in J. auto.
+Qed.
+
+Lemma decode_ipointer_shape:
+  forall chunk mvl i,
+  decode_val chunk mvl = Vinttoptr i ->
+  chunk = Mint32 /\ pointer_encoding_shape mvl.
+Proof.
+  intros. exploit decode_val_ipointer_inv; eauto. intros [A B].
+  split; auto. subst mvl.
+  assert (J:=@encode_ipointer_shape i).
+  unfold encode_val in J.
+  simpl in J. auto.
 Qed.
 
 (** * Compatibility with memory injections *)
@@ -877,17 +1576,19 @@
 
 Inductive memval_inject (f: meminj): memval -> memval -> Prop :=
   | memval_inject_byte:
-      forall n, memval_inject f (Byte n) (Byte n)
+      forall wz n, memval_inject f (Byte wz n) (Byte wz n)
   | memval_inject_ptr:
       forall b1 ofs1 b2 ofs2 delta n,
       f b1 = Some (b2, delta) ->
-      ofs2 = Int.add ofs1 (Int.repr delta) ->
+      ofs2 = Int.add 31 ofs1 (Int.repr 31 delta) ->
       memval_inject f (Pointer b1 ofs1 n) (Pointer b2 ofs2 n)
+  | memval_inject_inttoptr:
+      forall i n, memval_inject f (IPointer i n) (IPointer i n)
   | memval_inject_undef:
       forall mv, memval_inject f Undef mv.
 
-Lemma memval_inject_incr:
-  forall f f' v1 v2, memval_inject f v1 v2 -> inject_incr f f' -> memval_inject f' v1 v2.
+Lemma memval_inject_incr: forall f f' v1 v2, 
+  memval_inject f v1 v2 -> inject_incr f f' -> memval_inject f' v1 v2.
 Proof.
   intros. inv H; econstructor. rewrite (H0 _ _ _ H1). reflexivity. auto.
 Qed.
@@ -898,15 +1599,19 @@
 Lemma proj_bytes_inject:
   forall f vl vl',
   list_forall2 (memval_inject f) vl vl' ->
-  forall bl,
-  proj_bytes vl = Some bl ->
-  proj_bytes vl' = Some bl.
+  forall n bl,
+  proj_bytes n vl = Some bl ->
+  proj_bytes n vl' = Some bl.
 Proof.
   induction 1; simpl. congruence.
   inv H; try congruence.
-  destruct (proj_bytes al); intros. 
-  inv H. rewrite (IHlist_forall2 l); auto. 
-  congruence.
+
+  intros.
+  destruct (eq_nat_dec wz n0); auto.
+  remember (proj_bytes n0 al) as R.
+  destruct R.
+    inv H. rewrite (IHlist_forall2 n0 l); auto.
+    congruence.      
 Qed.
 
 Lemma check_pointer_inject:
@@ -915,21 +1620,38 @@
   forall n b ofs b' delta,
   check_pointer n b ofs vl = true ->
   f b = Some(b', delta) ->
-  check_pointer n b' (Int.add ofs (Int.repr delta)) vl' = true.
+  check_pointer n b' (Int.add 31 ofs (Int.repr 31 delta)) vl' = true.
 Proof.
-  induction 1; intros; destruct n; simpl in *; auto. 
+  induction 1; intros; destruct n; simpl in *; auto.
   inv H; auto.
-  destruct (andb_prop _ _ H1). destruct (andb_prop _ _ H). 
-  destruct (andb_prop _ _ H5). 
+  destruct (andb_prop _ _ H1). destruct (andb_prop _ _ H).
+  destruct (andb_prop _ _ H5).
   assert (n = n0) by (apply beq_nat_true; auto).
-  assert (b = b0) by (eapply proj_sumbool_true; eauto). 
+  assert (b = b0) by (eapply proj_sumbool_true; eauto).
   assert (ofs = ofs1) by (eapply proj_sumbool_true; eauto).
-  subst. rewrite H3 in H2; inv H2. 
-  unfold proj_sumbool. rewrite dec_eq_true. rewrite dec_eq_true. 
-  rewrite <- beq_nat_refl. simpl. eauto. 
+  subst. rewrite H3 in H2; inv H2.
+  unfold proj_sumbool. rewrite dec_eq_true. rewrite dec_eq_true.
+  rewrite <- beq_nat_refl. simpl. eauto.
   congruence.
 Qed.
 
+Lemma check_ipointer_inject:
+  forall f vl vl',
+  list_forall2 (memval_inject f) vl vl' ->
+  forall n i,
+  check_ipointer n i vl = true ->
+  check_ipointer n i vl' = true. 
+Proof.
+  induction 1; intros; destruct n; simpl in *; auto. 
+  inv H; auto.
+
+  destruct (andb_prop _ _ H1). destruct (andb_prop _ _ H).
+  apply IHlist_forall2 in H2.
+  congruence.
+
+  inv H1.
+Qed.
+
 Lemma proj_pointer_inject:
   forall f vl1 vl2,
   list_forall2 (memval_inject f) vl1 vl2 ->
@@ -937,24 +1659,44 @@
 Proof.
   intros. unfold proj_pointer.
   inversion H; subst. auto. inversion H0; subst; auto.
-  case_eq (check_pointer (size_chunk_nat Mint32) b0 ofs1 (Pointer b0 ofs1 n :: al)); intros.
+  case_eq (check_pointer (size_chunk_nat Mint32) b0 ofs1 
+             (Pointer b0 ofs1 n :: al)); intros.
   exploit check_pointer_inject. eexact H. eauto. eauto. 
   intro. rewrite H4. econstructor; eauto. 
   constructor.
 Qed.
 
+Lemma proj_ipointer_inject:
+  forall f vl1 vl2,
+  list_forall2 (memval_inject f) vl1 vl2 ->
+  val_inject f (proj_ipointer vl1) (proj_ipointer vl2).
+Proof.
+  intros. unfold proj_ipointer.
+  inversion H; subst. auto. inversion H0; subst; auto.
+  case_eq (check_ipointer (size_chunk_nat Mint32) i 
+             (IPointer i n :: al)); intros.
+  exploit check_ipointer_inject. eexact H. eauto. eauto. 
+  intro. rewrite H3. econstructor; eauto. 
+  constructor.
+Qed.
+
 Lemma proj_bytes_not_inject:
   forall f vl vl',
   list_forall2 (memval_inject f) vl vl' ->
-  proj_bytes vl = None -> proj_bytes vl' <> None -> In Undef vl.
+  forall n,
+  proj_bytes n vl = None -> proj_bytes n vl' <> None -> In Undef vl.
 Proof.
   induction 1; simpl; intros.
-  congruence.
-  inv H; try congruence. 
-  right. apply IHlist_forall2.
-  destruct (proj_bytes al); congruence.
-  destruct (proj_bytes bl); congruence.
-  auto.
+    congruence.
+    inv H; try congruence; auto.
+    destruct (eq_nat_dec wz n); subst; auto.
+      remember (proj_bytes n al) as R.
+      remember (proj_bytes n bl) as R'.
+      destruct R; destruct R';
+        try solve [inversion H1 | inversion H2 | contradict H2; auto].
+        right. eapply IHlist_forall2; eauto.
+          rewrite <- HeqR'. intro. inversion H.          
+      contradict H2; auto.
 Qed.
 
 Lemma check_pointer_undef:
@@ -968,6 +1710,17 @@
   rewrite IHn; auto. apply andb_false_r. 
 Qed.
 
+Lemma check_ipointer_undef:
+  forall n i vl,
+  In Undef vl -> check_ipointer n i vl = false.
+Proof.
+  induction n; intros; simpl. 
+  destruct vl. elim H. auto.
+  destruct vl. auto.
+  destruct m; auto. simpl in H; destruct H. congruence.
+  rewrite IHn; auto. apply andb_false_r. 
+Qed.
+
 Lemma proj_pointer_undef:
   forall vl, In Undef vl -> proj_pointer vl = Vundef.
 Proof.
@@ -976,19 +1729,96 @@
   rewrite check_pointer_undef. auto. auto.
 Qed.
 
+Lemma proj_ipointer_undef:
+  forall vl, In Undef vl -> proj_ipointer vl = Vundef.
+Proof.
+  intros; unfold proj_ipointer.
+  destruct vl; auto. destruct m; auto. 
+  rewrite check_ipointer_undef. auto. auto.
+Qed.
+
+Lemma proj_bytes_undef:
+  forall vl wz, In Undef vl -> proj_bytes wz vl = None.
+Proof.
+  induction vl; intros. 
+    inversion H.   
+
+    simpl in H.
+    destruct H as [H | H]; simpl; subst; auto.
+    destruct a; auto.
+    destruct (eq_nat_dec n wz); subst; auto.
+    rewrite IHvl; auto.
+Qed.
+
+Lemma proj_pointer_inv : forall vs,
+  proj_pointer vs = Vundef \/ exists b, exists ofs, proj_pointer vs = Vptr b ofs.
+Proof.
+  intros.
+  unfold proj_pointer.
+  destruct vs; auto.
+  destruct m; auto.
+  destruct (check_pointer (size_chunk_nat Mint32) b i (Pointer b i n :: vs));
+    auto.
+    right. exists b. exists i. auto.
+Qed.
+
+Lemma proj_ipointer_inv : forall vs,
+  proj_ipointer vs = Vundef \/ exists i, proj_ipointer vs = Vinttoptr i.
+Proof.
+  intros.
+  unfold proj_ipointer.
+  destruct vs; auto.
+  destruct m; auto.
+  destruct (check_ipointer (size_chunk_nat Mint32) i (IPointer i n :: vs)); auto.
+    right. exists i. auto.
+Qed.
+
+Lemma proj_pointer_neq_proj_ipointer : forall vs,
+  proj_pointer vs <> Vundef ->
+  proj_ipointer vs <> Vundef ->
+  False.
+Proof.
+  unfold proj_pointer, proj_ipointer. intros.
+  destruct vs; try solve [contradict H; auto].
+  destruct m; try solve [contradict H; auto].
+    auto.
+Qed.
+
 Theorem decode_val_inject:
   forall f vl1 vl2 chunk,
   list_forall2 (memval_inject f) vl1 vl2 ->
   val_inject f (decode_val chunk vl1) (decode_val chunk vl2).
 Proof.
-  intros. unfold decode_val. 
-  case_eq (proj_bytes vl1); intros. 
-  exploit proj_bytes_inject; eauto. intros. rewrite H1. 
-  destruct chunk; constructor.
-  destruct chunk; auto.
-  case_eq (proj_bytes vl2); intros.
-  rewrite proj_pointer_undef. auto. eapply proj_bytes_not_inject; eauto. congruence.
-  apply proj_pointer_inject; auto.
+  intros. unfold decode_val.
+  case_eq (proj_bytes (wz_of_chunk chunk) vl1); intros.
+    exploit proj_bytes_inject; eauto. intros. rewrite H1.
+    destruct chunk; constructor.
+ 
+    destruct chunk; auto.
+    destruct (eq_nat_dec n 31); subst; auto.
+    case_eq (proj_bytes (wz_of_chunk (Mint 31)) vl2); intros.
+      assert (In Undef vl1) as J.
+        eapply proj_bytes_not_inject; eauto. 
+           congruence.
+      rewrite proj_pointer_undef; auto.
+      rewrite proj_ipointer_undef; auto.
+      destruct (@proj_pointer_inv vl1) as [J1 | [b1 [ofs1 J1]]]; rewrite J1.
+        destruct (@proj_ipointer_inv vl1) as [J1' | [i1' J1']]; rewrite J1'. 
+          auto.
+        apply proj_ipointer_inject in H.
+        rewrite J1' in H.
+        destruct (@proj_pointer_inv vl2) as [J2 | [b2 [ofs2 J2]]]; rewrite J2.
+          auto.
+
+          inv H.
+          case_eq (proj_pointer_neq_proj_ipointer vl2); try congruence.
+
+        destruct (@proj_pointer_inv vl2) as [J2 | [b2 [ofs2 J2]]]; rewrite J2.
+          apply proj_pointer_inject in H.
+          rewrite J1 in H. rewrite J2 in H. inversion H.
+           
+          rewrite <- J1. rewrite <- J2.
+          apply proj_pointer_inject; auto.
 Qed.
 
 (** Symmetrically, [encode_val], applied to values related by [val_inject],
@@ -996,7 +1826,8 @@
   related by [memval_inject]. *)
 
 Lemma inj_bytes_inject:
-  forall f bl, list_forall2 (memval_inject f) (inj_bytes bl) (inj_bytes bl).
+  forall f wz bl, 
+    list_forall2 (memval_inject f) (inj_bytes wz bl) (inj_bytes wz bl).
 Proof.
   induction bl; constructor; auto. constructor.
 Qed.
@@ -1021,12 +1852,19 @@
   list_forall2 (memval_inject f) (encode_val chunk v1) (encode_val chunk v2).
 Proof.
   intros. inv H; simpl.
-  apply inj_bytes_inject.
-  apply inj_bytes_inject.
-  destruct chunk; try apply repeat_Undef_inject_self. 
-  unfold inj_pointer; simpl; repeat econstructor; auto. 
-  replace (size_chunk_nat chunk) with (length (encode_val chunk v2)).
-  apply repeat_Undef_inject_any. apply encode_val_length. 
+    apply inj_bytes_inject.
+    apply inj_bytes_inject.
+
+    destruct chunk; try apply repeat_Undef_inject_self.
+    destruct (eq_nat_dec n 31); subst; try apply repeat_Undef_inject_self.
+      simpl; repeat econstructor; auto.
+
+    destruct chunk; try apply repeat_Undef_inject_self.
+    destruct (eq_nat_dec n 31); subst; try apply repeat_Undef_inject_self.
+      unfold inj_ipointer; simpl; repeat econstructor; auto.
+
+    replace (size_chunk_nat chunk) with (length (encode_val chunk v2)).
+    apply repeat_Undef_inject_any. apply encode_val_length.
 Qed.
 
 (** The identity injection has interesting properties. *)
@@ -1038,19 +1876,37 @@
   val_inject inject_id v1 v2 <-> Val.lessdef v1 v2.
 Proof.
   intros; split; intros.
-  inv H. constructor. constructor.
-  unfold inject_id in H0. inv H0. rewrite Int.add_zero. constructor.
-  constructor.
-  inv H. destruct v2; econstructor. unfold inject_id; reflexivity. rewrite Int.add_zero; auto.
-  constructor.
+  inv H; try solve [constructor].
+    unfold inject_id in H0. inv H0. rewrite Int.add_zero. constructor.
+
+  inv H; try solve [constructor].
+    destruct v2; econstructor. 
+      unfold inject_id; reflexivity. 
+      rewrite Int.add_zero; auto.
 Qed.
 
-Definition memval_lessdef: memval -> memval -> Prop := memval_inject inject_id.
+Lemma memval_inject_id:
+  forall mv, memval_inject inject_id mv mv.
+Proof.
+  destruct mv; econstructor. unfold inject_id; reflexivity. 
+    rewrite Int.add_zero; auto. 
+Qed.
 
-Lemma memval_lessdef_refl:
-  forall mv, memval_lessdef mv mv.
+Lemma memval_inject_trans : forall mi mv1 mv2 mv3,
+  memval_inject mi mv1 mv2 ->
+  memval_inject inject_id mv2 mv3 ->
+  memval_inject mi mv1 mv3.
 Proof.
-  red. destruct mv; econstructor.
-  unfold inject_id; reflexivity. rewrite Int.add_zero; auto. 
+  unfold inject_id.
+  intros mi mv1 mv2 mv3 H1 H2.
+  inv H1; inv H2; try solve [apply memval_inject_undef; auto].
+    apply memval_inject_byte.
+
+    inv H5.
+    eapply memval_inject_ptr; eauto.
+      rewrite Int.add_zero. auto.
+
+    apply memval_inject_inttoptr; auto.
 Qed.
- 
+
+
diff -ruN lib/compcert-1.9/Memory.v lib.patched/compcert-1.9/Memory.v
--- lib/compcert-1.9/Memory.v	2014-08-30 20:09:04.806089049 -0400
+++ lib.patched/compcert-1.9/Memory.v	2014-08-30 00:29:06.159588829 -0400
@@ -27,6 +27,7 @@
 *)
   
 Require Import Axioms.
+Require Import Znumtheory.
 Require Import Coqlib.
 Require Import AST.
 Require Import Integers.
@@ -54,6 +55,13 @@
   intros; unfold update. apply zeq_false; auto.
 Qed.
 
+Lemma update_stable:
+  forall (A: Type) (x: Z) (v: A) (f: Z -> A) (y: Z),
+  update x (f x) f y = f y.
+Proof.
+  intros; unfold update. destruct (zeq y x); subst; auto.
+Qed.
+
 Module Mem <: MEM.
 
 Definition perm_order' (po: option permission) (p: permission) := 
@@ -62,25 +70,45 @@
   | None => False
  end.
 
-Record mem' : Type := mkmem {
+Record mem_ : Type := mkmem {
   mem_contents: block -> Z -> memval;
   mem_access: block -> Z -> option permission;
   bounds: block -> Z * Z;
   nextblock: block;
+  maxaddress: Z;
+  ptr2int: block -> Z -> option Z;
+  int2ptr: Z -> option (block * Z);
+
   nextblock_pos: nextblock > 0;
   nextblock_noaccess: forall b, 0 < b < nextblock \/ bounds b = (0,0) ;
   bounds_noaccess: forall b ofs, ofs < fst(bounds b) \/ ofs >= snd(bounds b) -> mem_access b ofs = None;
-  noread_undef: forall b ofs,  perm_order' (mem_access b ofs) Readable \/ mem_contents b ofs = Undef
+  noread_undef: forall b ofs, perm_order' (mem_access b ofs) Readable \/ mem_contents b ofs = Undef;
+
+  maxaddress_pos: maxaddress >= 0;  
+  conversion_props : 
+    (forall b ofs, (0 < b < nextblock /\ fst(bounds b) <= ofs < snd(bounds b))
+      <-> exists z, ptr2int b ofs = Some z) /\
+    (forall b ofs z, ptr2int b ofs = Some z <-> int2ptr z = Some (b, ofs)) /\
+    (forall b ofs1 ofs2 z1 z2, 
+      ptr2int b ofs1 = Some z1 -> ptr2int b ofs2 = Some z2 -> 
+      ofs2 - ofs1 = z2 - z1
+    ) /\ 
+    (forall b1 b2 ofs1 ofs2 z1 z2, 
+      b1 <> b2 -> ptr2int b1 ofs1 = Some z1 -> ptr2int b2 ofs2 = Some z2 -> 
+      z1 <> z2
+    ) /\  
+    (forall b ofs z, ptr2int b ofs = Some z -> 0 < z <= maxaddress)   
 }.
 
-Definition mem := mem'.
+Definition mem := mem_.
 
 Lemma mkmem_ext:
- forall cont1 cont2 acc1 acc2 bound1 bound2 next1 next2 
-          a1 a2 b1 b2 c1 c2 d1 d2,
+ forall cont1 cont2 acc1 acc2 bound1 bound2 next1 next2 max1 max2 
+        p2i1 p2i2 i2p1 i2p2 a1 a2 b1 b2 c1 c2 d1 d2 e1 e2 f1 f2,
   cont1=cont2 -> acc1=acc2 -> bound1=bound2 -> next1=next2 ->
-  mkmem cont1 acc1 bound1 next1 a1 b1 c1 d1 =
-  mkmem cont2 acc2 bound2 next2 a2 b2 c2 d2.
+  max1=max2 -> p2i1=p2i2 -> i2p1=i2p2 -> 
+  mkmem cont1 acc1 bound1 next1 max1 p2i1 i2p1 a1 b1 c1 d1 e1 f1 =
+  mkmem cont2 acc2 bound2 next2 max2 p2i2 i2p2 a2 b2 c2 d2 e2 f2.
 Proof.
   intros. subst. f_equal; apply proof_irr.
 Qed.
@@ -99,6 +127,14 @@
   intros; red; intros. subst b'. contradiction.
 Qed.
 
+Lemma valid_block_dec : forall M b,
+  {valid_block M b} + {~ valid_block M b}.
+Proof.
+  intros M b.
+  unfold valid_block.
+  apply Z_lt_dec; auto.
+Qed.
+
 Hint Local Resolve valid_not_valid_diff: mem.
 
 (** Permissions *)
@@ -274,13 +310,14 @@
 
 Theorem valid_pointer_valid_access:
   forall m b ofs,
-  valid_pointer m b ofs = true <-> valid_access m Mint8unsigned b ofs Nonempty.
+  valid_pointer m b ofs = true <-> valid_access m (Mint 7) b ofs Nonempty.
 Proof.
   intros. rewrite valid_pointer_nonempty_perm. 
   split; intros.
-  split. simpl; red; intros. replace ofs0 with ofs by omega. auto.
+  split. simpl; red; intros. rewrite bytesize_chunk_7_eq_1 in H0.
+    replace ofs0 with ofs by omega. auto.
   simpl. apply Zone_divide. 
-  destruct H. apply H. simpl. omega.
+  destruct H. apply H. simpl. rewrite bytesize_chunk_7_eq_1. omega.
 Qed.
 
 (** Bounds *)
@@ -335,10 +372,29 @@
   mkmem (fun b ofs => Undef)
         (fun b ofs => None)
         (fun b => (0,0))
-        1 _ _ _ _.
+        1
+        0
+        (fun b ofs => None)
+        (fun z => None)
+        _ _ _ _ _ _.
 Next Obligation.
   omega.
 Qed.
+Next Obligation.
+  split.
+    intros b z.
+    split; intro H.
+      contradict H; auto with zarith.      
+      destruct H as [z0 H]. inversion H.
+  split.
+    intros b ofs z.
+    split; intro H; try solve [inversion H].
+  split.
+    intros b ofs1 ofs2 z1 z2 H; try solve [inversion H].
+  split.
+    intros b1 b2 z10 z20 z1 z2 H1 H2; try solve [inversion H2].
+    intros b ofs z H; try solve [inversion H].
+Qed.
 
 Definition nullptr: block := 0.
 
@@ -347,6 +403,144 @@
   undefined cells.  Note that allocation never fails: we model an
   infinite memory. *)
 
+Fixpoint update_int2ptr (f : Z -> option (block * Z)) (b: block) 
+  (maxaddress lo: Z) (ofs: nat) : Z -> option (block * Z) :=
+match ofs with
+| S ofs' => update (maxaddress + 1 + (Z_of_nat ofs')) 
+              (Some (b, lo + (Z_of_nat ofs'))) 
+              (update_int2ptr f b maxaddress lo ofs')
+| O => f
+end.
+
+Lemma update_int2ptr_spec1 : forall f b ma lo sz ofs,
+  0 <= ofs - lo < Z_of_nat sz -> 
+  update_int2ptr f b ma lo sz (ma + 1 + (ofs - lo)) = Some (b, ofs).
+Proof.
+  induction sz; intros ofs H; simpl in *.
+    assert (0 < 0). auto with zarith.
+    contradict H; auto with zarith.    
+    
+    unfold update.
+    destruct (zeq (ma + 1 + (ofs - lo)) (ma + 1 + Z_of_nat sz)).
+      assert (lo +  Z_of_nat sz = ofs) as EQ.
+        auto with zarith.
+      rewrite EQ. auto.
+
+      apply IHsz. 
+      assert (ofs - lo <> Z_of_nat sz) as NEQ.
+        auto with zarith.
+      rewrite Zpos_P_of_succ_nat in H.
+      auto with zarith.
+Qed.      
+
+Lemma update_int2ptr_spec1' : forall f b ma lo sz x,
+  ma + 1 <= x < ma + 1 + Z_of_nat sz -> 
+  update_int2ptr f b ma lo sz x = Some (b, lo + x - ma - 1).
+Proof.
+  intros.
+  assert (x = ma + 1 + (lo + x - ma - 1 - lo)) as EQ.
+    auto with zarith.
+  rewrite EQ at 1.
+  apply update_int2ptr_spec1; auto with zarith.
+Qed.      
+
+Lemma update_int2ptr_spec2 : forall f b ma lo sz ofs x,
+  update_int2ptr f b ma lo sz x = Some (b, ofs) ->
+  x = ma + 1 + (ofs - lo) \/ f x = Some (b, ofs).
+Proof.
+  induction sz; intros ofs x H; simpl in *; auto.
+    unfold update in H.
+    destruct (zeq x (ma + 1 + Z_of_nat sz)); subst.
+      inversion H; subst.
+      auto with zarith.
+
+      apply IHsz in H; auto.
+Qed.      
+
+Lemma O_le_Z_of_nat : forall n, Z_of_nat n >= 0.
+Proof.
+  destruct n; auto using O_lt_Z_of_S with zarith.
+Qed.
+
+Lemma update_int2ptr_spec3 : forall f b ma lo sz ofs x,
+  update_int2ptr f b ma lo sz x = Some (b, ofs) ->
+  lo <= ofs < lo + Z_of_nat sz \/ f x = Some (b, ofs).
+Proof.
+  induction sz; intros ofs x H; simpl in *; auto.
+    unfold update in H.
+    rewrite Zpos_P_of_succ_nat.
+    destruct (zeq x (ma + 1 + Z_of_nat sz)); subst.
+      inversion H; subst.
+      auto using O_le_Z_of_nat with zarith.
+
+      apply IHsz in H; auto. 
+      destruct H as [H | H]; auto with zarith.
+Qed.      
+ 
+Lemma int2ptr_some_is_false : forall int2ptr0 
+  (mem_access0: block -> Z -> option permission) (bounds0: block -> Z * Z) 
+  (ptr2int0: block -> Z -> option Z) nextblock0 (ofs:Z) z,
+  int2ptr0 z = Some (nextblock0, ofs) ->
+  (forall b, 0 < b < nextblock0 \/ bounds0 b = (0,0)) ->
+  (forall b ofs, ofs < fst(bounds0 b) \/ ofs >= snd(bounds0 b) -> 
+    mem_access0 b ofs = None) ->
+  (forall b ofs, 
+    0 < b < nextblock0 /\ fst (bounds0 b) <= ofs < snd (bounds0 b) <-> 
+    exists z, ptr2int0 b ofs = Some z) ->
+  (forall b ofs z, ptr2int0 b ofs = Some z <-> int2ptr0 z = Some (b, ofs)) ->
+  False.
+Proof.
+  intros int2ptr0 mem_access0 bounds0 ptr2int0 nextblock0 ofs z H 
+    nextblock_noaccess0 bounds_noaccess0 cprop1 cprop2.
+  destruct (@cprop2 nextblock0 ofs z) as [J1 J2].
+  apply J2 in H.
+  assert (exists z, ptr2int0 nextblock0 ofs = Some z) as EXIST.
+    exists z. assumption.
+  destruct (@cprop1 nextblock0 ofs) as [J3 J4].
+  apply J4 in EXIST.
+  destruct EXIST as [EXIST _].
+  contradict EXIST; auto with zarith.
+Qed.
+
+Lemma update_int2ptr_spec4' : forall f b ma lo sz x,
+  x < ma + 1 \/ x >= ma + 1 + Z_of_nat sz -> 
+  update_int2ptr f b ma lo sz x = f x.
+Proof.
+  induction sz; intros x H; simpl in *; auto.
+    unfold update.
+    destruct (zeq x (ma + 1 + Z_of_nat sz)); subst.
+      destruct H as [H | H].
+        contradict H; auto using O_le_Z_of_nat with zarith. 
+
+        rewrite Zpos_P_of_succ_nat in H.
+        contradict H; auto with zarith. 
+
+      rewrite Zpos_P_of_succ_nat in H.
+      apply IHsz.
+      destruct H as [H | H]; auto.
+      right. auto with zarith.
+Qed.      
+
+Lemma update_int2ptr_spec4 : forall f b ma lo sz z,
+  z <= ma -> 
+  update_int2ptr f b ma lo sz z = f z.
+Proof.
+  intros.
+  apply update_int2ptr_spec4'; auto with zarith.
+Qed.
+
+Lemma update_int2ptr_spec5 : forall f b ma lo sz z b' ofs,
+  update_int2ptr f b ma lo sz z = Some (b', ofs) ->
+  b <> b' ->
+  f z = Some (b', ofs). 
+Proof.
+  induction sz; intros z b' ofs H1 H2; simpl in *; auto.
+    unfold update in H1.  
+    destruct (zeq z (ma + 1 + Z_of_nat sz)); subst; auto.
+      inversion H1; subst.
+      contradict H2; auto.
+Qed.
+
 Program Definition alloc (m: mem) (lo hi: Z) :=
   (mkmem (update m.(nextblock) 
                  (fun ofs => Undef)
@@ -356,7 +550,17 @@
                  m.(mem_access))
          (update m.(nextblock) (lo, hi) m.(bounds))
          (Zsucc m.(nextblock))
-         _ _ _ _,
+         (m.(maxaddress) + if zlt lo hi then hi - lo else 0)
+         (update m.(nextblock) 
+                 (fun ofs => 
+                   if zle lo ofs && zlt ofs hi then 
+                     Some (m.(maxaddress) + 1 + (ofs - lo)) 
+                   else None
+                 ) 
+                 m.(ptr2int))
+         (update_int2ptr m.(int2ptr) m.(nextblock) m.(maxaddress) lo 
+           (nat_of_Z (hi - lo)))
+         _ _ _ _ _ _,
    m.(nextblock)).
 Next Obligation.
   generalize (nextblock_pos m). omega. 
@@ -384,8 +588,118 @@
 destruct (zeq b (nextblock m)); auto.
 apply noread_undef.
 Qed.
-
-
+Next Obligation.
+  generalize (maxaddress_pos m).
+  destruct (zlt lo hi); omega.
+Qed.
+Next Obligation.
+  destruct m. simpl.
+  destruct conversion_props0 as [cprop1 [cprop2 [cprop3 [cprop4 cprop5]]]].
+  unfold update.
+  split.
+    intros b ofs.
+    destruct (zeq b nextblock0); subst.
+      destruct (zle lo ofs); simpl.
+        destruct (zlt ofs hi); simpl.
+          split; intro H.
+            exists (maxaddress0 + 1 + (ofs - lo)). auto.
+            auto with zarith.
+          split; intro H.
+            destruct H as [_ [_ H]]. contradict H; auto.
+            destruct H as [z1 H]. inversion H.
+        split; intro H.
+          destruct H as [_ [H _]]. contradict H; auto.
+          destruct H as [z1 H]. inversion H.
+     split; intros H.
+       destruct H as [H1 H2].
+       apply cprop1. split; auto with zarith.
+
+       apply cprop1 in H. destruct H as [H1 H2]. 
+       split; auto with zarith.
+  split.
+    intros b ofs z.
+    destruct (zeq b nextblock0); subst; auto.
+      destruct (zle lo ofs); simpl.
+        destruct (zlt ofs hi); simpl.
+          split; intro H.
+            inversion H; subst.
+            apply update_int2ptr_spec1. 
+              rewrite nat_of_Z_eq; auto with zarith.
+           
+            apply update_int2ptr_spec2 in H; auto.
+            destruct H as [H | H]; subst; auto.
+              eapply int2ptr_some_is_false in H; eauto.
+              inversion H.
+
+          split; intro H; try solve [inversion H].
+            apply update_int2ptr_spec3 in H; auto.
+            destruct H as [H | H]; subst; auto.
+              destruct (@Z_le_dec lo hi) as [J | J].
+                rewrite nat_of_Z_eq in H; auto with zarith. 
+                assert (lo + (hi - lo) = hi) as EQ. auto with zarith.
+                contradict H; auto with zarith.
+
+                rewrite nat_of_Z_neg in H; auto with zarith.
+                simpl in H. contradict H; auto with zarith.
+              eapply int2ptr_some_is_false in H; eauto.
+              inversion H.
+        split; intro H; try solve [inversion H].
+          apply update_int2ptr_spec3 in H; auto.
+          destruct H as [H | H]; subst; auto.
+            contradict H; auto with zarith.
+
+            eapply int2ptr_some_is_false in H; eauto.
+            inversion H.
+      split; intro H.   
+        destruct (@cprop2 b ofs z) as [J1 J2].
+        assert (J3:=H).
+        apply J1 in H.
+        apply cprop5 in J3.
+        rewrite update_int2ptr_spec4; auto with zarith.
+
+        apply update_int2ptr_spec5 in H; auto.
+        apply cprop2; auto.
+  split.
+    intros b ofs1 ofs2 z1 z2 H1 H2.               
+    destruct (zeq b nextblock0); subst; eauto. 
+      destruct (zle lo ofs1); simpl in H1; try solve [inversion H1].
+      destruct (zlt ofs1 hi); simpl in H1; try solve [inversion H1].
+      destruct (zle lo ofs2); simpl in H2; try solve [inversion H2].
+      destruct (zlt ofs2 hi); simpl in H2; try solve [inversion H2].
+      inversion H1; subst.
+      inversion H2; subst.
+      clear H1 H2.
+      auto with zarith.      
+  split.
+    intros b1 b2 ofs1 ofs2 z1 z2 H1 H2 H3.               
+    destruct (zeq b1 nextblock0); subst; eauto. 
+      destruct (zeq b2 nextblock0); subst; eauto. 
+      destruct (zle lo ofs1); simpl in H2; try solve [inversion H2].
+      destruct (zlt ofs1 hi); simpl in H2; try solve [inversion H2].
+      inversion H2; subst.
+      clear H2.
+      apply cprop5 in H3.
+      auto with zarith.      
+
+      destruct (zeq b2 nextblock0); subst; eauto. 
+      destruct (zle lo ofs2); simpl in H3; try solve [inversion H3].
+      destruct (zlt ofs2 hi); simpl in H3; try solve [inversion H3].
+      inversion H3; subst.
+      clear H3.
+      apply cprop5 in H2.
+      auto with zarith.      
+      
+    intros b ofs z H.
+    destruct (zeq b nextblock0); subst; eauto. 
+      destruct (zle lo ofs); simpl in H; try solve [inversion H].
+      destruct (zlt ofs hi); simpl in H; try solve [inversion H].
+      inversion H; subst.
+      destruct (zlt lo hi); simpl in H; auto with zarith.      
+
+      apply cprop5 in H.
+      destruct (zlt lo hi); simpl in H; auto with zarith.      
+Qed.          
+         
 (** Freeing a block between the given bounds.
   Return the updated memory state where the given range of the given block
   has been invalidated: future reads and writes to this
@@ -394,8 +708,8 @@
 Definition clearN (m: block -> Z -> memval) (b: block) (lo hi: Z) : 
     block -> Z -> memval :=
    fun b' ofs => if zeq b' b 
-                         then if zle lo ofs && zlt ofs hi then Undef else m b' ofs
-                         else m b' ofs.
+                 then if zle lo ofs && zlt ofs hi then Undef else m b' ofs
+                 else m b' ofs.
 
 Lemma clearN_in:
    forall m b lo hi ofs, lo <= ofs < hi -> clearN m b lo hi b ofs = Undef.
@@ -416,14 +730,34 @@
 elimtype False; omega.
 Qed.
 
+Definition clear_ptr2int (f: block -> Z -> option Z) (b: block) (lo hi: Z)
+  : block -> Z -> option Z :=
+fun b' ofs => if zeq b' b 
+              then if zle lo ofs && zlt ofs hi then None else f b' ofs
+              else f b' ofs.
+  
+Definition clear_int2ptr (f: Z -> option (block * Z)) (b: block) (lo hi: Z)
+  : Z -> option (block * Z) :=
+fun i => match f i with
+         | Some (b', ofs) =>
+             if zeq b' b 
+             then if zle lo ofs && zlt ofs hi then None else Some (b', ofs)
+             else Some (b', ofs)
+         | None => None
+         end.
 
 Program Definition unchecked_free (m: mem) (b: block) (lo hi: Z): mem :=
   mkmem (clearN m.(mem_contents) b lo hi)
         (update b 
-                (fun ofs => if zle lo ofs && zlt ofs hi then None else m.(mem_access) b ofs)
+                (fun ofs => if zle lo ofs && zlt ofs hi then None 
+                            else m.(mem_access) b ofs)
                 m.(mem_access))
         m.(bounds)
-        m.(nextblock) _ _ _ _.
+        m.(nextblock)
+        m.(maxaddress)
+        m.(ptr2int)
+        m.(int2ptr)
+         _ _ _ _ _ _.
 Next Obligation.
   apply nextblock_pos. 
 Qed.
@@ -447,6 +781,12 @@
   apply noread_undef.
   apply noread_undef.
 Qed.
+Next Obligation.
+  apply maxaddress_pos.
+Qed.
+Next Obligation.
+  destruct m. simpl in *. auto.
+Qed.
 
 Definition free (m: mem) (b: block) (lo hi: Z): option mem :=
   if range_perm_dec m b lo hi Freeable 
@@ -488,7 +828,7 @@
 
 Definition loadv (chunk: memory_chunk) (m: mem) (addr: val) : option val :=
   match addr with
-  | Vptr b ofs => load chunk m b (Int.unsigned ofs)
+  | Vptr b ofs => load chunk m b (Int.signed 31 ofs)
   | _ => None
   end.
 
@@ -562,29 +902,51 @@
   intros. apply getN_exten. intros. apply setN_outside. omega. 
 Qed.
 
-Lemma setN_noread_undef:
-  forall m b ofs bytes (RP: range_perm m b ofs (ofs + Z_of_nat (length bytes)) Writable),
-  forall b' ofs',
-  perm m b' ofs' Readable \/
-  update b (setN bytes ofs (mem_contents m b)) (mem_contents m) b' ofs' = Undef.
-Proof.
-  intros. unfold update. destruct (zeq b' b). subst b'.
-  assert (ofs <= ofs' < ofs + Z_of_nat (length bytes)
-         \/ ofs' < ofs
-         \/ ofs' >= ofs + Z_of_nat (length bytes)) by omega.
-  destruct H. left. apply perm_implies with Writable; auto with mem. 
-  rewrite setN_outside; auto. apply noread_undef; auto. 
-  apply noread_undef; auto.
+Lemma getN_update_s: forall f f' mb n ofs bs (Heq: getN n ofs f' = bs),
+  bs = getN n ofs (update mb f' f mb).
+Proof.
+  induction n; simpl; intros; auto.
+    destruct bs as [|bs]; inv Heq.
+    rewrite <- IHn with (bs:=getN n (ofs + 1) f'); auto.
+    rewrite update_s; auto.
+Qed.
+
+Lemma getN_update_setN_s: forall M mb n ofs bs (Heq: n = length bs),
+  bs = getN n ofs
+         (update mb (setN bs ofs (mem_contents M mb))
+            (mem_contents M) mb).
+Proof.
+  intros. subst.
+  erewrite <- getN_update_s; eauto.
+  rewrite getN_setN_same; auto.
+Qed.
+
+Lemma getN_Undef__list_repeat_Undef: forall sz0 z,
+  getN sz0 z (fun _ : Z => Undef) = list_repeat sz0 Undef.
+Proof.
+  induction sz0; simpl; auto.
+    congruence.
 Qed.
 
 Lemma store_noread_undef:
   forall m ch b ofs (VA: valid_access m ch b ofs Writable) v,
-  forall b' ofs', 
-  perm m b' ofs' Readable \/ 
-  update b (setN (encode_val ch v) ofs (mem_contents m b)) (mem_contents m) b' ofs' = Undef.
+       forall b' ofs', 
+       perm m b' ofs' Readable \/ 
+        update b (setN (encode_val ch v) ofs (mem_contents m b)) (mem_contents m) b' ofs' = Undef.
 Proof.
-  intros. destruct VA. apply setN_noread_undef. 
-  rewrite encode_val_length. rewrite <- size_chunk_conv. auto.
+  intros.
+  destruct VA as [? _].
+  unfold update.
+  destruct (zeq b' b).
+  subst b'.
+  assert (ofs <= ofs' < ofs + size_chunk ch \/ (ofs' < ofs \/ ofs' >= ofs + size_chunk ch)) by omega.
+  destruct H0.
+  exploit (H ofs'); auto; intro.
+  eauto with mem.
+  rewrite setN_outside.
+  destruct (noread_undef m b ofs'); auto.
+  rewrite encode_val_length. rewrite <- size_chunk_conv; auto.
+  destruct (noread_undef m b' ofs'); auto.
 Qed.
 
 (** [store chunk m b ofs v] perform a write in memory state [m].
@@ -600,10 +962,15 @@
                     m.(mem_access)
                     m.(bounds)
                     m.(nextblock)
+                    m.(maxaddress)
+                    m.(ptr2int)
+                    m.(int2ptr)
                     m.(nextblock_pos)
                     m.(nextblock_noaccess)
                     m.(bounds_noaccess)
-                    (store_noread_undef m chunk b ofs VA v))
+                    (store_noread_undef m chunk b ofs VA v)
+                    m.(maxaddress_pos)
+                    m.(conversion_props))
  | right _ => None
  end.
 
@@ -612,36 +979,17 @@
 
 Definition storev (chunk: memory_chunk) (m: mem) (addr v: val) : option mem :=
   match addr with
-  | Vptr b ofs => store chunk m b (Int.unsigned ofs) v
+  | Vptr b ofs => store chunk m b (Int.signed 31 ofs) v
   | _ => None
   end.
 
-(** [storebytes m b ofs bytes] stores the given list of bytes [bytes]
-  starting at location [(b, ofs)].  Returns updated memory state
-  or [None] if the accessed locations are not writable. *)
-
-Definition storebytes (m: mem) (b: block) (ofs: Z) (bytes: list memval) : option mem :=
-  match range_perm_dec m b ofs (ofs + Z_of_nat (length bytes)) Writable with
-  | left RP =>
-      Some (mkmem
-             (update b (setN bytes ofs (m.(mem_contents) b)) m.(mem_contents))
-             m.(mem_access)
-             m.(bounds)
-             m.(nextblock)
-             m.(nextblock_pos)
-             m.(nextblock_noaccess)
-             m.(bounds_noaccess)
-             (setN_noread_undef m b ofs bytes RP))
-  | right _ =>
-      None
-  end.
-
 (** [drop_perm m b lo hi p] sets the permissions of the byte range
     [(b, lo) ... (b, hi - 1)] to [p].  These bytes must have permissions
     at least [p] in the initial memory state [m].
     Returns updated memory state, or [None] if insufficient permissions. *)
 
-Program Definition drop_perm (m: mem) (b: block) (lo hi: Z) (p: permission): option mem :=
+Program Definition drop_perm (m: mem) (b: block) (lo hi: Z) (p: permission)
+  : option mem :=
   if range_perm_dec m b lo hi p then
     Some (mkmem (update b 
                         (fun ofs => if zle lo ofs && zlt ofs hi && negb (perm_order_dec p Readable)
@@ -650,7 +998,12 @@
                 (update b
                         (fun ofs => if zle lo ofs && zlt ofs hi then Some p else m.(mem_access) b ofs)
                         m.(mem_access))
-                m.(bounds) m.(nextblock) _ _ _ _)
+                m.(bounds) 
+                m.(nextblock) 
+                m.(maxaddress)
+                m.(ptr2int)
+                m.(int2ptr)
+                _ _ _ _ _ _)
   else None.
 Next Obligation.
   destruct m; auto.
@@ -673,6 +1026,15 @@
   eapply noread_undef; eauto.
   eapply noread_undef; eauto.
 Qed.
+Next Obligation.
+  destruct m; auto.
+Qed.
+Next Obligation.
+  destruct m; simpl in *.
+  destruct conversion_props0 as [cprop1 [cprop2 [cprop3 [cprop4 cprop5]]]].
+  unfold update, range_perm, perm, perm_order', mem_access in *.
+  split; auto.
+Qed.
 
 (** * Properties of the memory operations *)
 
@@ -735,14 +1097,19 @@
   apply decode_val_type. 
 Qed.
 
+Theorem load_chunk:
+  forall m chunk b ofs v,
+  Mem.load chunk m b ofs = Some v ->
+  Val.has_chunk v chunk.
+Proof.
+  intros. exploit load_result; eauto; intros. rewrite H0. 
+  apply decode_val_chunk. 
+Qed.
+
 Theorem load_cast:
   forall m chunk b ofs v,
   load chunk m b ofs = Some v ->
   match chunk with
-  | Mint8signed => v = Val.sign_ext 8 v
-  | Mint8unsigned => v = Val.zero_ext 8 v
-  | Mint16signed => v = Val.sign_ext 16 v
-  | Mint16unsigned => v = Val.zero_ext 16 v
   | Mfloat32 => v = Val.singleoffloat v
   | _ => True
   end.
@@ -752,6 +1119,7 @@
   intros. subst v. apply decode_val_cast. 
 Qed.
 
+(*
 Theorem load_int8_signed_unsigned:
   forall m b ofs,
   load Mint8signed m b ofs = option_map (Val.sign_ext 8) (load Mint8unsigned m b ofs).
@@ -777,25 +1145,7 @@
   destruct (proj_bytes cl); auto. rewrite decode_int16_signed_unsigned. auto.
   rewrite pred_dec_false; auto.
 Qed.
-
-(** ** Properties related to [loadbytes] *)
-
-Theorem range_perm_loadbytes:
-  forall m b ofs len,
-  range_perm m b ofs (ofs + len) Readable ->
-  exists bytes, loadbytes m b ofs len = Some bytes.
-Proof.
-  intros. econstructor. unfold loadbytes. rewrite pred_dec_true; eauto. 
-Qed.
-
-Theorem loadbytes_range_perm:
-  forall m b ofs len bytes,
-  loadbytes m b ofs len = Some bytes ->
-  range_perm m b ofs (ofs + len) Readable.
-Proof.
-  intros until bytes. unfold loadbytes.
-  destruct (range_perm_dec m b ofs (ofs + len) Readable). auto. congruence.
-Qed.
+*)
 
 Theorem loadbytes_load:
   forall chunk m b ofs bytes,
@@ -839,14 +1189,6 @@
   inv H. apply getN_length.
 Qed.
 
-Theorem loadbytes_empty:
-  forall m b ofs n,
-  n <= 0 -> loadbytes m b ofs n = Some nil.
-Proof.
-  intros. unfold loadbytes. rewrite pred_dec_true. rewrite nat_of_Z_neg; auto.
-  red; intros. omegaContradiction.
-Qed.
-  
 Lemma getN_concat:
   forall c n1 n2 p,
   getN (n1 + n2)%nat p c = getN n1 p c ++ getN n2 (p + Z_of_nat n1) c.
@@ -947,6 +1289,16 @@
 Variable v: val.
 Variable m2: mem.
 Hypothesis STORE: store chunk m1 b ofs v = Some m2.
+(*
+Lemma store_result:
+  m2 = unchecked_store chunk m1 b ofs v.
+Proof.
+  unfold store in STORE.
+  destruct (valid_access_dec m1 chunk b ofs Writable).
+  congruence. 
+  congruence.
+Qed.
+*)
 
 Lemma store_access: mem_access m2 = mem_access m1.
 Proof.
@@ -1056,7 +1408,61 @@
 Proof.
   intros.
   destruct (load_store_similar chunk) as [v' [A B]]. auto.
-  rewrite A. decEq. eapply decode_encode_val_similar; eauto. 
+  rewrite A. decEq. eapply decode_encode_val_similar; eauto using chunk_eq_refl.
+Qed.
+
+Theorem load_store_exact_same:
+  Val.has_chunk v chunk ->
+  load chunk m2 b ofs = Some v.
+Proof.
+  intros.
+  destruct (load_store_similar chunk) as [v' [A B]]. auto.
+  rewrite A. decEq. clear A STORE.
+  destruct v, chunk, v'; simpl in *; try inv H; try inv B; try solve [
+    auto |
+    destruct (eq_nat_dec n n); congruence
+  ].
+
+    destruct (eq_nat_dec n n); try congruence.
+    rewrite Int.repr_unsigned in B. auto.
+
+    rewrite <- H in B. auto.
+Qed.
+
+Lemma load_store_same': forall
+  (Hinv: forall bs, 
+     bs = Mem.getN (size_chunk_nat chunk) ofs (Mem.mem_contents m1 b) ->
+     bs = encode_val chunk (decode_val chunk bs))
+  (Hld: Some v = Mem.load chunk m1 b ofs),
+  m1 = m2.
+Proof.
+  intros.
+  unfold store in STORE.
+  unfold load in Hld.
+  remember (Mem.valid_access_dec m1 chunk b ofs Readable) as R1.
+  destruct R1; inv Hld.
+  remember (Mem.valid_access_dec m1 chunk b ofs Writable) as R2.
+  destruct R2; inv STORE.
+  destruct m1. simpl.
+  apply mkmem_ext; auto.
+  rewrite <- Hinv; auto.
+  apply Axioms.extensionality. intro b0.
+  apply Axioms.extensionality. intro ofs0.
+  unfold update.
+  destruct (zeq b0 b); subst; auto.
+  clear.
+  generalize dependent ofs.
+  generalize dependent ofs0.
+  generalize (mem_contents0 b).
+  generalize (size_chunk_nat chunk). clear.
+  induction n; simpl; intros; auto.
+    rewrite getN_exten with (c2:=update ofs (m ofs) m).
+      rewrite <- IHn.
+      rewrite update_stable; auto.
+
+      intros.
+      rewrite update_o; auto.
+        omega.
 Qed.
 
 Theorem load_store_other:
@@ -1108,10 +1514,10 @@
   unfold update. destruct (zeq b' b). subst b'.
   destruct H. congruence.
   destruct (zle n 0). 
-  rewrite (nat_of_Z_neg _ z). auto.
-  destruct H. omegaContradiction.
+  rewrite (nat_of_Z_neg n). auto.
+  destruct H. omega. omega. 
   apply getN_setN_outside. rewrite encode_val_length. rewrite <- size_chunk_conv.
-  rewrite nat_of_Z_eq. auto. omega. 
+  rewrite nat_of_Z_eq. auto. omega. omega.
   auto.
   red; intros. eauto with mem.
   rewrite pred_dec_false. auto.
@@ -1192,7 +1598,7 @@
     assert (length mvl = sz). 
       generalize (encode_val_length chunk v). rewrite <- H1. rewrite SZ. 
       simpl; congruence.
-    rewrite H4. rewrite size_chunk_conv in z0. omega. 
+    rewrite H4. rewrite size_chunk_conv in g0. omega. 
   contradiction.
 
 (* 3. ofs > ofs':
@@ -1210,11 +1616,133 @@
     rewrite setN_outside. rewrite update_s. auto. omega.
   assert (~memval_valid_first (c' ofs)).
     rewrite SZ' in PSHAPE. simpl in PSHAPE. inv PSHAPE. 
-    apply H4. apply getN_in. rewrite size_chunk_conv in z. 
-    rewrite SZ' in z. rewrite inj_S in z. omega. 
+    apply H4. apply getN_in. rewrite size_chunk_conv in g. 
+    rewrite SZ' in g. rewrite inj_S in g. omega. 
   contradiction.
 Qed.
 
+Lemma int2ptr_store : forall z, int2ptr m1 z = int2ptr m2 z. 
+Proof.
+  intro z.
+  unfold store in STORE. 
+  destruct ( valid_access_dec m1 chunk b ofs Writable); inv STORE.
+  auto.
+Qed.
+
+Lemma ptr2int_store : forall b1 ofs1, ptr2int m1 b1 ofs1 = ptr2int m2 b1 ofs1.
+Proof.
+  intro z.
+  unfold store in STORE. 
+  destruct ( valid_access_dec m1 chunk b ofs Writable); inv STORE.
+  auto.
+Qed.
+
+Lemma store_range_perm_1:
+  forall b' lo' hi' p,
+  Mem.range_perm m1 b' lo' hi' p -> Mem.range_perm m2 b' lo' hi' p.
+Proof.
+  intros.
+  unfold Mem.range_perm in *.
+  intros ofs0 J.
+  apply H in J.
+  eapply perm_store_1; eauto.
+Qed.
+
+Definition ld_st_ld_rel v1 v1' v2 b1 b2 ofs1 ofs2 m1 m2 M :=
+  ((v1 = v1' /\ 
+   (b1 <> b2 \/ ofs1 + size_chunk m1 <= ofs2 \/ ofs2 + size_chunk m2 <= ofs1))
+  \/ 
+   (v1 = decode_val m1 (Mem.getN (size_chunk_nat m1) ofs1
+           (Mem.setN (encode_val m2 v2) ofs2 (Mem.mem_contents M b2))) /\
+    v1' = decode_val m1 (Mem.getN (size_chunk_nat m1) ofs1 
+            (Mem.mem_contents M b2)) /\
+    (b1 = b2 /\ ofs1 + size_chunk m1 > ofs2 /\ ofs2 + size_chunk m2 > ofs1))).
+
+Lemma store_preserves_load_inv_aux': forall b1 chunk1 ofs1 v1,
+  Mem.load chunk1 m2 b1 ofs1 = Some v1 ->
+  exists v1',
+    Mem.load chunk1 m1 b1 ofs1 = Some v1' /\
+    ld_st_ld_rel v1 v1' v b1 b ofs1 ofs chunk1 chunk m1.
+Proof.
+  intros. unfold ld_st_ld_rel.
+  destruct (zeq b1 b); subst; 
+    try solve [erewrite <- load_store_other; eauto; exists v1; eauto].
+  destruct (zle (ofs1 + size_chunk chunk1) ofs);
+    try solve [erewrite <- load_store_other; eauto; exists v1; split; auto].
+  destruct (zle (ofs + size_chunk chunk) ofs1);
+    try solve [erewrite <- load_store_other; eauto; exists v1; split; auto].
+  assert (valid_access m1 chunk1 b ofs1 Readable) as J.
+    apply load_valid_access in H.
+    eapply store_valid_access_2; eauto.
+  unfold load in *.
+  destruct (valid_access_dec m1 chunk1 b ofs1 Readable); try congruence.
+  exists (decode_val chunk1
+           (getN (size_chunk_nat chunk1) ofs1 (Mem.mem_contents m1 b))).
+  split; auto.
+  right.
+  split; auto.
+  destruct (valid_access_dec m2 chunk1 b ofs1 Readable); inv H.
+  erewrite store_mem_contents; eauto.
+  unfold update.
+  destruct (zeq b b); try congruence.
+Qed.
+
+Lemma store_preserves_load_inv_aux: forall b1 chunk1 ofs1 v1,
+  Mem.load chunk1 m2 b1 ofs1 = Some v1 ->
+  exists v1',
+    Mem.load chunk1 m1 b1 ofs1 = Some v1' /\
+    ((v1 = v1' /\
+     (b1 <> b \/ ofs1 + size_chunk chunk1 <= ofs \/ 
+      ofs + size_chunk chunk <= ofs1))
+    \/
+     ((forall b0 ofs0, v1 = Vptr b0 ofs0 -> v1 = v /\ chunk1 = chunk) /\
+      (b1 = b /\ ofs1 + size_chunk chunk1 > ofs /\ 
+       ofs + size_chunk chunk > ofs1))).
+Proof.
+  intros.
+  destruct (zeq b1 b); subst;
+    try solve [erewrite <- load_store_other; eauto; exists v1; eauto].
+  destruct (zle (ofs1 + size_chunk chunk1) ofs);
+    try solve [erewrite <- load_store_other; eauto; exists v1; split; auto].
+  destruct (zle (ofs + size_chunk chunk) ofs1);
+    try solve [erewrite <- load_store_other; eauto; exists v1; split; auto].
+  assert (exists v1', load chunk1 m1 b ofs1 = Some v1') as J.
+    apply load_valid_access in H.
+    apply valid_access_load.
+    eapply store_valid_access_2; eauto.
+  destruct J as [v1' J].
+  exists v1'.
+  split; auto.
+    right.
+    split; auto.
+      intros. subst.
+      eapply load_pointer_store in H; eauto.
+      destruct H as [H | H].
+        destruct H as [J1 [J2 [J3 [J4 J5]]]]; subst; auto.
+        destruct H as [H | [H | H]]; try solve [congruence | omega].
+Qed.
+
+Lemma store_preserves_load_inv: forall b1 ofs1 v1 chunk1,
+  load chunk1 m2 b1 ofs1 = Some v1 ->
+  exists v1',
+    load chunk1 m1 b1 ofs1 = Some v1' /\
+    (v1 = v1' \/ 
+     (forall b0 ofs0, v1 = Vptr b0 ofs0 -> v1 = v /\ chunk1 = chunk)).
+Proof.
+  intros.
+  eapply store_preserves_load_inv_aux in H; eauto.
+  destruct H as [v1' [J1 [[J2 J3] | [J2 J3]]]]; subst; eauto.
+Qed.
+
+Lemma store_getN_out: forall blk ofs1 sz (Hneq: blk <> b),
+  getN sz ofs1 (Mem.mem_contents m1 blk) = 
+    getN sz ofs1 (Mem.mem_contents m2 blk).
+Proof.
+  intros.
+  rewrite store_mem_contents.
+  rewrite update_o; auto.
+Qed.
+
 End STORE.
 
 Hint Local Resolve perm_store_1 perm_store_2: mem.
@@ -1249,8 +1777,15 @@
   destruct (size_chunk_nat_pos chunk') as [sz' SZ']. 
   assert (ENC: encode_val chunk (Vptr v_b v_o) = list_repeat (size_chunk_nat chunk) Undef
                \/ pointer_encoding_shape (encode_val chunk (Vptr v_b v_o))).
-  destruct chunk; try (left; reflexivity). 
-  right. apply encode_pointer_shape. 
+  destruct chunk; try (left; reflexivity).
+  destruct (eq_nat_dec n 31).
+    rewrite e in *.
+    right. apply encode_pointer_shape. 
+
+    left. Transparent encode_val. simpl.  
+    destruct (eq_nat_dec n 31); auto.
+      contradict e; auto.
+
   assert (GET: getN (size_chunk_nat chunk) ofs c' = encode_val chunk (Vptr v_b v_o)).
   unfold c'. rewrite <- (encode_val_length chunk (Vptr v_b v_o)). 
   apply getN_setN_same.
@@ -1320,13 +1855,27 @@
           | _ => False
           end).
 Transparent encode_val.
-  unfold e, encode_val. rewrite SZ. destruct chunk; simpl; auto.
-  destruct e as [ | e1 el]. contradiction.
-  rewrite SZ'. simpl. rewrite setN_outside. rewrite update_s. 
-  destruct e1; try contradiction. 
-  destruct chunk'; auto. 
-  destruct chunk'; auto. intuition.
-  omega.
+  unfold e, encode_val. rewrite SZ. 
+  destruct chunk; simpl; auto.
+    destruct (eq_nat_dec n 31); subst; auto.
+
+    destruct e as [ | e1 el]. contradiction.
+    rewrite SZ'. simpl. rewrite setN_outside. rewrite update_s. 
+    destruct e1; try contradiction. 
+      destruct chunk'; auto. 
+        unfold decode_val. simpl.
+        destruct (eq_nat_dec n 31); auto.
+
+      subst.
+      destruct H1 as [H1 | H1].   
+        contradict H1; auto.
+    
+        destruct chunk'; auto.
+          unfold decode_val.
+          destruct (eq_nat_dec n0 31); subst.
+            contradict H1; auto.
+            simpl. auto.
+      omega.
 Qed.
 
 Lemma store_similar_chunks:
@@ -1344,13 +1893,105 @@
   destruct (valid_access_dec m chunk1 b ofs Writable);
   destruct (valid_access_dec m chunk2 b ofs Writable); auto.
   f_equal. apply mkmem_ext; auto. congruence.
+
   elimtype False.
-  destruct chunk1; destruct chunk2;  inv H0; unfold valid_access, align_chunk in *; try contradiction.
+  destruct chunk1; destruct chunk2;  inv H0; 
+    unfold valid_access, align_chunk in *; try contradiction.
+
+    unfold range_perm in v.
+    unfold size_chunk_nat, size_chunk in v.
+    rewrite H2 in v.
+    destruct (le_lt_dec n0 31).
+      destruct (le_lt_dec n1 31).
+        apply n; auto.
+        apply bytesize_chunk_neq with (n2:=n1) in l; auto.
+      destruct (le_lt_dec n1 31).
+        apply bytesize_chunk_neq with (n2:=n0) in l0; auto.
+        apply n; auto.
+
+    unfold range_perm in v.
+    unfold size_chunk_nat, size_chunk in v.
+    rewrite H2 in v.
+    destruct (le_lt_dec n0 31).
+      apply n; auto.
+      apply bytesize_chunk_gt_31 in l.
+        contradict H2; omega.
+
+    unfold range_perm in v.
+    unfold size_chunk_nat, size_chunk in v.
+    rewrite H2 in v.
+    destruct (le_lt_dec n0 31).
+      apply bytesize_chunk_le_31 in l. contradict H2; omega.
+
+      simpl in n. destruct v.
+      apply n. split; auto.
+
+    destruct (le_lt_dec n0 31).
+      unfold size_chunk_nat, size_chunk in n.
+      rewrite <- H2 in n.
+      apply n; auto.
+
+      apply bytesize_chunk_gt_31 in l.
+      rewrite <- H2 in l. contradict l; omega.
+
+    destruct (le_lt_dec n0 31).
+      apply bytesize_chunk_le_31 in l.
+      rewrite <- H2 in l. contradict l; omega.
+
+      unfold size_chunk_nat, size_chunk in n.
+      rewrite <- H2 in n.
+      apply n; auto.
+
   elimtype False.
-  destruct chunk1; destruct chunk2;  inv H0; unfold valid_access, align_chunk in *; try contradiction.
-Qed.
+  destruct chunk1; destruct chunk2; inv H0; 
+    unfold valid_access, align_chunk in *; try contradiction.
 
+    unfold range_perm in v.
+    unfold size_chunk_nat, size_chunk in v.
+    rewrite <- H2 in v.
+    destruct (le_lt_dec n0 31).
+      destruct (le_lt_dec n1 31).
+        apply n; auto.
+        apply bytesize_chunk_neq with (n2:=n1) in l; auto.
+      destruct (le_lt_dec n1 31).
+        apply bytesize_chunk_neq with (n2:=n0) in l0; auto.
+        apply n; auto.
+
+    unfold range_perm in v.
+    unfold size_chunk_nat, size_chunk in v.
+    rewrite <- H2 in v.
+    destruct (le_lt_dec n0 31).
+      apply n; auto.
+      apply bytesize_chunk_gt_31 in l; auto.
+        rewrite H2 in l. contradict l. omega.
+
+    unfold range_perm in v.
+    unfold size_chunk_nat, size_chunk in v.
+    rewrite <- H2 in v.
+    destruct (le_lt_dec n0 31).
+      apply bytesize_chunk_le_31 in l. contradict H2; omega.
+
+      simpl in n. destruct v.
+      apply n. rewrite H2 in *. split; auto. 
+
+    destruct (le_lt_dec n0 31).
+      unfold size_chunk_nat, size_chunk in n, v.
+      rewrite <- H2 in v.
+      apply n; auto.
+
+      apply bytesize_chunk_gt_31 in l.
+      rewrite <- H2 in l. contradict l; omega.
+
+    destruct (le_lt_dec n0 31).
+      apply bytesize_chunk_le_31 in l.
+      rewrite <- H2 in l. contradict l; omega.
+
+      unfold size_chunk_nat, size_chunk in n, v.
+      rewrite <- H2 in v.
+      apply n; auto.
+Qed.
 
+(*
 Theorem store_signed_unsigned_8:
   forall m b ofs v,
   store Mint8signed m b ofs v = store Mint8unsigned m b ofs v.
@@ -1384,6 +2025,7 @@
   store Mint16signed m b ofs (Vint (Int.sign_ext 16 n)) =
   store Mint16signed m b ofs (Vint n).
 Proof. intros. apply store_similar_chunks. apply encode_val_int16_sign_ext. Qed.
+*)
 
 Theorem store_float32_truncate:
   forall m b ofs n,
@@ -1391,269 +2033,6 @@
   store Mfloat32 m b ofs (Vfloat n).
 Proof. intros. apply store_similar_chunks. simpl. decEq. apply encode_float32_cast. Qed.
 
-(** ** Properties related to [storebytes]. *)
-
-Theorem range_perm_storebytes:
-  forall m1 b ofs bytes,
-  range_perm m1 b ofs (ofs + Z_of_nat (length bytes)) Writable ->
-  { m2 : mem | storebytes m1 b ofs bytes = Some m2 }.
-Proof.
-  intros. 
-  exists (mkmem
-             (update b (setN bytes ofs (m1.(mem_contents) b)) m1.(mem_contents))
-             m1.(mem_access)
-             m1.(bounds)
-             m1.(nextblock)
-             m1.(nextblock_pos)
-             m1.(nextblock_noaccess)
-             m1.(bounds_noaccess)
-             (setN_noread_undef m1 b ofs bytes H)).
-  unfold storebytes. 
-  destruct (range_perm_dec m1 b ofs (ofs + Z_of_nat (length bytes)) Writable).
-  decEq. decEq. apply proof_irr. 
-  contradiction.
-Qed.
-
-Theorem storebytes_store:
-  forall m1 b ofs chunk v m2,
-  storebytes m1 b ofs (encode_val chunk v) = Some m2 ->
-  (align_chunk chunk | ofs) ->
-  store chunk m1 b ofs v = Some m2.
-Proof.
-  unfold storebytes, store. intros. 
-  destruct (range_perm_dec m1 b ofs (ofs + Z_of_nat (length (encode_val chunk v))) Writable); inv H.
-  destruct (valid_access_dec m1 chunk b ofs Writable).
-  decEq. decEq. apply proof_irr. 
-  elim n. constructor; auto. 
-  rewrite encode_val_length in r. rewrite size_chunk_conv. auto.
-Qed.
-
-Theorem store_storebytes:
-  forall m1 b ofs chunk v m2,
-  store chunk m1 b ofs v = Some m2 ->
-  storebytes m1 b ofs (encode_val chunk v) = Some m2.
-Proof.
-  unfold storebytes, store. intros. 
-  destruct (valid_access_dec m1 chunk b ofs Writable); inv H.
-  destruct (range_perm_dec m1 b ofs (ofs + Z_of_nat (length (encode_val chunk v))) Writable).
-  decEq. decEq. apply proof_irr. 
-  destruct v0.  elim n. 
-  rewrite encode_val_length. rewrite <- size_chunk_conv. auto.
-Qed.
-
-Theorem storebytes_empty:
-  forall m b ofs, storebytes m b ofs nil = Some m.
-Proof.
-  intros. unfold storebytes. simpl. 
-  destruct (range_perm_dec m b ofs (ofs + 0) Writable).
-  decEq. destruct m; simpl; apply mkmem_ext; auto. 
-  apply extensionality. unfold update; intros. destruct (zeq x b); congruence.
-  elim n. red; intros; omegaContradiction.
-Qed.
-  
-Section STOREBYTES.
-Variable m1: mem.
-Variable b: block.
-Variable ofs: Z.
-Variable bytes: list memval.
-Variable m2: mem.
-Hypothesis STORE: storebytes m1 b ofs bytes = Some m2.
-
-Lemma storebytes_access: mem_access m2 = mem_access m1.
-Proof.
-  unfold storebytes in STORE. 
-  destruct (range_perm_dec m1 b ofs (ofs + Z_of_nat (length bytes)) Writable);
-  inv STORE.
-  auto.
-Qed.
-
-Lemma storebytes_mem_contents:
-   mem_contents m2 = update b (setN bytes ofs (m1.(mem_contents) b)) m1.(mem_contents).
-Proof.
-  unfold storebytes in STORE. 
-  destruct (range_perm_dec m1 b ofs (ofs + Z_of_nat (length bytes)) Writable);
-  inv STORE.
-  auto.
-Qed.
-
-Theorem perm_storebytes_1:
-  forall b' ofs' p, perm m1 b' ofs' p -> perm m2 b' ofs' p.
-Proof.
-  intros. unfold perm in *. rewrite storebytes_access; auto.
-Qed.
-
-Theorem perm_storebytes_2:
-  forall b' ofs' p, perm m2 b' ofs' p -> perm m1 b' ofs' p.
-Proof.
-  intros. unfold perm in *. rewrite storebytes_access in H; auto.
-Qed.
-
-Hint Local Resolve perm_storebytes_1 perm_storebytes_2: mem.
-
-Theorem storebytes_valid_access_1:
-  forall chunk' b' ofs' p,
-  valid_access m1 chunk' b' ofs' p -> valid_access m2 chunk' b' ofs' p.
-Proof.
-  intros. inv H. constructor; try red; auto with mem.
-Qed.
-
-Theorem storebytes_valid_access_2:
-  forall chunk' b' ofs' p,
-  valid_access m2 chunk' b' ofs' p -> valid_access m1 chunk' b' ofs' p.
-Proof.
-  intros. inv H. constructor; try red; auto with mem.
-Qed.
-
-Hint Local Resolve storebytes_valid_access_1 storebytes_valid_access_2: mem.
-
-Theorem nextblock_storebytes:
-  nextblock m2 = nextblock m1.
-Proof.
-  intros.
-  unfold storebytes in STORE. 
-  destruct (range_perm_dec m1 b ofs (ofs + Z_of_nat (length bytes)) Writable);
-  inv STORE.
-  auto.
-Qed.
-
-Theorem storebytes_valid_block_1:
-  forall b', valid_block m1 b' -> valid_block m2 b'.
-Proof.
-  unfold valid_block; intros. rewrite nextblock_storebytes; auto.
-Qed.
-
-Theorem storebytes_valid_block_2:
-  forall b', valid_block m2 b' -> valid_block m1 b'.
-Proof.
-  unfold valid_block; intros. rewrite nextblock_storebytes in H; auto.
-Qed.
-
-Hint Local Resolve storebytes_valid_block_1 storebytes_valid_block_2: mem.
-
-Theorem storebytes_range_perm:
-  range_perm m1 b ofs (ofs + Z_of_nat (length bytes)) Writable.
-Proof.
-  intros. 
-  unfold storebytes in STORE. 
-  destruct (range_perm_dec m1 b ofs (ofs + Z_of_nat (length bytes)) Writable);
-  inv STORE.
-  auto.
-Qed.
-
-Theorem bounds_storebytes:
-  forall b', bounds m2 b' = bounds m1 b'.
-Proof.
-  intros.
-  unfold storebytes in STORE. 
-  destruct (range_perm_dec m1 b ofs (ofs + Z_of_nat (length bytes)) Writable);
-  inv STORE.
-  auto.
-Qed.
-
-Theorem loadbytes_storebytes_same:
-  loadbytes m2 b ofs (Z_of_nat (length bytes)) = Some bytes.
-Proof.
-  intros. unfold storebytes in STORE. unfold loadbytes. 
-  destruct (range_perm_dec m1 b ofs (ofs + Z_of_nat (length bytes)) Writable);
-  try discriminate.
-  rewrite pred_dec_true. 
-  decEq. inv STORE; simpl. rewrite update_s. rewrite nat_of_Z_of_nat. 
-  apply getN_setN_same. 
-  red; eauto with mem. 
-Qed.
-
-Theorem loadbytes_storebytes_other:
-  forall b' ofs' len,
-  len >= 0 ->
-  b' <> b
-  \/ ofs' + len <= ofs
-  \/ ofs + Z_of_nat (length bytes) <= ofs' ->
-  loadbytes m2 b' ofs' len = loadbytes m1 b' ofs' len.
-Proof.
-  intros. unfold loadbytes.
-  destruct (range_perm_dec m1 b' ofs' (ofs' + len) Readable).
-  rewrite pred_dec_true. 
-  rewrite storebytes_mem_contents. decEq. 
-  unfold update. destruct (zeq b' b). subst b'. 
-  apply getN_setN_outside. rewrite nat_of_Z_eq; auto. intuition congruence.
-  auto.
-  red; auto with mem.
-  apply pred_dec_false. 
-  red; intros; elim n. red; auto with mem.
-Qed.
-
-Theorem load_storebytes_other:
-  forall chunk b' ofs',
-  b' <> b
-  \/ ofs' + size_chunk chunk <= ofs
-  \/ ofs + Z_of_nat (length bytes) <= ofs' ->
-  load chunk m2 b' ofs' = load chunk m1 b' ofs'.
-Proof.
-  intros. unfold load.
-  destruct (valid_access_dec m1 chunk b' ofs' Readable).
-  rewrite pred_dec_true. 
-  rewrite storebytes_mem_contents. decEq. 
-  unfold update. destruct (zeq b' b). subst b'. 
-  rewrite getN_setN_outside. auto. rewrite <- size_chunk_conv. intuition congruence.
-  auto.
-  destruct v; split; auto. red; auto with mem.
-  apply pred_dec_false. 
-  red; intros; elim n. destruct H0. split; auto. red; auto with mem.
-Qed.
-
-End STOREBYTES.
-
-Lemma setN_concat:
-  forall bytes1 bytes2 ofs c,
-  setN (bytes1 ++ bytes2) ofs c = setN bytes2 (ofs + Z_of_nat (length bytes1)) (setN bytes1 ofs c).
-Proof.
-  induction bytes1; intros.
-  simpl. decEq. omega.
-  simpl length. rewrite inj_S. simpl. rewrite IHbytes1. decEq. omega.
-Qed.
-
-Theorem storebytes_concat:
-  forall m b ofs bytes1 m1 bytes2 m2,
-  storebytes m b ofs bytes1 = Some m1 ->
-  storebytes m1 b (ofs + Z_of_nat(length bytes1)) bytes2 = Some m2 ->
-  storebytes m b ofs (bytes1 ++ bytes2) = Some m2.
-Proof.
-  intros. generalize H; intro ST1. generalize H0; intro ST2.
-  unfold storebytes; unfold storebytes in ST1; unfold storebytes in ST2.
-  destruct (range_perm_dec m b ofs (ofs + Z_of_nat(length bytes1)) Writable); try congruence.
-  destruct (range_perm_dec m1 b (ofs + Z_of_nat(length bytes1)) (ofs + Z_of_nat(length bytes1) + Z_of_nat(length bytes2)) Writable); try congruence.
-  destruct (range_perm_dec m b ofs (ofs + Z_of_nat (length (bytes1 ++ bytes2))) Writable).
-  inv ST1; inv ST2; simpl. decEq. apply mkmem_ext; auto.
-  apply extensionality; intros. unfold update. destruct (zeq x b); auto.
-  subst x. rewrite zeq_true. apply setN_concat.
-  elim n.   
-  rewrite app_length. rewrite inj_plus. red; intros.
-  destruct (zlt ofs0 (ofs + Z_of_nat(length bytes1))).
-  apply r. omega. 
-  eapply perm_storebytes_2; eauto. apply r0. omega.
-Qed.
-
-Theorem storebytes_split:
-  forall m b ofs bytes1 bytes2 m2,
-  storebytes m b ofs (bytes1 ++ bytes2) = Some m2 ->
-  exists m1,
-     storebytes m b ofs bytes1 = Some m1
-  /\ storebytes m1 b (ofs + Z_of_nat(length bytes1)) bytes2 = Some m2.
-Proof.
-  intros. 
-  destruct (range_perm_storebytes m b ofs bytes1) as [m1 ST1].
-  red; intros. exploit storebytes_range_perm; eauto. rewrite app_length. 
-  rewrite inj_plus. omega.
-  destruct (range_perm_storebytes m1 b (ofs + Z_of_nat (length bytes1)) bytes2) as [m2' ST2].
-  red; intros. eapply perm_storebytes_1; eauto. exploit storebytes_range_perm. 
-  eexact H. instantiate (1 := ofs0). rewrite app_length. rewrite inj_plus. omega.
-  auto.
-  assert (Some m2 = Some m2').
-  rewrite <- H. eapply storebytes_concat; eauto.
-  inv H0.
-  exists m1; split; auto. 
-Qed.
-
 (** ** Properties related to [alloc]. *)
 
 Section ALLOC.
@@ -1664,6 +2043,16 @@
 Variable b: block.
 Hypothesis ALLOC: alloc m1 lo hi = (m2, b).
 
+Lemma alloc_mem_contents:
+  update (Mem.nextblock m1) 
+                 (fun ofs => Undef)
+                 (Mem.mem_contents m1) = (Mem.mem_contents m2).
+Proof.
+  intros.
+  unfold alloc in ALLOC.
+  inversion ALLOC. auto.
+Qed.
+
 Theorem nextblock_alloc:
   nextblock m2 = Zsucc (nextblock m1).
 Proof.
@@ -1837,7 +2226,13 @@
 Proof.
   intros. exploit load_result; eauto. intro. rewrite H0. 
   injection ALLOC; intros. rewrite <- H2; simpl. rewrite <- H1.
-  rewrite update_s. destruct chunk; reflexivity. 
+  rewrite update_s. destruct chunk; try reflexivity. 
+  unfold decode_val.
+  rewrite proj_bytes_undef.
+  destruct (eq_nat_dec n 31); subst; auto.
+    assert (J:=size_chunk_nat_pos' (Mint n)). 
+    destruct (size_chunk_nat (Mint n)); simpl; auto.
+      contradict J; omega.
 Qed.
 
 Theorem load_alloc_same':
@@ -1852,6 +2247,64 @@
   eapply load_alloc_same; eauto.
 Qed.
 
+Lemma int2ptr_alloc_1 : forall z b1 ofs1,
+  int2ptr m1 z = Some (b1, ofs1) -> int2ptr m2 z = Some (b1, ofs1). 
+Proof.
+  intros.
+  injection ALLOC; intros; subst; simpl.
+  rewrite <- H.
+  apply update_int2ptr_spec4.
+  destruct (conversion_props m1) as [cprop1 [cprop2 [cprop3 [cprop4 cprop5]]]].
+  apply cprop2 in H.
+  apply cprop5 in H; auto with zarith.
+Qed.
+
+Lemma int2ptr_alloc_2 : forall z b1 ofs1,
+  int2ptr m1 z = None -> int2ptr m2 z = Some (b1, ofs1) -> b = b1.
+Proof.
+  intros.
+  injection ALLOC; intros; subst; simpl in *.
+  destruct (eq_block (nextblock m1) b1); auto.
+    apply update_int2ptr_spec5 in H0; auto.
+    rewrite H in H0. inversion H0.
+Qed.
+
+Lemma int2ptr_alloc_3 : forall z,
+  int2ptr m2 z = None -> int2ptr m1 z = None. 
+Proof.
+  intros.
+  remember (int2ptr m1 z) as R.
+  destruct R as [[b1 ofs1]|]; auto.
+  symmetry in HeqR.
+  apply int2ptr_alloc_1 in HeqR.
+  rewrite H in HeqR. inversion HeqR.
+Qed.
+
+Lemma ptr2int_alloc : forall b0 ofs0,
+  b0 < Mem.nextblock m1 -> ptr2int m1 b0 ofs0 = ptr2int m2 b0 ofs0.
+Proof.
+  intros b0 ofs0 Hless.
+  unfold alloc in ALLOC.
+  inv ALLOC.
+  destruct m1.
+  simpl in *.
+  unfold update.
+  destruct (zeq b0 nextblock0); subst; auto.
+    contradict Hless; auto with zarith.
+Qed.
+
+Lemma range_perm_alloc_other:
+  forall b' lo' hi' p,
+  Mem.range_perm m1 b' lo' hi' p ->
+  Mem.range_perm m2 b' lo' hi' p.
+Proof.
+  intros.
+  unfold Mem.range_perm in *.
+  intros ofs J.
+  apply H in J.
+  eapply perm_alloc_1; eauto.
+Qed.
+
 End ALLOC.
 
 Hint Local Resolve valid_block_alloc fresh_block_alloc valid_new_block: mem.
@@ -1889,6 +2342,19 @@
   congruence. congruence.
 Qed.
 
+Lemma free_getN_out: forall b ofs sz (Hneq: bf <> b),
+  Mem.getN sz ofs (Mem.mem_contents m1 b) = 
+    Mem.getN sz ofs (Mem.mem_contents m2 b).
+Proof.
+  intros.
+  rewrite free_result. 
+  unfold unchecked_free. simpl.
+  generalize ofs.
+  induction sz; simpl; intros; auto.
+    rewrite IHsz.
+    rewrite clearN_out; auto.
+Qed.
+
 Theorem nextblock_free:
   nextblock m2 = nextblock m1.
 Proof.
@@ -2033,6 +2499,33 @@
   red; intro; elim n. eapply valid_access_free_1; eauto. 
 Qed.
 
+Theorem load_free': forall (b : block)
+  (a : memory_chunk) (ofs : Z) (v : val)
+  (HeqR : Some v = load a m2 b ofs),
+  b <> bf \/ lo >= hi \/ ofs + size_chunk a <= lo \/ hi <= ofs.
+Proof.
+  intros.
+  symmetry in HeqR.
+  apply load_valid_access in HeqR.
+  destruct (zeq b bf); subst; auto.
+  right.
+  destruct (zlt lo hi); try omega.
+  destruct (zle (ofs + size_chunk a) lo); auto.
+  destruct (zle hi ofs); auto.
+  contradict HeqR.
+  eapply valid_access_free_2; eauto; try omega.
+Qed.
+
+Lemma int2ptr_free : forall z, int2ptr m1 z = int2ptr m2 z. 
+Proof.
+  intros. rewrite free_result. reflexivity.
+Qed.
+
+Lemma ptr2int_free : forall b1 ofs1, ptr2int m1 b1 ofs1 = ptr2int m2 b1 ofs1.
+Proof.
+  intros. rewrite free_result. reflexivity.
+Qed.
+
 End FREE.
 
 Hint Local Resolve valid_block_free_1 valid_block_free_2
@@ -2132,7 +2625,7 @@
   destruct (zlt ofs0 lo). eapply perm_drop_3; eauto. 
   destruct (zle hi ofs0). eapply perm_drop_3; eauto.
   apply perm_implies with p. eapply perm_drop_1; eauto. omega. 
-  generalize (size_chunk_pos chunk); intros. intuition. omegaContradiction. omegaContradiction.
+  generalize (size_chunk_pos chunk); intros. intuition. 
   eapply perm_drop_3; eauto.
 Qed.
 
@@ -2212,9 +2705,12 @@
   forall m1 m2, 
   mem_access m1 = mem_access m2 ->
   nextblock m1 = nextblock m2 ->
+  maxaddress m1 = maxaddress m2 ->
   (forall b, 0 < b < nextblock m1 -> bounds m1 b = bounds m2 b) ->
   (forall b ofs, perm_order' (mem_access m1 b ofs) Readable -> 
                           mem_contents m1 b ofs = mem_contents m2 b ofs) ->
+  (forall b ofs, ptr2int m1 b ofs = ptr2int m2 b ofs) ->
+  (forall i, int2ptr m1 i = int2ptr m2 i) ->
   m1 = m2.
 Proof.
   intros.
@@ -2232,25 +2728,35 @@
   destruct (nextblock_noaccess0 b); auto.
   destruct (nextblock_noaccess1 b); auto.
   congruence.
+
+  apply extensionality; intro b.
+  apply extensionality; intro ofs. 
+  auto.
+
+  apply extensionality; intro z.
+  auto.
 Qed.
 
 Theorem mem_ext:
   forall m1 m2, 
   perm m1 = perm m2 ->
   nextblock m1 = nextblock m2 ->
+  maxaddress m1 = maxaddress m2 ->
   (forall b, 0 < b < nextblock m1 -> bounds m1 b = bounds m2 b) ->
   (forall b ofs, loadbytes m1 b ofs 1 = loadbytes m2 b ofs 1) ->
+  (forall b ofs, ptr2int m1 b ofs = ptr2int m2 b ofs) ->
+  (forall i, int2ptr m1 i = int2ptr m2 i) ->
   m1 = m2.
 Proof.
-  intros.
+  intros m1 m2 H H0 H1 H2 H3 H4 H5.
   generalize (mem_access_ext _ _ H); clear H; intro.
   apply mem_ext'; auto.
   intros.
-  specialize (H2 b ofs).
-  unfold loadbytes in H2; simpl in H2.
+  specialize (H3 b ofs).
+  unfold loadbytes in H3; simpl in H3.
   destruct (range_perm_dec m1 b ofs (ofs+1)).
   destruct (range_perm_dec m2 b ofs (ofs+1)).
-  inv H2; auto.
+  inv H3; auto.
   contradict n.
   intros ofs' ?; assert (ofs'=ofs) by omega; subst ofs'.
   unfold perm, perm_order'.
@@ -2294,23 +2800,11 @@
   perm m2 b2 (ofs + delta) p.
 Proof.
   intros. 
-  assert (valid_access m1 Mint8unsigned b1 ofs p).
-    split. red; intros. simpl in H2. replace ofs0 with ofs by omega. auto.
+  assert (valid_access m1 (Mint 7) b1 ofs p).
+    split. red; intros. simpl in H2. rewrite bytesize_chunk_7_eq_1 in H2. replace ofs0 with ofs by omega. auto.
     simpl. apply Zone_divide.
   exploit mi_access; eauto. intros [A B].
-  apply A. simpl; omega. 
-Qed.
-
-Lemma range_perm_inj:
-  forall f m1 m2 b1 lo hi p b2 delta,
-  mem_inj f m1 m2 ->
-  range_perm m1 b1 lo hi p ->
-  f b1 = Some(b2, delta) ->
-  range_perm m2 b2 (lo + delta) (hi + delta) p.
-Proof.
-  intros; red; intros.
-  replace ofs with ((ofs - delta) + delta) by omega.
-  eapply perm_inj; eauto. apply H0. omega.
+  apply A. simpl; rewrite bytesize_chunk_7_eq_1; omega. 
 Qed.
 
 (** Preservation of loads. *)
@@ -2352,25 +2846,6 @@
   rewrite <- size_chunk_conv. exploit load_valid_access; eauto. intros [A B]. auto.
 Qed.
 
-Lemma loadbytes_inj:
-  forall f m1 m2 len b1 ofs b2 delta bytes1,
-  mem_inj f m1 m2 ->
-  loadbytes m1 b1 ofs len = Some bytes1 ->
-  f b1 = Some (b2, delta) ->
-  exists bytes2, loadbytes m2 b2 (ofs + delta) len = Some bytes2
-              /\ list_forall2 (memval_inject f) bytes1 bytes2.
-Proof.
-  intros. unfold loadbytes in *. 
-  destruct (range_perm_dec m1 b1 ofs (ofs + len) Readable); inv H0.
-  exists (getN (nat_of_Z len) (ofs + delta) (m2.(mem_contents) b2)).
-  split. apply pred_dec_true.  
-  replace (ofs + delta + len) with ((ofs + len) + delta) by omega.
-  eapply range_perm_inj; eauto with mem. 
-  apply getN_inj; auto. 
-  destruct (zle 0 len). rewrite nat_of_Z_eq; auto. omega. 
-  rewrite nat_of_Z_neg. simpl. red; intros; omegaContradiction. omega.
-Qed.
-
 (** Preservation of stores. *)
 
 Lemma setN_inj:
@@ -2507,99 +2982,6 @@
   eauto with mem.
 Qed.
 
-Lemma storebytes_mapped_inj:
-  forall f m1 b1 ofs bytes1 n1 m2 b2 delta bytes2,
-  mem_inj f m1 m2 ->
-  storebytes m1 b1 ofs bytes1 = Some n1 ->
-  meminj_no_overlap f m1 ->
-  f b1 = Some (b2, delta) ->
-  list_forall2 (memval_inject f) bytes1 bytes2 ->
-  exists n2,
-    storebytes m2 b2 (ofs + delta) bytes2 = Some n2
-    /\ mem_inj f n1 n2.
-Proof.
-  intros. inversion H. 
-  assert (range_perm m2 b2 (ofs + delta) (ofs + delta + Z_of_nat (length bytes2)) Writable).
-    replace (ofs + delta + Z_of_nat (length bytes2))
-       with ((ofs + Z_of_nat (length bytes1)) + delta).
-    eapply range_perm_inj; eauto with mem. 
-    eapply storebytes_range_perm; eauto.
-    rewrite (list_forall2_length H3). omega.
-  destruct (range_perm_storebytes _ _ _ _ H4) as [n2 STORE]. 
-  exists n2; split. eauto.
-  constructor.
-(* access *)
-  intros.
-  eapply storebytes_valid_access_1; [apply STORE |].
-  eapply mi_access0; eauto.
-  eapply storebytes_valid_access_2; [apply H0 |]. auto.
-(* mem_contents *)
-  intros.
-  assert (perm m1 b0 ofs0 Nonempty). eapply perm_storebytes_2; eauto. 
-  rewrite (storebytes_mem_contents _ _ _ _ _ H0).
-  rewrite (storebytes_mem_contents _ _ _ _ _ STORE).
-  unfold update. 
-  destruct (zeq b0 b1). subst b0.
-  (* block = b1, block = b2 *)
-  assert (b3 = b2) by congruence. subst b3.
-  assert (delta0 = delta) by congruence. subst delta0.
-  rewrite zeq_true.
-  apply setN_inj with (access := fun ofs => perm m1 b1 ofs Nonempty); auto.
-  destruct (zeq b3 b2). subst b3.
-  (* block <> b1, block = b2 *)
-  rewrite setN_other. auto.
-  intros.
-  assert (b2 <> b2 \/ ofs0 + delta0 <> (r - delta) + delta).
-    eapply meminj_no_overlap_perm; eauto. 
-    exploit storebytes_range_perm. eexact H0. 
-    instantiate (1 := r - delta). 
-    rewrite (list_forall2_length H3). omega.
-    eauto with mem.
-  destruct H9. congruence. omega.
-  (* block <> b1, block <> b2 *)
-  eauto.
-Qed.
-
-Lemma storebytes_unmapped_inj:
-  forall f m1 b1 ofs bytes1 n1 m2,
-  mem_inj f m1 m2 ->
-  storebytes m1 b1 ofs bytes1 = Some n1 ->
-  f b1 = None ->
-  mem_inj f n1 m2.
-Proof.
-  intros. inversion H.
-  constructor.
-(* access *)
-  intros. eapply mi_access0; eauto. eapply storebytes_valid_access_2; eauto. 
-(* mem_contents *)
-  intros. 
-  rewrite (storebytes_mem_contents _ _ _ _ _ H0).
-  rewrite update_o. eapply mi_memval0; eauto. eapply perm_storebytes_2; eauto.
-  congruence.
-Qed.
-
-Lemma storebytes_outside_inj:
-  forall f m1 m2 b ofs bytes2 m2',
-  mem_inj f m1 m2 ->
-  (forall b' delta ofs',
-    f b' = Some(b, delta) ->
-    perm m1 b' ofs' Nonempty ->
-    ofs' + delta < ofs \/ ofs' + delta >= ofs + Z_of_nat (length bytes2)) ->
-  storebytes m2 b ofs bytes2 = Some m2' ->
-  mem_inj f m1 m2'.
-Proof.
-  intros. inversion H. constructor.
-(* access *)
-  intros. eapply storebytes_valid_access_1; eauto with mem.
-(* mem_contents *)
-  intros. 
-  rewrite (storebytes_mem_contents _ _ _ _ _ H1).
-  unfold update. destruct (zeq b2 b). subst b2.
-  rewrite setN_outside. auto. 
-  eapply H0; eauto. 
-  eauto with mem.
-Qed.
-
 (** Preservation of allocations *)
 
 Lemma alloc_right_inj:
@@ -2614,9 +2996,9 @@
   intros. eauto with mem. 
 (* mem_contents *)
   intros.
-  assert (valid_access m2 Mint8unsigned b0 (ofs + delta) Nonempty).
+  assert (valid_access m2 (Mint 7) b0 (ofs + delta) Nonempty).
     eapply mi_access0; eauto.
-    split. simpl. red; intros. assert (ofs0 = ofs) by omega. congruence.
+    split. simpl. red; intros. rewrite bytesize_chunk_7_eq_1 in H3. assert (ofs0 = ofs) by omega. congruence.
     simpl. apply Zone_divide. 
   assert (valid_block m2 b0) by eauto with mem.
   rewrite <- MEM; simpl. rewrite update_o. eauto with mem.
@@ -2825,7 +3207,7 @@
   the [Vundef] values stored in [m1] by more defined values stored
   in [m2] at the same locations. *)
 
-Record extends' (m1 m2: mem) : Prop :=
+Record extends_ (m1 m2: mem) : Prop :=
   mk_extends {
     mext_next: nextblock m1 = nextblock m2;
     mext_inj:  mem_inj inject_id m1 m2
@@ -2834,7 +3216,7 @@
 *)
   }.
 
-Definition extends := extends'.
+Definition extends := extends_.
 
 Theorem extends_refl:
   forall m, extends m m.
@@ -2842,7 +3224,8 @@
   intros. constructor. auto. constructor.
   intros. unfold inject_id in H; inv H. replace (ofs + 0) with ofs by omega. auto.
   intros. unfold inject_id in H; inv H. replace (ofs + 0) with ofs by omega. 
-  apply memval_lessdef_refl.
+  apply memval_inject_id.
+(*  intros. omega. *)
 Qed.
 
 Theorem load_extends:
@@ -2869,17 +3252,6 @@
   congruence.
 Qed.
 
-Theorem loadbytes_extends:
-  forall m1 m2 b ofs len bytes1,
-  extends m1 m2 ->
-  loadbytes m1 b ofs len = Some bytes1 ->
-  exists bytes2, loadbytes m2 b ofs len = Some bytes2
-              /\ list_forall2 memval_lessdef bytes1 bytes2.
-Proof.
-  intros. inv H.
-  replace ofs with (ofs + 0) by omega. eapply loadbytes_inj; eauto. 
-Qed.
-
 Theorem store_within_extends:
   forall chunk m1 m2 b ofs v1 m1' v2,
   extends m1 m2 ->
@@ -2942,52 +3314,6 @@
   congruence.
 Qed.
 
-Theorem storebytes_within_extends:
-  forall m1 m2 b ofs bytes1 m1' bytes2,
-  extends m1 m2 ->
-  storebytes m1 b ofs bytes1 = Some m1' ->
-  list_forall2 memval_lessdef bytes1 bytes2 ->
-  exists m2',
-     storebytes m2 b ofs bytes2 = Some m2'
-  /\ extends m1' m2'.
-Proof.
-  intros. inversion H.
-  exploit storebytes_mapped_inj; eauto. 
-    unfold inject_id; red; intros. inv H3; inv H4. auto.
-    unfold inject_id; reflexivity.
-  intros [m2' [A B]].
-  exists m2'; split.
-  replace (ofs + 0) with ofs in A by omega. auto.
-  split; auto.
-  rewrite (nextblock_storebytes _ _ _ _ _ H0).
-  rewrite (nextblock_storebytes _ _ _ _ _ A).
-  auto.
-(*
-  intros.
-  rewrite (bounds_store _ _ _ _ _ _ H0).
-  rewrite (bounds_store _ _ _ _ _ _ A).
-  auto.
-*)
-Qed.
-
-Theorem storebytes_outside_extends:
-  forall m1 m2 b ofs bytes2 m2',
-  extends m1 m2 ->
-  storebytes m2 b ofs bytes2 = Some m2' ->
-  ofs + Z_of_nat (length bytes2) <= low_bound m1 b \/ high_bound m1 b <= ofs ->
-  extends m1 m2'.
-Proof.
-  intros. inversion H. constructor.
-  rewrite (nextblock_storebytes _ _ _ _ _ H0). auto.
-  eapply storebytes_outside_inj; eauto.
-  unfold inject_id; intros. inv H2.
-  exploit perm_in_bounds; eauto. omega.
-(* 
-  intros.
-  rewrite (bounds_store _ _ _ _ _ _ H0). auto.
-*)
-Qed.
-
 Theorem alloc_extends:
   forall m1 m2 lo1 hi1 b m1' lo2 hi2,
   extends m1 m2 ->
@@ -3129,7 +3455,7 @@
 - the offsets [delta] are representable with signed machine integers.
 *)
 
-Record inject' (f: meminj) (m1 m2: mem) : Prop :=
+Record inject_ (f: meminj) (m1 m2: mem) : Prop :=
   mk_inject {
     mi_inj:
       mem_inj f m1 m2;
@@ -3142,15 +3468,15 @@
     mi_range_offset:
       forall b b' delta,
       f b = Some(b', delta) ->
-      0 <= delta <= Int.max_unsigned;
+      Int.min_signed 31 <= delta <= Int.max_signed 31;
     mi_range_block:
       forall b b' delta,
       f b = Some(b', delta) ->
       delta = 0 \/ 
-      (0 <= low_bound m2 b' /\ high_bound m2 b' <= Int.max_unsigned)
+      (Int.min_signed 31 <= low_bound m2 b' /\ high_bound m2 b' <= Int.max_signed 31)
   }.
 
-Definition inject := inject'.
+Definition inject := inject_.
 
 Hint Local Resolve mi_mappedblocks mi_range_offset: mem.
 
@@ -3186,15 +3512,6 @@
   intros. inv H0. eapply perm_inj; eauto. 
 Qed.
 
-Theorem range_perm_inject:
-  forall f m1 m2 b1 b2 delta lo hi p,
-  f b1 = Some(b2, delta) ->
-  inject f m1 m2 ->
-  range_perm m1 b1 lo hi p -> range_perm m2 b2 (lo + delta) (hi + delta) p.
-Proof.
-  intros. inv H0. eapply range_perm_inj; eauto.
-Qed.
-
 Theorem valid_access_inject:
   forall f m1 m2 chunk b1 ofs b2 delta p,
   f b1 = Some(b2, delta) ->
@@ -3224,17 +3541,17 @@
 Lemma address_inject:
   forall f m1 m2 b1 ofs1 b2 delta,
   inject f m1 m2 ->
-  perm m1 b1 (Int.unsigned ofs1) Nonempty ->
+  perm m1 b1 (Int.signed 31 ofs1) Nonempty ->
   f b1 = Some (b2, delta) ->
-  Int.unsigned (Int.add ofs1 (Int.repr delta)) = Int.unsigned ofs1 + delta.
+  Int.signed 31 (Int.add 31 ofs1 (Int.repr 31 delta)) = Int.signed 31 ofs1 + delta.
 Proof.
   intros.
   exploit perm_inject; eauto. intro A.
   exploit perm_in_bounds. eexact A. intros [B C]. 
   exploit mi_range_block; eauto. intros [D | [E F]].
   subst delta. rewrite Int.add_zero. omega.
-  unfold Int.add.
-  repeat rewrite Int.unsigned_repr. auto.
+  rewrite Int.add_signed.
+  repeat rewrite Int.signed_repr. auto.
   eapply mi_range_offset; eauto.
   omega. 
   eapply mi_range_offset; eauto.
@@ -3243,9 +3560,9 @@
 Lemma address_inject':
   forall f m1 m2 chunk b1 ofs1 b2 delta,
   inject f m1 m2 ->
-  valid_access m1 chunk b1 (Int.unsigned ofs1) Nonempty ->
+  valid_access m1 chunk b1 (Int.signed 31 ofs1) Nonempty ->
   f b1 = Some (b2, delta) ->
-  Int.unsigned (Int.add ofs1 (Int.repr delta)) = Int.unsigned ofs1 + delta.
+  Int.signed 31 (Int.add 31 ofs1 (Int.repr 31 delta)) = Int.signed 31 ofs1 + delta.
 Proof.
   intros. destruct H0. eapply address_inject; eauto. 
   apply H0. generalize (size_chunk_pos chunk). omega. 
@@ -3254,28 +3571,28 @@
 Theorem valid_pointer_inject_no_overflow:
   forall f m1 m2 b ofs b' x,
   inject f m1 m2 ->
-  valid_pointer m1 b (Int.unsigned ofs) = true ->
+  valid_pointer m1 b (Int.signed 31 ofs) = true ->
   f b = Some(b', x) ->
-  0 <= Int.unsigned ofs + Int.unsigned (Int.repr x) <= Int.max_unsigned.
+  Int.min_signed 31 <= Int.signed 31 ofs + Int.signed 31 (Int.repr 31 x) <= Int.max_signed 31.
 Proof.
   intros. rewrite valid_pointer_valid_access in H0.
   exploit address_inject'; eauto. intros.
-  rewrite Int.unsigned_repr; eauto.
-  rewrite <- H2. apply Int.unsigned_range_2. 
+  rewrite Int.signed_repr; eauto.
+  rewrite <- H2. apply Int.signed_range. 
   eapply mi_range_offset; eauto.
 Qed.
 
 Theorem valid_pointer_inject_val:
   forall f m1 m2 b ofs b' ofs',
   inject f m1 m2 ->
-  valid_pointer m1 b (Int.unsigned ofs) = true ->
+  valid_pointer m1 b (Int.signed 31 ofs) = true ->
   val_inject f (Vptr b ofs) (Vptr b' ofs') ->
-  valid_pointer m2 b' (Int.unsigned ofs') = true.
+  valid_pointer m2 b' (Int.signed 31 ofs') = true.
 Proof.
   intros. inv H1.
   exploit valid_pointer_inject_no_overflow; eauto. intro NOOV.
-  unfold Int.add. rewrite Int.unsigned_repr; auto.
-  rewrite Int.unsigned_repr.
+  rewrite Int.add_signed. rewrite Int.signed_repr; auto.
+  rewrite Int.signed_repr.
   eapply valid_pointer_inject; eauto.
   eapply mi_range_offset; eauto.
 Qed.
@@ -3297,13 +3614,13 @@
   forall f m m' b1 ofs1 b2 ofs2 b1' delta1 b2' delta2,
   inject f m m' ->
   b1 <> b2 ->
-  valid_pointer m b1 (Int.unsigned ofs1) = true ->
-  valid_pointer m b2 (Int.unsigned ofs2) = true ->
+  valid_pointer m b1 (Int.signed 31 ofs1) = true ->
+  valid_pointer m b2 (Int.signed 31 ofs2) = true ->
   f b1 = Some (b1', delta1) ->
   f b2 = Some (b2', delta2) ->
   b1' <> b2' \/
-  Int.unsigned (Int.add ofs1 (Int.repr delta1)) <>
-  Int.unsigned (Int.add ofs2 (Int.repr delta2)).
+  Int.signed 31 (Int.add 31 ofs1 (Int.repr 31 delta1)) <>
+  Int.signed 31 (Int.add 31 ofs2 (Int.repr 31 delta2)).
 Proof.
   intros. 
   rewrite valid_pointer_valid_access in H1. 
@@ -3311,57 +3628,11 @@
   rewrite (address_inject' _ _ _ _ _ _ _ _ H H1 H3). 
   rewrite (address_inject' _ _ _ _ _ _ _ _ H H2 H4). 
   inv H1. simpl in H5. inv H2. simpl in H1.
+  rewrite bytesize_chunk_7_eq_1 in *.
   eapply meminj_no_overlap_perm. 
   eapply mi_no_overlap; eauto. eauto. eauto. eauto. 
-  apply (H5 (Int.unsigned ofs1)). omega.
-  apply (H1 (Int.unsigned ofs2)). omega.
-Qed.
-
-Theorem disjoint_or_equal_inject:
-  forall f m m' b1 b1' delta1 b2 b2' delta2 ofs1 ofs2 sz,
-  inject f m m' ->
-  f b1 = Some(b1', delta1) ->
-  f b2 = Some(b2', delta2) ->
-  range_perm m b1 ofs1 (ofs1 + sz) Nonempty ->
-  range_perm m b2 ofs2 (ofs2 + sz) Nonempty ->
-  sz > 0 ->
-  b1 <> b2 \/ ofs1 = ofs2 \/ ofs1 + sz <= ofs2 \/ ofs2 + sz <= ofs1 ->
-  b1' <> b2' \/ ofs1 + delta1 = ofs2 + delta2
-             \/ ofs1 + delta1 + sz <= ofs2 + delta2 
-             \/ ofs2 + delta2 + sz <= ofs1 + delta1.
-Proof.
-  intros. 
-  exploit range_perm_in_bounds. eexact H2. omega. intros [LO1 HI1].
-  exploit range_perm_in_bounds. eexact H3. omega. intros [LO2 HI2].
-  destruct (eq_block b1 b2).
-  assert (b1' = b2') by congruence. assert (delta1 = delta2) by congruence. subst.
-  destruct H5. congruence. right. destruct H5. left; congruence. right. omega.
-  exploit mi_no_overlap; eauto. intros [P | P]. auto. right. omega.
-Qed.
-
-Theorem aligned_area_inject:
-  forall f m m' b ofs al sz b' delta,
-  inject f m m' ->
-  al = 1 \/ al = 2 \/ al = 4 -> sz > 0 ->
-  (al | sz) ->
-  range_perm m b ofs (ofs + sz) Nonempty ->
-  (al | ofs) ->
-  f b = Some(b', delta) ->
-  (al | ofs + delta).
-Proof.
-  intros. 
-  assert (P: al > 0) by omega.
-  assert (Q: Zabs al <= Zabs sz). apply Zdivide_bounds; auto. omega.
-  rewrite Zabs_eq in Q; try omega. rewrite Zabs_eq in Q; try omega.
-  assert (R: exists chunk, al = align_chunk chunk /\ al = size_chunk chunk).
-    destruct H0. subst; exists Mint8unsigned; auto.
-    destruct H0. subst; exists Mint16unsigned; auto.
-    subst; exists Mint32; auto.
-  destruct R as [chunk [A B]].
-  assert (valid_access m chunk b ofs Nonempty).
-    split. red; intros; apply H3. omega. congruence.
-  exploit valid_access_inject; eauto. intros [C D]. 
-  congruence.
+  apply (H5 (Int.signed 31 ofs1)). omega.
+  apply (H1 (Int.signed 31 ofs2)). omega.
 Qed.
 
 (** Preservation of loads *)
@@ -3385,23 +3656,12 @@
 Proof.
   intros. inv H1; simpl in H0; try discriminate.
   exploit load_inject; eauto. intros [v2 [LOAD INJ]].
-  exists v2; split; auto. unfold loadv. 
-  replace (Int.unsigned (Int.add ofs1 (Int.repr delta)))
-     with (Int.unsigned ofs1 + delta).
+  exists v2; split; auto. simpl.
+  replace (Int.signed 31 (Int.add 31 ofs1 (Int.repr 31 delta)))
+     with (Int.signed 31 ofs1 + delta).
   auto. symmetry. eapply address_inject'; eauto with mem.
 Qed.
 
-Theorem loadbytes_inject:
-  forall f m1 m2 b1 ofs len b2 delta bytes1,
-  inject f m1 m2 ->
-  loadbytes m1 b1 ofs len = Some bytes1 ->
-  f b1 = Some (b2, delta) ->
-  exists bytes2, loadbytes m2 b2 (ofs + delta) len = Some bytes2
-              /\ list_forall2 (memval_inject f) bytes1 bytes2.
-Proof.
-  intros. inv H. eapply loadbytes_inj; eauto. 
-Qed.
-
 (** Preservation of stores *)
 
 Theorem store_mapped_inject:
@@ -3495,94 +3755,12 @@
     storev chunk m2 a2 v2 = Some n2 /\ inject f n1 n2.
 Proof.
   intros. inv H1; simpl in H0; try discriminate.
-  unfold storev.
-  replace (Int.unsigned (Int.add ofs1 (Int.repr delta)))
-    with (Int.unsigned ofs1 + delta).
+  simpl. replace (Int.signed 31 (Int.add 31 ofs1 (Int.repr 31 delta)))
+            with (Int.signed 31 ofs1 + delta).
   eapply store_mapped_inject; eauto.
   symmetry. eapply address_inject'; eauto with mem.
 Qed.
 
-Theorem storebytes_mapped_inject:
-  forall f m1 b1 ofs bytes1 n1 m2 b2 delta bytes2,
-  inject f m1 m2 ->
-  storebytes m1 b1 ofs bytes1 = Some n1 ->
-  f b1 = Some (b2, delta) ->
-  list_forall2 (memval_inject f) bytes1 bytes2 ->
-  exists n2,
-    storebytes m2 b2 (ofs + delta) bytes2 = Some n2
-    /\ inject f n1 n2.
-Proof.
-  intros. inversion H.
-  exploit storebytes_mapped_inj; eauto. intros [n2 [STORE MI]].
-  exists n2; split. eauto. constructor.
-(* inj *)
-  auto.
-(* freeblocks *)
-  intros. apply mi_freeblocks0. red; intros; elim H3; eapply storebytes_valid_block_1; eauto.
-(* mappedblocks *)
-  intros. eapply storebytes_valid_block_1; eauto. 
-(* no overlap *)
-  red; intros.
-  repeat rewrite (bounds_storebytes _ _ _ _ _ H0).
-  eauto. 
-(* range offset *)
-  eauto.
-(* range blocks *)
-  intros. rewrite (bounds_storebytes _ _ _ _ _ STORE). eauto.
-Qed.
-
-Theorem storebytes_unmapped_inject:
-  forall f m1 b1 ofs bytes1 n1 m2,
-  inject f m1 m2 ->
-  storebytes m1 b1 ofs bytes1 = Some n1 ->
-  f b1 = None ->
-  inject f n1 m2.
-Proof.
-  intros. inversion H.
-  constructor.
-(* inj *)
-  eapply storebytes_unmapped_inj; eauto.
-(* freeblocks *)
-  intros. apply mi_freeblocks0. red; intros; elim H2; eapply storebytes_valid_block_1; eauto.
-(* mappedblocks *)
-  eauto with mem.
-(* no overlap *)
-  red; intros. 
-  repeat rewrite (bounds_storebytes _ _ _ _ _ H0).
-  eauto. 
-(* range offset *)
-  eauto.
-(* range blocks *)
-  auto.
-Qed.
-
-Theorem storebytes_outside_inject:
-  forall f m1 m2 b ofs bytes2 m2',
-  inject f m1 m2 ->
-  (forall b' delta,
-    f b' = Some(b, delta) ->
-    high_bound m1 b' + delta <= ofs
-    \/ ofs + Z_of_nat (length bytes2) <= low_bound m1 b' + delta) ->
-  storebytes m2 b ofs bytes2 = Some m2' ->
-  inject f m1 m2'.
-Proof.
-  intros. inversion H. constructor.
-(* inj *)
-  eapply storebytes_outside_inj; eauto.
-  intros. exploit perm_in_bounds; eauto. intro. 
-  exploit H0; eauto. omega. 
-(* freeblocks *)
-  auto.
-(* mappedblocks *)
-  intros. eapply storebytes_valid_block_1; eauto. 
-(* no overlap *)
-  auto.
-(* range offset *)
-  auto.
-(* range blocks *)
-  intros. rewrite (bounds_storebytes _ _ _ _ _ H1). eauto.
-Qed.
-
 (* Preservation of allocations *)
 
 Theorem alloc_right_inject:
@@ -3659,8 +3837,8 @@
   inject f m1 m2 ->
   alloc m1 lo hi = (m1', b1) ->
   valid_block m2 b2 ->
-  0 <= delta <= Int.max_unsigned ->
-  delta = 0 \/ 0 <= low_bound m2 b2 /\ high_bound m2 b2 <= Int.max_unsigned ->
+  Int.min_signed 31 <= delta <= Int.max_signed 31 ->
+  delta = 0 \/ Int.min_signed 31 <= low_bound m2 b2 /\ high_bound m2 b2 <= Int.max_signed 31 ->
   (forall ofs p, lo <= ofs < hi -> perm m2 b2 (ofs + delta) p) ->
   inj_offset_aligned delta (hi-lo) ->
   (forall b ofs, 
@@ -3736,7 +3914,7 @@
   eapply alloc_right_inject; eauto.
   eauto.
   instantiate (1 := b2). eauto with mem.
-  instantiate (1 := 0). unfold Int.max_unsigned. generalize Int.modulus_pos; omega.
+  instantiate (1 := 0). generalize (Int.min_signed_neg 31) (Int.max_signed_pos 31); omega.
   auto.
   intros.
   apply perm_implies with Freeable; auto with mem.
@@ -3893,7 +4071,7 @@
 (* range *)
   unfold flat_inj; intros.
   destruct (zlt b (nextblock m)); inv H0.
-  unfold Int.max_unsigned. generalize Int.modulus_pos; omega.
+  generalize (Int.min_signed_neg 31) (Int.max_signed_pos 31); omega.
 (* range *)
   unfold flat_inj; intros.
   destruct (zlt b (nextblock m)); inv H0. auto.
@@ -3960,7 +4138,7 @@
 
 Notation mem := Mem.mem.
 
-Global Opaque Mem.alloc Mem.free Mem.store Mem.load Mem.storebytes Mem.loadbytes.
+Global Opaque Mem.alloc Mem.free Mem.store Mem.load.
 
 Hint Resolve
   Mem.valid_not_valid_diff
@@ -3972,7 +4150,6 @@
   Mem.valid_access_perm
   Mem.valid_access_load
   Mem.load_valid_access
-  Mem.loadbytes_range_perm
   Mem.valid_access_store
   Mem.perm_store_1
   Mem.perm_store_2
@@ -3982,14 +4159,6 @@
   Mem.store_valid_access_1
   Mem.store_valid_access_2
   Mem.store_valid_access_3
-  Mem.storebytes_range_perm
-  Mem.perm_storebytes_1
-  Mem.perm_storebytes_2
-  Mem.storebytes_valid_access_1
-  Mem.storebytes_valid_access_2
-  Mem.nextblock_storebytes
-  Mem.storebytes_valid_block_1
-  Mem.storebytes_valid_block_2
   Mem.nextblock_alloc
   Mem.alloc_result
   Mem.valid_block_alloc
@@ -4014,4 +4183,13 @@
   Mem.valid_access_free_2
   Mem.valid_access_free_inv_1
   Mem.valid_access_free_inv_2
+  Mem.int2ptr_store
+  Mem.ptr2int_store
+  Mem.int2ptr_alloc_1
+  Mem.int2ptr_alloc_2
+  Mem.int2ptr_alloc_3
+  Mem.ptr2int_alloc
+  Mem.int2ptr_free
+  Mem.ptr2int_free
 : mem.
+
diff -ruN lib/compcert-1.9/Memtype.v lib.patched/compcert-1.9/Memtype.v
--- lib/compcert-1.9/Memtype.v	2014-08-30 20:09:04.806089049 -0400
+++ lib.patched/compcert-1.9/Memtype.v	2014-08-30 00:29:06.159588829 -0400
@@ -23,6 +23,7 @@
 - [free]: invalidate a memory block.
 *)
 
+Require Import Znumtheory.
 Require Import Coqlib.
 Require Import AST.
 Require Import Integers.
@@ -110,13 +111,13 @@
 
 Definition loadv (chunk: memory_chunk) (m: mem) (addr: val) : option val :=
   match addr with
-  | Vptr b ofs => load chunk m b (Int.unsigned ofs)
+  | Vptr b ofs => load chunk m b (Int.signed 31 ofs)
   | _ => None
   end.
 
 Definition storev (chunk: memory_chunk) (m: mem) (addr v: val) : option mem :=
   match addr with
-  | Vptr b ofs => store chunk m b (Int.unsigned ofs) v
+  | Vptr b ofs => store chunk m b (Int.signed 31 ofs) v
   | _ => None
   end.
 
@@ -126,11 +127,6 @@
   [None] is returned if the accessed addresses are not readable. *)
 Parameter loadbytes: forall (m: mem) (b: block) (ofs n: Z), option (list memval).
 
-(** [storebytes m b ofs bytes] stores the given list of bytes [bytes]
-  starting at location [(b, ofs)].  Returns updated memory state
-  or [None] if the accessed locations are not writable. *)
-Parameter storebytes: forall (m: mem) (b: block) (ofs: Z) (bytes: list memval), option mem.
-
 (** [free_list] frees all the given (block, lo, hi) triples. *)
 Fixpoint free_list (m: mem) (l: list (block * Z * Z)) {struct l}: option mem :=
   match l with
@@ -230,7 +226,7 @@
   valid_pointer m b ofs = true <-> perm m b ofs Nonempty.
 Axiom valid_pointer_valid_access:
   forall m b ofs,
-  valid_pointer m b ofs = true <-> valid_access m Mint8unsigned b ofs Nonempty.
+  valid_pointer m b ofs = true <-> valid_access m (Mint 7) b ofs Nonempty.
 
 (** Each block has associated low and high bounds.  These are the bounds 
     that were given when the block was allocated.  *)
@@ -291,14 +287,11 @@
   forall m chunk b ofs v,
   load chunk m b ofs = Some v ->
   match chunk with
-  | Mint8signed => v = Val.sign_ext 8 v
-  | Mint8unsigned => v = Val.zero_ext 8 v
-  | Mint16signed => v = Val.sign_ext 16 v
-  | Mint16unsigned => v = Val.zero_ext 16 v
   | Mfloat32 => v = Val.singleoffloat v
   | _ => True
   end.
 
+(*
 Axiom load_int8_signed_unsigned:
   forall m b ofs,
   load Mint8signed m b ofs = option_map (Val.sign_ext 8) (load Mint8unsigned m b ofs).
@@ -306,22 +299,10 @@
 Axiom load_int16_signed_unsigned:
   forall m b ofs,
   load Mint16signed m b ofs = option_map (Val.sign_ext 16) (load Mint16unsigned m b ofs).
-
+*)
 
 (** ** Properties of [loadbytes]. *)
 
-(** [loadbytes] succeeds if and only if we have read permissions on the accessed
-    memory area. *)
-
-Axiom range_perm_loadbytes:
-  forall m b ofs len,
-  range_perm m b ofs (ofs + len) Readable ->
-  exists bytes, loadbytes m b ofs len = Some bytes.
-Axiom loadbytes_range_perm:
-  forall m b ofs len bytes,
-  loadbytes m b ofs len = Some bytes ->
-  range_perm m b ofs (ofs + len) Readable.
-
 (** If [loadbytes] succeeds, the corresponding [load] succeeds and
   returns a value that is determined by the
   bytes read by [loadbytes]. *)
@@ -346,10 +327,6 @@
   loadbytes m b ofs n = Some bytes ->
   length bytes = nat_of_Z n.
 
-Axiom loadbytes_empty:
-  forall m b ofs n,
-  n <= 0 -> loadbytes m b ofs n = Some nil.
-
 (** Composing or decomposing [loadbytes] operations at adjacent addresses. *)
 Axiom loadbytes_concat:
   forall m b ofs n1 n2 bytes1 bytes2,
@@ -467,6 +444,7 @@
 (** [store] is insensitive to the signedness or the high bits of
   small integer quantities. *)
 
+(*
 Axiom store_signed_unsigned_8:
   forall m b ofs v,
   store Mint8signed m b ofs v = store Mint8unsigned m b ofs v.
@@ -489,101 +467,12 @@
   forall m b ofs n,
   store Mint16signed m b ofs (Vint (Int.sign_ext 16 n)) =
   store Mint16signed m b ofs (Vint n).
+*)
 Axiom store_float32_truncate:
   forall m b ofs n,
   store Mfloat32 m b ofs (Vfloat (Float.singleoffloat n)) =
   store Mfloat32 m b ofs (Vfloat n).
 
-(** ** Properties of [storebytes]. *)
-
-(** [storebytes] preserves block validity, permissions, access validity, and bounds.
-  Moreover, a [storebytes] succeeds if and only if we have write permissions
-  on the addressed memory area. *)
-
-Axiom range_perm_storebytes:
-  forall m1 b ofs bytes,
-  range_perm m1 b ofs (ofs + Z_of_nat (length bytes)) Writable ->
-  { m2 : mem | storebytes m1 b ofs bytes = Some m2 }.
-Axiom storebytes_range_perm:
-  forall m1 b ofs bytes m2, storebytes m1 b ofs bytes = Some m2 ->
-  range_perm m1 b ofs (ofs + Z_of_nat (length bytes)) Writable.
-Axiom perm_storebytes_1:
-  forall m1 b ofs bytes m2, storebytes m1 b ofs bytes = Some m2 ->
-  forall b' ofs' p, perm m1 b' ofs' p -> perm m2 b' ofs' p.
-Axiom perm_storebytes_2:
-  forall m1 b ofs bytes m2, storebytes m1 b ofs bytes = Some m2 ->
-  forall b' ofs' p, perm m2 b' ofs' p -> perm m1 b' ofs' p.
-Axiom storebytes_valid_access_1:
-  forall m1 b ofs bytes m2, storebytes m1 b ofs bytes = Some m2 ->
-  forall chunk' b' ofs' p,
-  valid_access m1 chunk' b' ofs' p -> valid_access m2 chunk' b' ofs' p.
-Axiom storebytes_valid_access_2:
-  forall m1 b ofs bytes m2, storebytes m1 b ofs bytes = Some m2 ->
-  forall chunk' b' ofs' p,
-  valid_access m2 chunk' b' ofs' p -> valid_access m1 chunk' b' ofs' p.
-Axiom nextblock_storebytes:
-  forall m1 b ofs bytes m2, storebytes m1 b ofs bytes = Some m2 ->
-  nextblock m2 = nextblock m1.
-Axiom storebytes_valid_block_1:
-  forall m1 b ofs bytes m2, storebytes m1 b ofs bytes = Some m2 ->
-  forall b', valid_block m1 b' -> valid_block m2 b'.
-Axiom storebytes_valid_block_2:
-  forall m1 b ofs bytes m2, storebytes m1 b ofs bytes = Some m2 ->
-  forall b', valid_block m2 b' -> valid_block m1 b'.
-Axiom bounds_storebytes:
-  forall m1 b ofs bytes m2, storebytes m1 b ofs bytes = Some m2 ->
-  forall b', bounds m2 b' = bounds m1 b'.
-
-(** Connections between [store] and [storebytes]. *)
-
-Axiom storebytes_store:
-  forall m1 b ofs chunk v m2,
-  storebytes m1 b ofs (encode_val chunk v) = Some m2 ->
-  (align_chunk chunk | ofs) ->
-  store chunk m1 b ofs v = Some m2.
-
-Axiom store_storebytes:
-  forall m1 b ofs chunk v m2,
-  store chunk m1 b ofs v = Some m2 ->
-  storebytes m1 b ofs (encode_val chunk v) = Some m2.
-
-(** Load-store properties. *)
-
-Axiom loadbytes_storebytes_same:
-  forall m1 b ofs bytes m2, storebytes m1 b ofs bytes = Some m2 ->
-  loadbytes m2 b ofs (Z_of_nat (length bytes)) = Some bytes.
-Axiom loadbytes_storebytes_other:
-  forall m1 b ofs bytes m2, storebytes m1 b ofs bytes = Some m2 ->
-  forall b' ofs' len,
-  len >= 0 ->
-  b' <> b
-  \/ ofs' + len <= ofs
-  \/ ofs + Z_of_nat (length bytes) <= ofs' ->
-  loadbytes m2 b' ofs' len = loadbytes m1 b' ofs' len.
-Axiom load_storebytes_other:
-  forall m1 b ofs bytes m2, storebytes m1 b ofs bytes = Some m2 ->
-  forall chunk b' ofs',
-  b' <> b
-  \/ ofs' + size_chunk chunk <= ofs
-  \/ ofs + Z_of_nat (length bytes) <= ofs' ->
-  load chunk m2 b' ofs' = load chunk m1 b' ofs'.
-
-(** Composing or decomposing [storebytes] operations at adjacent addresses. *)
-
-Axiom storebytes_concat:
-  forall m b ofs bytes1 m1 bytes2 m2,
-  storebytes m b ofs bytes1 = Some m1 ->
-  storebytes m1 b (ofs + Z_of_nat(length bytes1)) bytes2 = Some m2 ->
-  storebytes m b ofs (bytes1 ++ bytes2) = Some m2.
-Axiom storebytes_split:
-  forall m b ofs bytes1 bytes2 m2,
-  storebytes m b ofs (bytes1 ++ bytes2) = Some m2 ->
-  exists m1,
-     storebytes m b ofs bytes1 = Some m1
-  /\ storebytes m1 b (ofs + Z_of_nat(length bytes1)) bytes2 = Some m2.
-Axiom storebytes_empty:
-  forall m b ofs, storebytes m b ofs nil = Some m.
-
 (** ** Properties of [alloc]. *)
 
 (** The identifier of the freshly allocated block is the next block
@@ -765,6 +654,12 @@
   b <> bf \/ lo >= hi \/ ofs + size_chunk chunk <= lo \/ hi <= ofs ->
   load chunk m2 b ofs = load chunk m1 b ofs.
 
+Axiom load_free': 
+  forall m1 bf lo hi m2, free m1 bf lo hi = Some m2 ->
+  forall (b : block) (a : memory_chunk) (ofs : Z) (v : val)
+  (HeqR : Some v = load a m2 b ofs),
+  b <> bf \/ lo >= hi \/ ofs + size_chunk a <= lo \/ hi <= ofs.
+
 (** ** Properties of [drop_perm]. *)
 
 Axiom nextblock_drop:
@@ -828,13 +723,6 @@
   Val.lessdef addr1 addr2 ->
   exists v2, loadv chunk m2 addr2 = Some v2 /\ Val.lessdef v1 v2.
 
-Axiom loadbytes_extends:
-  forall m1 m2 b ofs len bytes1,
-  extends m1 m2 ->
-  loadbytes m1 b ofs len = Some bytes1 ->
-  exists bytes2, loadbytes m2 b ofs len = Some bytes2
-              /\ list_forall2 memval_lessdef bytes1 bytes2.
-
 Axiom store_within_extends:
   forall chunk m1 m2 b ofs v1 m1' v2,
   extends m1 m2 ->
@@ -861,22 +749,6 @@
      storev chunk m2 addr2 v2 = Some m2'
   /\ extends m1' m2'.
 
-Axiom storebytes_within_extends:
-  forall m1 m2 b ofs bytes1 m1' bytes2,
-  extends m1 m2 ->
-  storebytes m1 b ofs bytes1 = Some m1' ->
-  list_forall2 memval_lessdef bytes1 bytes2 ->
-  exists m2',
-     storebytes m2 b ofs bytes2 = Some m2'
-  /\ extends m1' m2'.
-
-Axiom storebytes_outside_extends:
-  forall m1 m2 b ofs bytes2 m2',
-  extends m1 m2 ->
-  storebytes m2 b ofs bytes2 = Some m2' ->
-  ofs + Z_of_nat (length bytes2) <= low_bound m1 b \/ high_bound m1 b <= ofs ->
-  extends m1 m2'.
-
 Axiom alloc_extends:
   forall m1 m2 lo1 hi1 b m1' lo2 hi2,
   extends m1 m2 ->
@@ -971,23 +843,23 @@
 Axiom address_inject:
   forall f m1 m2 b1 ofs1 b2 delta,
   inject f m1 m2 ->
-  perm m1 b1 (Int.unsigned ofs1) Nonempty ->
+  perm m1 b1 (Int.signed 31 ofs1) Nonempty ->
   f b1 = Some (b2, delta) ->
-  Int.unsigned (Int.add ofs1 (Int.repr delta)) = Int.unsigned ofs1 + delta.
+  Int.signed 31 (Int.add 31 ofs1 (Int.repr 31 delta)) = Int.signed 31 ofs1 + delta.
 
 Axiom valid_pointer_inject_no_overflow:
   forall f m1 m2 b ofs b' x,
   inject f m1 m2 ->
-  valid_pointer m1 b (Int.unsigned ofs) = true ->
+  valid_pointer m1 b (Int.signed 31 ofs) = true ->
   f b = Some(b', x) ->
-  0 <= Int.unsigned ofs + Int.unsigned (Int.repr x) <= Int.max_unsigned.
+  Int.min_signed 31 <= Int.signed 31 ofs + Int.signed 31 (Int.repr 31 x) <= Int.max_signed 31.
 
 Axiom valid_pointer_inject_val:
   forall f m1 m2 b ofs b' ofs',
   inject f m1 m2 ->
-  valid_pointer m1 b (Int.unsigned ofs) = true ->
+  valid_pointer m1 b (Int.signed 31 ofs) = true ->
   val_inject f (Vptr b ofs) (Vptr b' ofs') ->
-  valid_pointer m2 b' (Int.unsigned ofs') = true.
+  valid_pointer m2 b' (Int.signed 31 ofs') = true.
 
 Axiom inject_no_overlap:
   forall f m1 m2 b1 b2 b1' b2' delta1 delta2 ofs1 ofs2,
@@ -1003,13 +875,13 @@
   forall f m m' b1 ofs1 b2 ofs2 b1' delta1 b2' delta2,
   inject f m m' ->
   b1 <> b2 ->
-  valid_pointer m b1 (Int.unsigned ofs1) = true ->
-  valid_pointer m b2 (Int.unsigned ofs2) = true ->
+  valid_pointer m b1 (Int.signed 31 ofs1) = true ->
+  valid_pointer m b2 (Int.signed 31 ofs2) = true ->
   f b1 = Some (b1', delta1) ->
   f b2 = Some (b2', delta2) ->
   b1' <> b2' \/
-  Int.unsigned (Int.add ofs1 (Int.repr delta1)) <>
-  Int.unsigned (Int.add ofs2 (Int.repr delta2)).
+  Int.signed 31 (Int.add 31 ofs1 (Int.repr 31 delta1)) <>
+  Int.signed 31 (Int.add 31 ofs2 (Int.repr 31 delta2)).
 
 Axiom load_inject:
   forall f m1 m2 chunk b1 ofs b2 delta v1,
@@ -1025,14 +897,6 @@
   val_inject f a1 a2 ->
   exists v2, loadv chunk m2 a2 = Some v2 /\ val_inject f v1 v2.
 
-Axiom loadbytes_inject:
-  forall f m1 m2 b1 ofs len b2 delta bytes1,
-  inject f m1 m2 ->
-  loadbytes m1 b1 ofs len = Some bytes1 ->
-  f b1 = Some (b2, delta) ->
-  exists bytes2, loadbytes m2 b2 (ofs + delta) len = Some bytes2
-              /\ list_forall2 (memval_inject f) bytes1 bytes2.
-
 Axiom store_mapped_inject:
   forall f chunk m1 b1 ofs v1 n1 m2 b2 delta v2,
   inject f m1 m2 ->
@@ -1069,33 +933,6 @@
   exists n2,
     storev chunk m2 a2 v2 = Some n2 /\ inject f n1 n2.
 
-Axiom storebytes_mapped_inject:
-  forall f m1 b1 ofs bytes1 n1 m2 b2 delta bytes2,
-  inject f m1 m2 ->
-  storebytes m1 b1 ofs bytes1 = Some n1 ->
-  f b1 = Some (b2, delta) ->
-  list_forall2 (memval_inject f) bytes1 bytes2 ->
-  exists n2,
-    storebytes m2 b2 (ofs + delta) bytes2 = Some n2
-    /\ inject f n1 n2.
-
-Axiom storebytes_unmapped_inject:
-  forall f m1 b1 ofs bytes1 n1 m2,
-  inject f m1 m2 ->
-  storebytes m1 b1 ofs bytes1 = Some n1 ->
-  f b1 = None ->
-  inject f n1 m2.
-
-Axiom storebytes_outside_inject:
-  forall f m1 m2 b ofs bytes2 m2',
-  inject f m1 m2 ->
-  (forall b' delta,
-    f b' = Some(b, delta) ->
-    high_bound m1 b' + delta <= ofs
-    \/ ofs + Z_of_nat (length bytes2) <= low_bound m1 b' + delta) ->
-  storebytes m2 b ofs bytes2 = Some m2' ->
-  inject f m1 m2'.
-
 Axiom alloc_right_inject:
   forall f m1 m2 lo hi b2 m2',
   inject f m1 m2 ->
@@ -1120,8 +957,8 @@
   inject f m1 m2 ->
   alloc m1 lo hi = (m1', b1) ->
   valid_block m2 b2 ->
-  0 <= delta <= Int.max_unsigned ->
-  delta = 0 \/ 0 <= low_bound m2 b2 /\ high_bound m2 b2 <= Int.max_unsigned ->
+  Int.min_signed 31 <= delta <= Int.max_signed 31 ->
+  delta = 0 \/ Int.min_signed 31 <= low_bound m2 b2 /\ high_bound m2 b2 <= Int.max_signed 31 ->
   (forall ofs p, lo <= ofs < hi -> perm m2 b2 (ofs + delta) p) ->
   inj_offset_aligned delta (hi-lo) ->
   (forall b ofs, 
diff -ruN lib/compcert-1.9/Ordered.v lib.patched/compcert-1.9/Ordered.v
--- lib/compcert-1.9/Ordered.v	2014-08-30 20:09:04.806089049 -0400
+++ lib.patched/compcert-1.9/Ordered.v	2014-08-30 00:29:06.159588829 -0400
@@ -54,9 +54,11 @@
 
 Module OrderedInt <: OrderedType.
 
-Definition t := int.
+Variable wordsize_one: nat.
+Definition t := Int.int wordsize_one.
 Definition eq (x y: t) := x = y.
-Definition lt (x y: t) := Int.unsigned x < Int.unsigned y.
+Definition lt (x y: t) := 
+  Int.unsigned wordsize_one x < Int.unsigned wordsize_one y.
 
 Lemma eq_refl : forall x : t, eq x x.
 Proof (@refl_equal t). 
@@ -74,17 +76,20 @@
 Qed.
 Lemma compare : forall x y : t, Compare lt eq x y.
 Proof.
-  intros. destruct (zlt (Int.unsigned x) (Int.unsigned y)).
+  intros. 
+  destruct (zlt (Int.unsigned wordsize_one x) (Int.unsigned wordsize_one y)).
   apply LT. auto.
-  destruct (Int.eq_dec x y).
+  destruct (Int.eq_dec wordsize_one x y).
   apply EQ. auto.
   apply GT.
-  assert (Int.unsigned x <> Int.unsigned y).
-    red; intros. rewrite <- (Int.repr_unsigned x) in n. rewrite <- (Int.repr_unsigned y) in n. congruence.
+  assert (Int.unsigned wordsize_one x <> Int.unsigned wordsize_one y).
+    red; intros. rewrite <- (Int.repr_unsigned wordsize_one x) in n. 
+      rewrite <- (Int.repr_unsigned wordsize_one y) in n. congruence.
   red. omega.
 Qed.
 
-Definition eq_dec : forall x y, { eq x y } + { ~ eq x y } := Int.eq_dec.
+Definition eq_dec : forall x y, { eq x y } + { ~ eq x y } := 
+  Int.eq_dec wordsize_one.
 
 End OrderedInt.
 
diff -ruN lib/compcert-1.9/Values.v lib.patched/compcert-1.9/Values.v
--- lib/compcert-1.9/Values.v	2014-08-30 20:09:04.806089049 -0400
+++ lib.patched/compcert-1.9/Values.v	2014-08-30 00:29:06.159588829 -0400
@@ -20,6 +20,8 @@
 Require Import AST.
 Require Import Integers.
 Require Import Floats.
+Require Import Equations.
+Require Import Axioms.
 
 Definition block : Type := Z.
 Definition eq_block := zeq.
@@ -35,16 +37,25 @@
 
 Inductive val: Type :=
   | Vundef: val
-  | Vint: int -> val
+  | Vint: forall (wz:nat), Int.int wz -> val
   | Vfloat: float -> val
-  | Vptr: block -> int -> val.
+  | Vptr: block -> int32 -> val
+  | Vinttoptr: int32 -> val.
 
-Definition Vzero: val := Vint Int.zero.
-Definition Vone: val := Vint Int.one.
-Definition Vmone: val := Vint Int.mone.
-
-Definition Vtrue: val := Vint Int.one.
-Definition Vfalse: val := Vint Int.zero.
+Definition zero (wz:nat) := (Int.zero wz).
+Definition one (wz:nat) := (Int.one wz).
+Definition mone (wz:nat) := (Int.mone wz).
+
+Definition Vzero (wz:nat): val := Vint wz (zero wz).
+Definition Vone (wz:nat): val := Vint wz (one wz).
+Definition Vmone (wz:nat): val := Vint wz (mone wz).
+
+Definition Vtrue := Vone 0.
+Definition Vfalse := Vzero 0.
+
+Definition eq_Vbool (wz:nat) (v v':val) := 
+  (v = Vone wz <-> v'= Vtrue) /\
+  (v = Vzero wz <-> v'= Vfalse).
 
 (** * Operations over values *)
 
@@ -54,14 +65,49 @@
 
 Module Val.
 
-Definition of_bool (b: bool): val := if b then Vtrue else Vfalse.
+(* FIXME: Comparision between float and int may not be correct. 
+   But we only need the eq to define LLVMgv.eq, which is only used for 
+   pointer comparision. *)
+Definition eq (v1 v2:val) : bool :=
+match v1, v2 with
+| Vundef, _ => false
+| _, Vundef => false
+| Vint wz1 i1, Vint wz2 i2 => zeq (Int.unsigned wz1 i1) (Int.unsigned wz2 i2)
+| Vint wz1 i1, Vfloat f2 => 
+    zeq (Int.unsigned wz1 i1) (Int.unsigned 31 (Float.intuoffloat f2))
+| Vfloat f1, Vint wz2 i2 => 
+    zeq (Int.unsigned 31 (Float.intuoffloat f1)) (Int.unsigned wz2 i2)
+| Vfloat f1, Vfloat f2 => match (Float.eq_dec f1 f2) with
+                          | left _ => true
+                          | right _ => false
+                          end
+| Vptr b1 o1, Vptr b2 o2 => eq_block b1 b2 && 
+                            zeq (Int.unsigned 31 o1) (Int.unsigned 31 o2)
+| Vinttoptr i1, Vinttoptr i2 => 
+    (* FIXME: Should we compare Vinttoptr and Vptr? *)
+    zeq (Int.unsigned 31 i1) (Int.unsigned 31 i2)
+| _, _ => false
+end.
+
+Definition get_wordsize (v : val) : option nat :=
+  match v with
+  | Vint wz _ => Some wz
+  | Vptr _ _ | Vinttoptr _ => 
+      (* This is incorrect, size of ptr is configured differently. *)
+      Some 31%nat
+  | _ => None
+  end.
+
+Definition of_bool (b: bool) : val := 
+if b then Vtrue else Vfalse.
 
 Definition has_type (v: val) (t: typ) : Prop :=
   match v, t with
   | Vundef, _ => True
-  | Vint _, Tint => True
+  | Vint _ _, Tint => True
   | Vfloat _, Tfloat => True
   | Vptr _ _, Tint => True
+  | Vinttoptr _, Tint => True
   | _, _ => False
   end.
 
@@ -78,28 +124,30 @@
 
 Definition is_true (v: val) : Prop :=
   match v with
-  | Vint n => n <> Int.zero
-  | Vptr b ofs => True
+  | Vint wz n => n <> zero wz
+  | Vptr _ _ | Vinttoptr _ => True
   | _ => False
   end.
 
 Definition is_false (v: val) : Prop :=
   match v with
-  | Vint n => n = Int.zero
+  | Vint wz n => n = zero wz
   | _ => False
   end.
 
 Inductive bool_of_val: val -> bool -> Prop :=
   | bool_of_val_int_true:
-      forall n, n <> Int.zero -> bool_of_val (Vint n) true
+      forall wz n, n <> zero wz -> bool_of_val (Vint wz n) true
   | bool_of_val_int_false:
-      bool_of_val (Vint Int.zero) false
+      forall wz, bool_of_val (Vzero wz) false
   | bool_of_val_ptr:
-      forall b ofs, bool_of_val (Vptr b ofs) true.
+      forall b ofs, bool_of_val (Vptr b ofs) true
+  | bool_of_val_inttoptr:
+      forall n, bool_of_val (Vinttoptr n) true.
 
 Definition neg (v: val) : val :=
   match v with
-  | Vint n => Vint (Int.neg n)
+  | Vint wz n => Vint wz (Int.neg wz n)
   | _ => Vundef
   end.
 
@@ -115,201 +163,344 @@
   | _ => Vundef
   end.
 
+Definition trunc (v: val) (wz':nat) : val :=
+match v with
+| Vint wz n => if le_lt_dec wz wz'
+               then Vundef
+               else Vint wz' (Int.repr wz' (Int.unsigned wz n))
+| _ => Vundef
+end.
+
+Definition ftrunc (v: val) : val :=
+match v with
+| Vfloat f => v
+| _ => Vundef
+end.
+
 Definition intoffloat (v: val) : val :=
   match v with
-  | Vfloat f => match Float.intoffloat f with Some n => Vint n | None => Vundef end
+  | Vfloat f => Vint 31 (Float.intoffloat f)
   | _ => Vundef
   end.
 
 Definition intuoffloat (v: val) : val :=
   match v with
-  | Vfloat f => match Float.intuoffloat f with Some n => Vint n | None => Vundef end
+  | Vfloat f => Vint 31 (Float.intuoffloat f)
   | _ => Vundef
   end.
 
 Definition floatofint (v: val) : val :=
   match v with
-  | Vint n => Vfloat (Float.floatofint n)
+  | Vint 31 n => Vfloat (Float.floatofint n)
   | _ => Vundef
   end.
 
 Definition floatofintu (v: val) : val :=
   match v with
-  | Vint n => Vfloat (Float.floatofintu n)
+  | Vint 31 n => Vfloat (Float.floatofintu n)
   | _ => Vundef
   end.
 
 Definition floatofwords (v1 v2: val) : val :=
   match v1, v2 with
-  | Vint n1, Vint n2 => Vfloat (Float.from_words n1 n2)
+  | Vint 31 n1, Vint 31 n2 => Vfloat (Float.from_words n1 n2)
   | _, _ => Vundef
   end.
 
 Definition notint (v: val) : val :=
   match v with
-  | Vint n => Vint (Int.xor n Int.mone)
+  | Vint wz n => Vint wz (Int.xor wz n (Int.mone wz))
   | _ => Vundef
   end.
 
 Definition notbool (v: val) : val :=
   match v with
-  | Vint n => of_bool (Int.eq n Int.zero)
-  | Vptr b ofs => Vfalse
+  | Vint wz n => of_bool (Int.eq wz n (zero wz))
+  | Vptr _ _ | Vinttoptr _ => Vfalse
   | _ => Vundef
   end.
 
+(* If v is a wz-bit of int, zero_ext v zeros the nbits-to-(wz-1) bits *)
 Definition zero_ext (nbits: Z) (v: val) : val :=
   match v with
-  | Vint n => Vint(Int.zero_ext nbits n)
+  | Vint wz n => Vint wz (Int.zero_ext wz nbits n)
   | _ => Vundef
   end.
 
-Definition sign_ext (nbits: Z) (v: val) : val :=
+(* If v is wz m-bit of int, 
+   zero_ext' v first converts v to v' that is of nbits bits,
+   then zeros the wz-to-(nbits-1) bits *)
+Definition zero_ext' (nbits: nat) (v: val) : val :=
   match v with
-  | Vint n => Vint(Int.sign_ext nbits n)
+  | Vint wz n => 
+      Vint nbits
+        (Int.zero_ext nbits (Z_of_nat wz)
+          (Int.repr nbits (Int.unsigned wz n)))
   | _ => Vundef
   end.
 
-Definition singleoffloat (v: val) : val :=
+(* If v is a wz-bit of int, sign_ext v signs the nbits-to-(wz-1) bits *)
+Definition sign_ext (nbits: Z) (v: val) : val :=
   match v with
-  | Vfloat f => Vfloat(Float.singleoffloat f)
+  | Vint wz n => Vint wz (Int.sign_ext wz nbits n)
   | _ => Vundef
   end.
 
-Definition add (v1 v2: val): val :=
-  match v1, v2 with
-  | Vint n1, Vint n2 => Vint(Int.add n1 n2)
-  | Vptr b1 ofs1, Vint n2 => Vptr b1 (Int.add ofs1 n2)
-  | Vint n1, Vptr b2 ofs2 => Vptr b2 (Int.add ofs2 n1)
-  | _, _ => Vundef
-  end.
-
-Definition sub (v1 v2: val): val :=
-  match v1, v2 with
-  | Vint n1, Vint n2 => Vint(Int.sub n1 n2)
-  | Vptr b1 ofs1, Vint n2 => Vptr b1 (Int.sub ofs1 n2)
-  | Vptr b1 ofs1, Vptr b2 ofs2 =>
-      if zeq b1 b2 then Vint(Int.sub ofs1 ofs2) else Vundef
-  | _, _ => Vundef
-  end.
-
-Definition mul (v1 v2: val): val :=
-  match v1, v2 with
-  | Vint n1, Vint n2 => Vint(Int.mul n1 n2)
-  | _, _ => Vundef
-  end.
-
-Definition divs (v1 v2: val): val :=
-  match v1, v2 with
-  | Vint n1, Vint n2 =>
-      if Int.eq n2 Int.zero then Vundef else Vint(Int.divs n1 n2)
-  | _, _ => Vundef
-  end.
-
-Definition mods (v1 v2: val): val :=
-  match v1, v2 with
-  | Vint n1, Vint n2 =>
-      if Int.eq n2 Int.zero then Vundef else Vint(Int.mods n1 n2)
-  | _, _ => Vundef
-  end.
-
-Definition divu (v1 v2: val): val :=
-  match v1, v2 with
-  | Vint n1, Vint n2 =>
-      if Int.eq n2 Int.zero then Vundef else Vint(Int.divu n1 n2)
-  | _, _ => Vundef
-  end.
-
-Definition modu (v1 v2: val): val :=
-  match v1, v2 with
-  | Vint n1, Vint n2 =>
-      if Int.eq n2 Int.zero then Vundef else Vint(Int.modu n1 n2)
-  | _, _ => Vundef
-  end.
-
-Definition add_carry (v1 v2 cin: val): val :=
-  match v1, v2, cin with
-  | Vint n1, Vint n2, Vint c => Vint(Int.add_carry n1 n2 c)
-  | _, _, _ => Vundef
-  end.
-
-Definition and (v1 v2: val): val :=
-  match v1, v2 with
-  | Vint n1, Vint n2 => Vint(Int.and n1 n2)
-  | _, _ => Vundef
-  end.
-
-Definition or (v1 v2: val): val :=
-  match v1, v2 with
-  | Vint n1, Vint n2 => Vint(Int.or n1 n2)
-  | _, _ => Vundef
-  end.
-
-Definition xor (v1 v2: val): val :=
-  match v1, v2 with
-  | Vint n1, Vint n2 => Vint(Int.xor n1 n2)
-  | _, _ => Vundef
-  end.
-
-Definition shl (v1 v2: val): val :=
-  match v1, v2 with
-  | Vint n1, Vint n2 =>
-     if Int.ltu n2 Int.iwordsize
-     then Vint(Int.shl n1 n2)
-     else Vundef
-  | _, _ => Vundef
-  end.
-
-Definition shr (v1 v2: val): val :=
-  match v1, v2 with
-  | Vint n1, Vint n2 =>
-     if Int.ltu n2 Int.iwordsize
-     then Vint(Int.shr n1 n2)
-     else Vundef
-  | _, _ => Vundef
-  end.
-
-Definition shr_carry (v1 v2: val): val :=
-  match v1, v2 with
-  | Vint n1, Vint n2 =>
-     if Int.ltu n2 Int.iwordsize
-     then Vint(Int.shr_carry n1 n2)
-     else Vundef
-  | _, _ => Vundef
+(* If v is wz m-bit of int, 
+   sign_ext' v first converts v to v' that is of nbits bits,
+   then signs the wz-to-(nbits-1) bits *)
+Definition sign_ext' (nbits: nat) (v: val) : val :=
+  match v with
+  | Vint wz n => 
+      Vint nbits
+        (Int.sign_ext nbits (Z_of_nat wz)
+          (Int.repr nbits (Int.unsigned wz n)))
+  | _ => Vundef
   end.
 
-Definition shrx (v1 v2: val): val :=
-  match v1, v2 with
-  | Vint n1, Vint n2 =>
-     if Int.ltu n2 Int.iwordsize
-     then Vint(Int.shrx n1 n2)
-     else Vundef
-  | _, _ => Vundef
+Definition singleoffloat (v: val) : val :=
+  match v with
+  | Vfloat f => Vfloat(Float.singleoffloat f)
+  | _ => Vundef
   end.
 
-Definition shru (v1 v2: val): val :=
-  match v1, v2 with
-  | Vint n1, Vint n2 =>
-     if Int.ltu n2 Int.iwordsize
-     then Vint(Int.shru n1 n2)
-     else Vundef
-  | _, _ => Vundef
-  end.
+Equations add (v1 v2: val): val :=
+add (Vint wz1 n1) (Vint wz2 n2) with (eq_nat_dec wz1 wz2) := {
+  add (Vint wz1 n1) (Vint ?(wz1) n2) (left eq_refl) :=
+     Vint wz1 (Int.add wz1 n1 n2);
+  add (Vint wz1 n1) (Vint wz2 n2) (right p) := Vundef  
+  };
+add (Vptr b1 ofs1) (Vint wz2 n2) with (eq_nat_dec wz2 31) := {
+  add (Vptr b1 ofs1) (Vint ?(wz2) n2) (left eq_refl) :=
+     Vptr b1 (Int.add 31 ofs1 n2);
+  add (Vptr b1 ofs1) (Vint ?(wz2) n2) (right p) := Vundef
+  };
+add (Vint wz1 n1) (Vptr b2 ofs2) with (eq_nat_dec wz1 31) := {
+  add (Vint ?(wz1) n1) (Vptr b2 ofs2) (left eq_refl) :=
+     Vptr b2 (Int.add 31 ofs2 n1);
+  add (Vint wz1 n1) (Vptr b2 ofs2) (right p) := Vundef
+  };
+add (Vinttoptr n1) (Vint wz2 n2) with (eq_nat_dec wz2 31) := {
+  add (Vinttoptr n1) (Vint ?(wz1) n2) (left eq_refl) :=
+     Vinttoptr (Int.add 31 n1 n2);
+  add (Vinttoptr n1) (Vint wz2 n2) (right p) := Vundef  
+  };
+add (Vint wz1 n1) (Vinttoptr n2) with (eq_nat_dec wz1 31) := {
+  add (Vint wz1 n1) (Vinttoptr n2) (left eq_refl) :=
+     Vinttoptr (Int.add wz1 n1 n2);
+  add (Vint wz1 n1) (Vinttoptr n2) (right p) := Vundef  
+  };
+add _ _ := Vundef.
+
+Equations sub (v1 v2: val): val :=
+sub (Vint wz1 n1) (Vint wz2 n2) with (eq_nat_dec wz1 wz2) := {
+  sub (Vint wz1 n1) (Vint ?(wz1) n2) (left eq_refl) :=
+     Vint wz1 (Int.sub wz1 n1 n2);
+  sub (Vint wz1 n1) (Vint wz2 n2) (right p) := Vundef  
+  };
+sub (Vptr b1 ofs1) (Vint wz2 n2) with (eq_nat_dec wz2 31) := {
+  sub (Vptr b1 ofs1) (Vint ?(wz2) n2) (left eq_refl) :=
+     Vptr b1 (Int.sub 31 ofs1 n2);
+  sub (Vptr b1 ofs1) (Vint ?(wz2) n2) (right p) := Vundef
+  };
+sub (Vptr b1 ofs1) (Vptr b2 ofs2) := 
+  if zeq b1 b2 then Vint 31 (Int.sub 31 ofs1 ofs2) else Vundef;
+sub (Vinttoptr n1) (Vint wz2 n2) with (eq_nat_dec wz2 31) := {
+  sub (Vinttoptr n1) (Vint ?(wz2) n2) (left eq_refl) :=
+     Vinttoptr (Int.sub 31 n1 n2);
+  sub (Vinttoptr n1) (Vint ?(wz2) n2) (right p) := Vundef
+  };
+sub (Vinttoptr n1) (Vinttoptr n2) := Vint 31 (Int.sub 31 n1 n2);
+sub _ _ := Vundef.
+
+Equations mul (v1 v2: val): val :=
+mul (Vint wz1 n1) (Vint wz2 n2) with (eq_nat_dec wz1 wz2) := {
+  mul (Vint wz1 n1) (Vint ?(wz1) n2) (left eq_refl) :=
+     Vint wz1 (Int.mul wz1 n1 n2);
+  mul (Vint wz1 n1) (Vint wz2 n2) (right p) := Vundef  
+  };
+mul _ _ := Vundef.
+
+Equations divs (v1 v2: val): val :=
+divs (Vint wz1 n1) (Vint wz2 n2) with (eq_nat_dec wz1 wz2) := {
+  divs (Vint wz1 n1) (Vint ?(wz1) n2) (left eq_refl) :=
+    if Int.eq wz1 n2 (Int.zero wz1) 
+    then Vundef 
+    else Vint wz1 (Int.divs wz1 n1 n2);
+  divs (Vint wz1 n1) (Vint wz2 n2) (right p) := Vundef  
+  };
+divs _ _ := Vundef.
+
+Equations mods (v1 v2: val): val :=
+mods (Vint wz1 n1) (Vint wz2 n2) with (eq_nat_dec wz1 wz2) := {
+  mods (Vint wz1 n1) (Vint ?(wz1) n2) (left eq_refl) :=
+    if Int.eq wz1 n2 (Int.zero wz1) 
+    then Vundef 
+    else Vint wz1 (Int.mods wz1 n1 n2);
+  mods (Vint wz1 n1) (Vint wz2 n2) (right p) := Vundef  
+  };
+mods _ _ := Vundef.
+
+Equations divu (v1 v2: val): val :=
+divu (Vint wz1 n1) (Vint wz2 n2) with (eq_nat_dec wz1 wz2) := {
+  divu (Vint wz1 n1) (Vint ?(wz1) n2) (left eq_refl) :=
+    if Int.eq wz1 n2 (Int.zero wz1) 
+    then Vundef 
+    else Vint wz1 (Int.divu wz1 n1 n2);
+  divu (Vint wz1 n1) (Vint wz2 n2) (right p) := Vundef  
+  };
+divu _ _ := Vundef.
+
+Equations modu (v1 v2: val): val :=
+modu (Vint wz1 n1) (Vint wz2 n2) with (eq_nat_dec wz1 wz2) := {
+  modu (Vint wz1 n1) (Vint ?(wz1) n2) (left eq_refl) :=
+    if Int.eq wz1 n2 (Int.zero wz1) 
+    then Vundef 
+    else Vint wz1 (Int.modu wz1 n1 n2);
+  modu (Vint wz1 n1) (Vint wz2 n2) (right p) := Vundef  
+  };
+modu _ _ := Vundef.
+
+Equations and (v1 v2: val): val :=
+and (Vint wz1 n1) (Vint wz2 n2) with (eq_nat_dec wz1 wz2) := {
+  and (Vint wz1 n1) (Vint ?(wz1) n2) (left eq_refl) :=
+    Vint wz1 (Int.and wz1 n1 n2);
+  and (Vint wz1 n1) (Vint wz2 n2) (right p) := Vundef  
+  };
+and _ _ := Vundef.
+
+Equations or (v1 v2: val): val :=
+or (Vint wz1 n1) (Vint wz2 n2) with (eq_nat_dec wz1 wz2) := {
+  or (Vint wz1 n1) (Vint ?(wz1) n2) (left eq_refl) :=
+    Vint wz1 (Int.or wz1 n1 n2);
+  or (Vint wz1 n1) (Vint wz2 n2) (right p) := Vundef  
+  };
+or _ _ := Vundef.
+
+Equations xor (v1 v2: val): val :=
+xor (Vint wz1 n1) (Vint wz2 n2) with (eq_nat_dec wz1 wz2) := {
+  xor (Vint wz1 n1) (Vint ?(wz1) n2) (left eq_refl) :=
+    Vint wz1 (Int.xor wz1 n1 n2);
+  xor (Vint wz1 n1) (Vint wz2 n2) (right p) := Vundef  
+  };
+xor _ _ := Vundef.
+
+Equations shl (v1 v2: val): val :=
+shl (Vint wz1 n1) (Vint wz2 n2) with (eq_nat_dec wz1 wz2) := {
+  shl (Vint wz1 n1) (Vint ?(wz1) n2) (left eq_refl) :=
+    if Int.ltu wz1 n2 (Int.iwordsize wz1)
+    then Vint wz1 (Int.shl wz1 n1 n2)
+    else Vundef;
+  shl (Vint wz1 n1) (Vint wz2 n2) (right p) := Vundef  
+  };
+shl _ _ := Vundef.
+
+Equations shr (v1 v2: val): val :=
+shr (Vint wz1 n1) (Vint wz2 n2) with (eq_nat_dec wz1 wz2) := {
+  shr (Vint wz1 n1) (Vint ?(wz1) n2) (left eq_refl) :=
+    if Int.ltu wz1 n2 (Int.iwordsize wz1)
+    then Vint wz1 (Int.shr wz1 n1 n2)
+    else Vundef;
+  shr (Vint wz1 n1) (Vint wz2 n2) (right p) := Vundef  
+  };
+shr _ _ := Vundef.
+
+Equations shr_carry (v1 v2: val): val :=
+shr_carry (Vint wz1 n1) (Vint wz2 n2) with (eq_nat_dec wz1 wz2) := {
+  shr_carry (Vint wz1 n1) (Vint ?(wz1) n2) (left eq_refl) :=
+    if Int.ltu wz1 n2 (Int.iwordsize wz1)
+    then Vint wz1 (Int.shr_carry wz1 n1 n2)
+    else Vundef;
+  shr_carry (Vint wz1 n1) (Vint wz2 n2) (right p) := Vundef  
+  };
+shr_carry _ _ := Vundef.
+
+Equations shrx (v1 v2: val): val :=
+shrx (Vint wz1 n1) (Vint wz2 n2) with (eq_nat_dec wz1 wz2) := {
+  shrx (Vint wz1 n1) (Vint ?(wz1) n2) (left eq_refl) :=
+    if Int.ltu wz1 n2 (Int.iwordsize wz1)
+    then Vint wz1 (Int.shrx wz1 n1 n2)
+    else Vundef;
+  shrx (Vint wz1 n1) (Vint wz2 n2) (right p) := Vundef  
+  };
+shrx _ _ := Vundef.
+
+Equations shru (v1 v2: val): val :=
+shru (Vint wz1 n1) (Vint wz2 n2) with (eq_nat_dec wz1 wz2) := {
+  shru (Vint wz1 n1) (Vint ?(wz1) n2) (left eq_refl) :=
+    if Int.ltu wz1 n2 (Int.iwordsize wz1)
+    then Vint wz1 (Int.shru wz1 n1 n2)
+    else Vundef;
+  shru (Vint wz1 n1) (Vint wz2 n2) (right p) := Vundef  
+  };
+shru _ _ := Vundef.
+
+(*
+Record R (wz:nat) := mkR { a : nat }.
+
+Inductive D : Prop :=
+  | C : forall (wz:nat), wz <> 0%nat -> R wz -> D
+  .
+
+Definition f (wz:nat) (H:wz <> 0%nat) (r1 r2 r3: R wz) : D := 
+match wz with
+| O => C wz H r1
+| S O => C wz H r2
+| _ => C wz H r3
+end. 
+
+Equations test (d d': D) : D :=
+test (C wz wz_isnt_zero r) (C wz' wz_isnt_zero' r') with (eq_nat_dec wz wz') := {
+  test (C wz wz_isnt_zero r) (C ?(wz) wz_isnt_zero' r') (left eq_refl) := f wz wz_isnt_zero r r' r';
+  test (C wz wz_isnt_zero r) (C wz' wz_isnt_zero' r') (right p) := (C wz wz_isnt_zero r)
+  }.
+
+Equations test2 (d: D) (wz':nat) (r' r'': R wz'): D :=
+test2 (C wz wz_isnt_zero r) wz' r' r'' with (eq_nat_dec wz wz') := {
+  test2 (C wz wz_isnt_zero r) ?(wz) r' r'' (left eq_refl) :=f wz wz_isnt_zero r r' r'';
+  test2 (C wz wz_isnt_zero r) wz' r' r'' _ := (C wz wz_isnt_zero r)
+  }.
+
+Equations rolm (v: val) (wz:nat) (amount mask: Int.int wz): val :=
+rolm (Vint wz1 n1) wz0 amount mask <= (eq_nat_dec wz0 wz1) => {
+  rolm (Vint wz1 n1) ?(wz1) amount mask (left eq_refl) :=
+    Vint wz1 (Int.rolm wz1 n1 amount mask);
+  rolm _ _ _ _ (right p) := Vundef
+  };
+rolm _ _ _ _ := Vundef.
+
+Equations rolm (v: val) (wz:nat) (amount mask: Int.int wz): val :=
+rolm (Vint wz1 wz_not_zero1 n1) wz0 amount mask <= (eq_nat_dec wz1 wz0) => {
+  rolm (Vint wz1 wz_not_zero1 n1) ?(wz1) amount mask (left eq_refl) :=
+    Vint wz1 wz_not_zero1 (Int.rolm wz1 wz_not_zero1 n1 amount mask);
+  rolm _ _ _ _ (right p) := Vundef
+  };
+rolm _ _ _ _ := Vundef.
+
+Equations rolm (v: val) (wz:nat) (wz_not_zero:wz <> 0%nat) (amount mask: Int.int wz): val :=
+rolm (Vint wz1 wz_not_zero1 n1) wz0 wz_not_zero0 amount mask with (eq_nat_dec wz1 wz0) := {
+  rolm (Vint wz1 wz_not_zero1 n1) ?(wz1) wz_not_zero0 amount0 mask (left eq_refl) :=
+    Vint wz1 wz_not_zero1 (Int.rolm wz1 wz_not_zero1 n1 amount0 mask);
+  rolm (Vint wz1 wz_not_zero1 n1) wz0 wz_not_zero0 amount mask (right p) := Vundef  
+  };
+rolm _ _ _ _ _ := Vundef.
+*)
 
-Definition rolm (v: val) (amount mask: int): val :=
+Definition rolm (v: val) (amount mask: int32): val :=
   match v with
-  | Vint n => Vint(Int.rolm n amount mask)
+  | Vint 31 n => Vint 31 (Int.rolm 31 n amount mask)
   | _ => Vundef
   end.
 
-Definition ror (v1 v2: val): val :=
-  match v1, v2 with
-  | Vint n1, Vint n2 =>
-     if Int.ltu n2 Int.iwordsize
-     then Vint(Int.ror n1 n2)
-     else Vundef
-  | _, _ => Vundef
-  end.
+Equations ror (v1 v2: val): val :=
+ror (Vint wz1 n1) (Vint wz2 n2) with (eq_nat_dec wz1 wz2) := {
+  ror (Vint wz1 n1) (Vint ?(wz1) n2) (left eq_refl) :=
+    if Int.ltu wz1 n2 (Int.iwordsize wz1)
+    then Vint wz1 (Int.ror wz1 n1 n2)
+    else Vundef;
+  ror (Vint wz1 n1) (Vint wz2 n2) (right p) := Vundef  
+  };
+ror _ _ := Vundef.
 
 Definition addf (v1 v2: val): val :=
   match v1, v2 with
@@ -335,6 +526,12 @@
   | _, _ => Vundef
   end.
 
+Definition modf (v1 v2: val): val :=
+  match v1, v2 with
+  | Vfloat f1, Vfloat f2 => Vfloat(Float.rem f1 f2)
+  | _, _ => Vundef
+  end.
+
 Definition cmp_mismatch (c: comparison): val :=
   match c with
   | Ceq => Vfalse
@@ -342,34 +539,69 @@
   | _   => Vundef
   end.
 
-Definition cmp (c: comparison) (v1 v2: val): val :=
-  match v1, v2 with
-  | Vint n1, Vint n2 => of_bool (Int.cmp c n1 n2)
-  | Vint n1, Vptr b2 ofs2 =>
-      if Int.eq n1 Int.zero then cmp_mismatch c else Vundef
-  | Vptr b1 ofs1, Vptr b2 ofs2 =>
-      if zeq b1 b2
-      then of_bool (Int.cmp c ofs1 ofs2)
-      else cmp_mismatch c
-  | Vptr b1 ofs1, Vint n2 =>
-      if Int.eq n2 Int.zero then cmp_mismatch c else Vundef
-  | _, _ => Vundef
-  end.
-
-Definition cmpu (c: comparison) (v1 v2: val): val :=
-  match v1, v2 with
-  | Vint n1, Vint n2 =>
-      of_bool (Int.cmpu c n1 n2)
-  | Vint n1, Vptr b2 ofs2 =>
-      if Int.eq n1 Int.zero then cmp_mismatch c else Vundef
-  | Vptr b1 ofs1, Vptr b2 ofs2 =>
-      if zeq b1 b2
-      then of_bool (Int.cmpu c ofs1 ofs2)
-      else cmp_mismatch c
-  | Vptr b1 ofs1, Vint n2 =>
-      if Int.eq n2 Int.zero then cmp_mismatch c else Vundef
-  | _, _ => Vundef
-  end.
+Equations cmp (c: comparison) (v1 v2: val): val :=
+cmp c (Vint wz1 n1) (Vint wz2 n2) with (eq_nat_dec wz1 wz2) := {
+  cmp c (Vint wz1 n1) (Vint ?(wz1) n2) (left eq_refl) :=
+    of_bool (Int.cmp wz1 c n1 n2);
+  cmp c (Vint wz1 n1) (Vint wz2 n2) (right p) := Vundef  
+  };
+cmp c (Vint wz1 n1) (Vptr b2 ofs2) with (eq_nat_dec wz1 31) := {
+  cmp c (Vint ?(wz1) n1) (Vptr b2 ofs2) (left eq_refl) :=
+    if Int.eq 31 n1 (Int.zero 31) then cmp_mismatch c else Vundef;
+  cmp c (Vint wz1 n1) (Vptr b2 ofs2) (right p) := Vundef
+  };
+cmp c (Vptr b1 ofs1) (Vptr b2 ofs2) :=
+  if zeq b1 b2
+  then of_bool (Int.cmp 31 c ofs1 ofs2)
+  else cmp_mismatch c;
+cmp c (Vptr b1 ofs1) (Vint wz2 n2) with (eq_nat_dec wz2 31) := {
+  cmp c (Vptr b1 ofs1) (Vint ?(wz2) n2) (left eq_refl) :=
+    if Int.eq 31 n2 (Int.zero 31) then cmp_mismatch c else Vundef;
+  cmp c (Vptr b1 ofs1) (Vint wz2 n2) (right p) := Vundef
+  };
+cmp c (Vint wz1 n1) (Vinttoptr n2) with (eq_nat_dec wz1 31) := {
+  cmp c (Vint wz1 n1) (Vinttoptr n2) (left eq_refl) := Vundef;
+  cmp c (Vint wz1 n1) (Vinttoptr n2) (right p) := Vundef  
+  };
+cmp c (Vinttoptr n1) (Vinttoptr n2) := of_bool (Int.cmp 31 c n1 n2);
+cmp c (Vinttoptr n1) (Vint wz2 n2) with (eq_nat_dec wz2 31) := {
+  cmp c (Vinttoptr n1) (Vint ?(wz2) n2) (left eq_refl) := Vundef;
+  cmp c (Vinttoptr n1) (Vint wz2 n2) (right p) := Vundef  
+  };
+(* FIXME: Vptr and Vinttoptr are not compariable. *)
+cmp _ _ _ := Vundef.
+
+Equations cmpu (c: comparison) (v1 v2: val): val :=
+cmpu c (Vint wz1 n1) (Vint wz2 n2) with (eq_nat_dec wz1 wz2) := {
+  cmpu c (Vint wz1 n1) (Vint ?(wz1) n2) (left eq_refl) :=
+    of_bool (Int.cmpu wz1 c n1 n2);
+  cmpu c (Vint wz1 n1) (Vint wz2 n2) (right p) := Vundef  
+  };
+cmpu c (Vint wz1 n1) (Vptr b2 ofs2) with (eq_nat_dec wz1 31) := {
+  cmpu c (Vint ?(wz1) n1) (Vptr b2 ofs2) (left eq_refl) :=
+    if Int.eq 31 n1 (Int.zero 31) then cmp_mismatch c else Vundef;
+  cmpu c (Vint wz1 n1) (Vptr b2 ofs2) (right p) := Vundef
+  };
+cmpu c (Vptr b1 ofs1) (Vptr b2 ofs2) :=
+  if zeq b1 b2
+  then of_bool (Int.cmpu 31 c ofs1 ofs2)
+  else cmp_mismatch c;
+cmpu c (Vptr b1 ofs1) (Vint wz2 n2) with (eq_nat_dec wz2 31) := {
+  cmpu c (Vptr b1 ofs1) (Vint ?(wz2) n2) (left eq_refl) :=
+    if Int.eq 31 n2 (Int.zero 31) then cmp_mismatch c else Vundef;
+  cmpu c (Vptr b1 ofs1) (Vint wz2 n2) (right p) := Vundef
+  };
+cmpu c (Vint wz1 n1) (Vinttoptr n2) with (eq_nat_dec wz1 31) := {
+  cmpu c (Vint wz1 n1) (Vinttoptr n2) (left eq_refl) := Vundef;
+  cmpu c (Vint wz1 n1) (Vinttoptr n2) (right p) := Vundef  
+  };
+cmpu c (Vinttoptr n1) (Vinttoptr n2) := of_bool (Int.cmpu 31 c n1 n2);
+cmpu c (Vinttoptr n1) (Vint wz2 n2) with (eq_nat_dec wz2 31) := {
+  cmpu c (Vinttoptr n1) (Vint ?(wz2) n2) (left eq_refl) := Vundef;
+  cmpu c (Vinttoptr n1) (Vint wz2 n2) (right p) := Vundef  
+  };
+(* FIXME: Vptr and Vinttoptr are not compariable. *)
+cmpu _ _ _ := Vundef.
 
 Definition cmpf (c: comparison) (v1 v2: val): val :=
   match v1, v2 with
@@ -377,6 +609,862 @@
   | _, _ => Vundef
   end.
 
+(** * Tacticals for Equations *)
+
+Ltac simpl_misc :=
+  (match goal with
+  | [ |- context [Vtrue] ] => unfold Vtrue; unfold Vone; unfold one
+  | [ |- context [Vfalse] ] => unfold Vfalse; unfold Vzero; unfold zero
+  | [ |- context [Vone] ] => unfold Vone; unfold one
+  | [ |- context [Vmone] ] => unfold Vmone; unfold mone
+  | [ |- context [Vzero] ] => unfold Vzero; unfold zero
+  | [ |- context [ Logic.eq_sym ?e ] ] =>
+  generalize (proof_irr e eq_refl);
+  intro; subst; simpl
+  | [ H : get_wordsize (Vint ?wz _) = Some ?wz0 |- _ ] =>
+    simpl in H; inversion H; subst
+  | [ H : get_wordsize (Vone ?wz _) = Some ?wz0 |- _ ] =>
+    simpl in H; inversion H; subst
+  | [ H : get_wordsize (Vmone ?wz _) = Some ?wz0 |- _ ] =>
+    simpl in H; inversion H; subst
+  | [ H : get_wordsize (Vzero ?wz _) = Some ?wz0 |- _ ] =>
+    simpl in H; inversion H; subst
+  | [ H : get_wordsize Vtrue = Some ?wz0 |- _ ] =>
+    simpl in H; inversion H; subst
+  | [ H : get_wordsize Vfalse = Some ?wz0 |- _ ] =>
+    simpl in H; inversion H; subst
+  end).
+
+Ltac simpl_add :=
+  (match goal with
+  | [ |- context [add Vundef _] ] => 
+      rewrite add_equation_1
+  | [ |- context [add (Vint ?wz ?i) Vundef] ] => 
+      rewrite add_equation_2
+
+  | [ |- context [add (Vint ?wz ?i) (Vint ?wz0 ?i0)] ] =>
+      rewrite add_equation_3;
+      unfold add_obligation_3;
+      unfold add_obligation_2;
+      destruct (eq_nat_dec wz wz0); subst
+  | [ |- context [add_obligation_1] ] =>
+      unfold add_obligation_1;
+      unfold solution_left;
+      unfold eq_rect_r;
+      unfold eq_rect;
+      simpl
+
+  | [ |- context [add (Vint ?wz ?i) (Vfloat ?f)] ] =>
+      rewrite add_equation_4
+
+  | [ |- context [add (Vint ?wz ?i) (Vptr _ _)] ] =>
+    rewrite add_equation_5;
+    unfold add_obligation_6;
+    unfold add_obligation_5;
+    destruct (eq_nat_dec wz 31); subst
+  | [ |- context [add_obligation_4] ] =>
+    unfold add_obligation_4;
+    unfold solution_left;
+    unfold eq_rect_r;
+    unfold eq_rect;
+    simpl
+
+  | [ |- context [add (Vint ?wz ?i) (Vinttoptr ?i0) ] ] =>
+  rewrite add_equation_6;
+  unfold add_obligation_9;
+  unfold add_obligation_8;
+  unfold add_obligation_7;
+  unfold solution_left;
+  unfold eq_rect_r;
+  unfold eq_rect;
+  destruct (eq_nat_dec wz 31); subst
+
+  | [ |- context [add (Vfloat ?f) _] ] =>
+      rewrite add_equation_7
+  | [ |- context [add (Vptr ?b ?i) Vundef] ] =>
+      rewrite add_equation_8
+
+  | [ |- context [add (Vptr _ _) (Vint ?wz ?i)] ] =>
+  rewrite add_equation_9;
+  unfold add_obligation_13;
+  unfold add_obligation_12;
+  destruct (eq_nat_dec wz 31); subst
+  | [ |- context [add_obligation_8] ] =>
+  unfold add_obligation_8;
+  unfold solution_left;
+  unfold eq_rect_r;
+  unfold eq_rect;
+  simpl
+
+  | [ |- context [add (Vptr ?b ?i) (Vfloat ?f)] ] =>
+      rewrite add_equation_10
+  | [ |- context [add (Vptr ?b ?i) (Vptr ?b0 ?i0)] ] =>
+      rewrite add_equation_11
+
+  | [ |- context [add (Vptr ?b ?i) (Vinttoptr ?i0)] ] =>
+      rewrite add_equation_12
+  | [ |- context [add (Vinttoptr ?i) Vundef] ] => 
+      rewrite add_equation_13
+
+  | [ |- context [add (Vinttoptr ?i0) (Vint ?wz ?i)] ] =>
+  rewrite add_equation_14;
+  unfold add_obligation_17;
+  unfold add_obligation_16;
+  unfold add_obligation_15;
+  unfold solution_left;
+  unfold eq_rect_r;
+  unfold eq_rect;
+  destruct (eq_nat_dec wz 31); subst
+
+  | [ |- context [add (Vinttoptr ?i) (Vfloat ?f)] ] => 
+      rewrite add_equation_15
+
+  | [ |- context [add (Vinttoptr ?i) (Vptr ?b ?i0)] ] => 
+      rewrite add_equation_16
+
+  | [ |- context [add (Vinttoptr ?i) (Vinttoptr ?i0)] ] => 
+      rewrite add_equation_17
+
+  | [ |- context [add_obligation_11] ] =>
+      unfold add_obligation_11, solution_left, eq_rect_r, eq_rect
+
+  end).
+
+Ltac ctx_contradiction :=
+  match goal with
+  | [ H : eq_nat_dec ?wz ?wz = in_right |- _ ] =>
+    let e := fresh "e" in
+    let n := fresh "n" in
+    destruct (eq_nat_dec wz wz) as [e | n]; try solve
+      [inversion H | contradiction n; auto]
+  | [ H : eq_nat_dec ?wz0 ?wz = in_right, 
+      H' : Some ?wz = Some ?wz0 
+      |- _ ] =>
+    let e := fresh "e" in
+    let n := fresh "n" in
+    inversion H'; subst;
+    destruct (eq_nat_dec wz0 wz0) as [e | n]; try solve
+      [inversion H | contradiction n; auto]
+  | [ H : eq_nat_dec ?wz0 ?wz = in_right, 
+      H' : Some ?wz0 = Some ?wz 
+      |- _ ] =>
+    let e := fresh "e" in
+    let n := fresh "n" in
+    inversion H'; subst;
+    destruct (eq_nat_dec wz0 wz0) as [e | n]; try solve
+      [inversion H | contradiction n; auto]
+  | [ H : None = Some _ |- _] => inversion H
+  | [ H : Some _ = None |- _] => inversion H
+  | [ H : ?wz ≠ ?wz |- _] => contradiction H; auto
+  | [ H : ?wz ≠ ?wz0, 
+      H' : Some ?wz = Some ?wz0
+      |- _] => 
+    inversion H'; subst;
+    contradiction H; auto
+  | [ H : ?wz ≠ ?wz0, 
+      H' : Some ?wz0 = Some ?wz
+      |- _] => 
+    inversion H'; subst;
+    contradiction H; auto
+  | [ H : ?wz ≠ ?wz0, 
+      H' : get_wordsize (Vint ?wz _) = Some ?wz0
+      |- _] => 
+    simpl in H'; inversion H'; subst;
+    contradiction H; auto
+  | [ H : ?wz ≠ ?wz0, 
+      H' : get_wordsize (Vint ?wz0 _) = Some ?wz
+      |- _] => 
+    simpl in H'; inversion H'; subst;
+    contradiction H; auto
+  | [ H : ?wz ≠ 31%nat, 
+      H' : get_wordsize (Vptr _ _) = Some ?wz
+      |- _] => 
+    simpl in H'; inversion H'; subst;
+    contradiction H; auto
+  | [ H : ?wz ≠ ?wz |- _] => contradict H; auto
+  end.
+
+Ltac simpl_sub :=
+  try (match goal with
+  | [ |- context [sub Vundef _] ] => 
+      rewrite sub_equation_1
+  | [ |- context [sub (Vint ?wz ?i) Vundef] ] => 
+      rewrite sub_equation_2
+
+  | [ |- context [sub (Vint ?wz ?i) (Vint ?wz0 ?i0)] ] =>
+      rewrite sub_equation_3;
+      unfold sub_obligation_3;
+      unfold sub_obligation_2;
+      destruct (eq_nat_dec wz wz0); subst
+  | [ |- context [sub_obligation_1] ] =>
+      unfold sub_obligation_1;
+      unfold solution_left;
+      unfold eq_rect_r;
+      unfold eq_rect;
+      simpl
+
+  | [ |- context [sub (Vint ?wz ?i) (Vfloat ?f)] ] =>
+      rewrite sub_equation_4
+  | [ |- context [sub (Vint ?wz ?i) (Vptr ?b ?i0)] ] =>
+      rewrite sub_equation_5
+  | [ |- context [sub (Vint ?wz ?i) (Vinttoptr ?i0)] ] =>
+      rewrite sub_equation_6
+  | [ |- context [sub (Vfloat ?f) _] ] =>
+      rewrite sub_equation_7
+  | [ |- context [sub (Vptr ?b ?i) Vundef] ] =>
+      rewrite sub_equation_8
+
+  | [ |- context [sub (Vptr ?b ?i) (Vint ?wz0 ?i0)] ] =>
+      rewrite sub_equation_9;
+      unfold sub_obligation_7;
+      unfold sub_obligation_6;
+      unfold sub_obligation_5;
+      unfold solution_left;
+      unfold eq_rect_r;
+      unfold eq_rect;
+      destruct (eq_nat_dec wz0 31); subst
+  | [ |- context [sub_obligation_5] ] =>
+      unfold sub_obligation_5;
+      unfold solution_left;
+      unfold eq_rect_r;
+      unfold eq_rect;
+      simpl
+
+  | [ |- context [sub (Vptr ?b ?i) (Vfloat ?f)] ] =>
+      rewrite sub_equation_10
+  | [ |- context [sub (Vptr ?b ?i) (Vptr ?b0 ?i0)] ] =>
+      rewrite sub_equation_11
+  | [ |- context [sub (Vptr ?b ?i) (Vinttoptr ?i0)] ] =>
+      rewrite sub_equation_12
+  | [ |- context [sub (Vinttoptr ?i) Vundef] ] =>
+      rewrite sub_equation_13
+
+  | [ |- context [sub (Vinttoptr ?i) (Vint ?wz0 ?i0)] ] =>
+      rewrite sub_equation_14;
+      unfold sub_obligation_11;
+      unfold sub_obligation_10;
+      unfold sub_obligation_9;
+      unfold solution_left;
+      unfold eq_rect_r;
+      unfold eq_rect;
+      destruct (eq_nat_dec wz0 31); subst
+
+  | [ |- context [sub (Vinttoptr ?i) (Vfloat ?f)] ] =>
+      rewrite sub_equation_15
+  | [ |- context [sub (Vinttoptr ?i) (Vptr ?b0 ?i0)] ] =>
+      rewrite sub_equation_16
+  | [ |- context [sub (Vinttoptr ?i) (Vinttoptr ?i0)] ] =>
+      rewrite sub_equation_17
+
+  end).
+
+Ltac simpl_mul :=
+  (match goal with
+  | [ |- context [mul Vundef _] ] => 
+      rewrite mul_equation_1
+  | [ |- context [mul (Vint ?wz ?i) Vundef] ] => 
+      rewrite mul_equation_2
+
+  | [ |- context [mul (Vint ?wz ?i) (Vint ?wz0 ?i0)] ] =>
+      rewrite mul_equation_3;
+      unfold mul_obligation_3;
+      unfold mul_obligation_2;
+      destruct (eq_nat_dec wz wz0); subst
+  | [ |- context [mul_obligation_1] ] =>
+      unfold mul_obligation_1;
+      unfold solution_left;
+      unfold eq_rect_r;
+      unfold eq_rect;
+      simpl
+
+  | [ |- context [mul (Vint ?wz ?i) (Vfloat ?f)] ] =>
+      rewrite mul_equation_4
+  | [ |- context [mul (Vint ?wz ?i) (Vptr ?b ?i0)] ] =>
+      rewrite mul_equation_5
+  | [ |- context [mul (Vfloat ?f) _] ] =>
+      rewrite mul_equation_6
+  | [ |- context [mul (Vptr ?b ?i) _] ] =>
+      rewrite mul_equation_7
+  end).
+
+Ltac simpl_divs :=
+  (match goal with
+  | [ |- context [divs Vundef _] ] => 
+      rewrite divs_equation_1
+  | [ |- context [divs (Vint ?wz ?i) Vundef] ] => 
+      rewrite divs_equation_2
+
+  | [ |- context [divs (Vint ?wz ?i) (Vint ?wz0 ?i0)] ] =>
+      rewrite divs_equation_3;
+      unfold divs_obligation_3;
+      unfold divs_obligation_2;
+      destruct (eq_nat_dec wz wz0); subst
+  | [ |- context [divs_obligation_1] ] =>
+      unfold divs_obligation_1;
+      unfold solution_left;
+      unfold eq_rect_r;
+      unfold eq_rect;
+      simpl
+
+  | [ |- context [divs (Vint ?wz ?i) (Vfloat ?f)] ] =>
+      rewrite divs_equation_4
+  | [ |- context [divs (Vint ?wz ?i) (Vptr ?b ?i0)] ] =>
+      rewrite divs_equation_5
+  | [ |- context [divs (Vfloat ?f) _] ] =>
+      rewrite divs_equation_6
+  | [ |- context [divs (Vptr ?b ?i) _] ] =>
+      rewrite divs_equation_7
+  end).
+
+Ltac simpl_divu :=
+  (match goal with
+  | [ |- context [divu Vundef _] ] => 
+      rewrite divu_equation_1
+  | [ |- context [divu (Vint ?wz ?i) Vundef] ] => 
+      rewrite divu_equation_2
+
+  | [ |- context [divu (Vint ?wz ?i) (Vint ?wz0 ?i0)] ] =>
+      rewrite divu_equation_3;
+      unfold divu_obligation_3;
+      unfold divu_obligation_2;
+      destruct (eq_nat_dec wz wz0); subst
+  | [ |- context [divu_obligation_1] ] =>
+      unfold divu_obligation_1;
+      unfold solution_left;
+      unfold eq_rect_r;
+      unfold eq_rect;
+      simpl
+
+  | [ |- context [divu (Vint ?wz ?i) (Vfloat ?f)] ] =>
+      rewrite divu_equation_4
+  | [ |- context [divu (Vint ?wz ?i) (Vptr ?b ?i0)] ] =>
+      rewrite divu_equation_5
+  | [ |- context [divu (Vfloat ?f) _] ] =>
+      rewrite divu_equation_6
+  | [ |- context [divu (Vptr ?b ?i) _] ] =>
+      rewrite divu_equation_7
+  end).
+
+Ltac simpl_mods :=
+  (match goal with
+  | [ |- context [mods Vundef _] ] => 
+      rewrite mods_equation_1
+  | [ |- context [mods (Vint ?wz ?i) Vundef] ] => 
+      rewrite mods_equation_2
+
+  | [ |- context [mods (Vint ?wz ?i) (Vint ?wz0 ?i0)] ] =>
+      rewrite mods_equation_3;
+      unfold mods_obligation_3;
+      unfold mods_obligation_2;
+      destruct (eq_nat_dec wz wz0); subst
+  | [ |- context [mods_obligation_1] ] =>
+      unfold mods_obligation_1;
+      unfold solution_left;
+      unfold eq_rect_r;
+      unfold eq_rect;
+      simpl
+
+  | [ |- context [mods (Vint ?wz ?i) (Vfloat ?f)] ] =>
+      rewrite mods_equation_4
+  | [ |- context [mods (Vint ?wz ?i) (Vptr ?b ?i0)] ] =>
+      rewrite mods_equation_5
+  | [ |- context [mods (Vfloat ?f) _] ] =>
+      rewrite mods_equation_6
+  | [ |- context [mods (Vptr ?b ?i) _] ] =>
+      rewrite mods_equation_7
+  end).
+
+Ltac simpl_modu :=
+  (match goal with
+  | [ |- context [modu Vundef _] ] => 
+      rewrite modu_equation_1
+  | [ |- context [modu (Vint ?wz ?i) Vundef] ] => 
+      rewrite modu_equation_2
+
+  | [ |- context [modu (Vint ?wz ?i) (Vint ?wz0 ?i0)] ] =>
+      rewrite modu_equation_3;
+      unfold modu_obligation_3;
+      unfold modu_obligation_2;
+      destruct (eq_nat_dec wz wz0); subst
+  | [ |- context [modu_obligation_1] ] =>
+      unfold modu_obligation_1;
+      unfold solution_left;
+      unfold eq_rect_r;
+      unfold eq_rect;
+      simpl
+
+  | [ |- context [modu (Vint ?wz ?i) (Vfloat ?f)] ] =>
+      rewrite modu_equation_4
+  | [ |- context [modu (Vint ?wz ?i) (Vptr ?b ?i0)] ] =>
+      rewrite modu_equation_5
+  | [ |- context [modu (Vfloat ?f) _] ] =>
+      rewrite modu_equation_6
+  | [ |- context [modu (Vptr ?b ?i) _] ] =>
+      rewrite modu_equation_7
+  end).
+
+Ltac simpl_shl :=
+  (match goal with
+  | [ |- context [shl Vundef _] ] => 
+      rewrite shl_equation_1
+  | [ |- context [shl (Vint ?wz ?i) Vundef] ] => 
+      rewrite shl_equation_2
+
+  | [ |- context [shl (Vint ?wz ?i) (Vint ?wz0 ?i0)] ] =>
+      rewrite shl_equation_3;
+      unfold shl_obligation_3;
+      unfold shl_obligation_2;
+      destruct (eq_nat_dec wz wz0); subst
+  | [ |- context [shl_obligation_1] ] =>
+      unfold shl_obligation_1;
+      unfold solution_left;
+      unfold eq_rect_r;
+      unfold eq_rect;
+      simpl
+
+  | [ |- context [shl (Vint ?wz ?i) (Vfloat ?f)] ] =>
+      rewrite shl_equation_4
+  | [ |- context [shl (Vint ?wz ?i) (Vptr ?b ?i0)] ] =>
+      rewrite shl_equation_5
+  | [ |- context [shl (Vfloat ?f) _] ] =>
+      rewrite shl_equation_6
+  | [ |- context [shl (Vptr ?b ?i) _] ] =>
+      rewrite shl_equation_7
+  end).
+
+Ltac simpl_shr :=
+  (match goal with
+  | [ |- context [shr Vundef _] ] => 
+      rewrite shr_equation_1
+  | [ |- context [shr (Vint ?wz ?i) Vundef] ] => 
+      rewrite shr_equation_2
+
+  | [ |- context [shr (Vint ?wz ?i) (Vint ?wz0 ?i0)] ] =>
+      rewrite shr_equation_3;
+      unfold shr_obligation_3;
+      unfold shr_obligation_2;
+      destruct (eq_nat_dec wz wz0); subst
+  | [ |- context [shr_obligation_1] ] =>
+      unfold shr_obligation_1;
+      unfold solution_left;
+      unfold eq_rect_r;
+      unfold eq_rect;
+      simpl
+
+  | [ |- context [shr (Vint ?wz ?i) (Vfloat ?f)] ] =>
+      rewrite shr_equation_4
+  | [ |- context [shr (Vint ?wz ?i) (Vptr ?b ?i0)] ] =>
+      rewrite shr_equation_5
+  | [ |- context [shr (Vfloat ?f) _] ] =>
+      rewrite shr_equation_6
+  | [ |- context [shr (Vptr ?b ?i) _] ] =>
+      rewrite shr_equation_7
+  end).
+
+
+Ltac simpl_shr_carry :=
+  (match goal with
+  | [ |- context [shr_carry Vundef _] ] => 
+      rewrite shr_carry_equation_1
+  | [ |- context [shr_carry (Vint ?wz ?i) Vundef] ] => 
+      rewrite shr_carry_equation_2
+
+  | [ |- context [shr_carry (Vint ?wz ?i) (Vint ?wz0 ?i0)] ] =>
+      rewrite shr_carry_equation_3;
+      unfold shr_carry_obligation_3;
+      unfold shr_carry_obligation_2;
+      destruct (eq_nat_dec wz wz0); subst
+  | [ |- context [shr_carry_obligation_1] ] =>
+      unfold shr_carry_obligation_1;
+      unfold solution_left;
+      unfold eq_rect_r;
+      unfold eq_rect;
+      simpl
+
+  | [ |- context [shr_carry (Vint ?wz ?i) (Vfloat ?f)] ] =>
+      rewrite shr_carry_equation_4
+  | [ |- context [shr_carry (Vint ?wz ?i) (Vptr ?b ?i0)] ] =>
+      rewrite shr_carry_equation_5
+  | [ |- context [shr_carry (Vfloat ?f) _] ] =>
+      rewrite shr_carry_equation_6
+  | [ |- context [shr_carry (Vptr ?b ?i) _] ] =>
+      rewrite shr_carry_equation_7
+  end).
+
+Ltac simpl_shrx :=
+  (match goal with
+  | [ |- context [shrx Vundef _] ] => 
+      rewrite shrx_equation_1
+  | [ |- context [shrx (Vint ?wz ?i) Vundef] ] => 
+      rewrite shrx_equation_2
+
+  | [ |- context [shrx (Vint ?wz ?i) (Vint ?wz0 ?i0)] ] =>
+      rewrite shrx_equation_3;
+      unfold shrx_obligation_3;
+      unfold shrx_obligation_2;
+      destruct (eq_nat_dec wz wz0); subst
+  | [ |- context [shrx_obligation_1] ] =>
+      unfold shrx_obligation_1;
+      unfold solution_left;
+      unfold eq_rect_r;
+      unfold eq_rect;
+      simpl
+
+  | [ |- context [shrx (Vint ?wz ?i) (Vfloat ?f)] ] =>
+      rewrite shrx_equation_4
+  | [ |- context [shrx (Vint ?wz ?i) (Vptr ?b ?i0)] ] =>
+      rewrite shrx_equation_5
+  | [ |- context [shrx (Vfloat ?f) _] ] =>
+      rewrite shrx_equation_6
+  | [ |- context [shrx (Vptr ?b ?i) _] ] =>
+      rewrite shrx_equation_7
+  end).
+
+Ltac simpl_shru :=
+  (match goal with
+  | [ |- context [shru Vundef _] ] => 
+      rewrite shru_equation_1
+  | [ |- context [shru (Vint ?wz ?i) Vundef] ] => 
+      rewrite shru_equation_2
+
+  | [ |- context [shru (Vint ?wz ?i) (Vint ?wz0 ?i0)] ] =>
+      rewrite shru_equation_3;
+      unfold shru_obligation_3;
+      unfold shru_obligation_2;
+      destruct (eq_nat_dec wz wz0); subst
+  | [ |- context [shru_obligation_1] ] =>
+      unfold shru_obligation_1;
+      unfold solution_left;
+      unfold eq_rect_r;
+      unfold eq_rect;
+      simpl
+
+  | [ |- context [shru (Vint ?wz ?i) (Vfloat ?f)] ] =>
+      rewrite shru_equation_4
+  | [ |- context [shru (Vint ?wz ?i) (Vptr ?b ?i0)] ] =>
+      rewrite shru_equation_5
+  | [ |- context [shru (Vfloat ?f) _] ] =>
+      rewrite shru_equation_6
+  | [ |- context [shru (Vptr ?b ?i) _] ] =>
+      rewrite shru_equation_7
+  end).
+
+Ltac simpl_ror :=
+  (match goal with
+  | [ |- context [ror Vundef _] ] => 
+      rewrite ror_equation_1
+  | [ |- context [ror (Vint ?wz ?i) Vundef] ] => 
+      rewrite ror_equation_2
+
+  | [ |- context [ror (Vint ?wz ?i) (Vint ?wz0 ?i0)] ] =>
+      rewrite ror_equation_3;
+      unfold ror_obligation_3;
+      unfold ror_obligation_2;
+      destruct (eq_nat_dec wz wz0); subst
+  | [ |- context [ror_obligation_1] ] =>
+      unfold ror_obligation_1;
+      unfold solution_left;
+      unfold eq_rect_r;
+      unfold eq_rect;
+      simpl
+
+  | [ |- context [ror (Vint ?wz ?i) (Vfloat ?f)] ] =>
+      rewrite ror_equation_4
+  | [ |- context [ror (Vint ?wz ?i) (Vptr ?b ?i0)] ] =>
+      rewrite ror_equation_5
+  | [ |- context [ror (Vfloat ?f) _] ] =>
+      rewrite ror_equation_6
+  | [ |- context [ror (Vptr ?b ?i) _] ] =>
+      rewrite ror_equation_7
+  end).
+
+Ltac simpl_and :=
+  (match goal with
+  | [ |- context [and Vundef _] ] => 
+      rewrite and_equation_1
+  | [ |- context [and (Vint ?wz ?i) Vundef] ] => 
+      rewrite and_equation_2
+
+  | [ |- context [and (Vint ?wz ?i) (Vint ?wz0 ?i0)] ] =>
+      rewrite and_equation_3;
+      unfold and_obligation_3;
+      unfold and_obligation_2;
+      destruct (eq_nat_dec wz wz0); subst
+  | [ |- context [and_obligation_1] ] =>
+      unfold and_obligation_1;
+      unfold solution_left;
+      unfold eq_rect_r;
+      unfold eq_rect;
+      simpl
+
+  | [ |- context [and (Vint ?wz ?i) (Vfloat ?f)] ] =>
+      rewrite and_equation_4
+  | [ |- context [and (Vint ?wz ?i) (Vptr ?b ?i0)] ] =>
+      rewrite and_equation_5
+  | [ |- context [and (Vfloat ?f) _] ] =>
+      rewrite and_equation_6
+  | [ |- context [shr (Vptr ?b ?i) _] ] =>
+      rewrite and_equation_7
+  end).
+
+Ltac simpl_or :=
+  (match goal with
+  | [ |- context [or Vundef _] ] => 
+      rewrite or_equation_1
+  | [ |- context [or (Vint ?wz ?i) Vundef] ] => 
+      rewrite or_equation_2
+
+  | [ |- context [or (Vint ?wz ?i) (Vint ?wz0 ?i0)] ] =>
+      rewrite or_equation_3;
+      unfold or_obligation_3;
+      unfold or_obligation_2;
+      destruct (eq_nat_dec wz wz0); subst
+  | [ |- context [or_obligation_1] ] =>
+      unfold or_obligation_1;
+      unfold solution_left;
+      unfold eq_rect_r;
+      unfold eq_rect;
+      simpl
+
+  | [ |- context [or (Vint ?wz ?i) (Vfloat ?f)] ] =>
+      rewrite or_equation_4
+  | [ |- context [or (Vint ?wz ?i) (Vptr ?b ?i0)] ] =>
+      rewrite or_equation_5
+  | [ |- context [or (Vfloat ?f) _] ] =>
+      rewrite or_equation_6
+  | [ |- context [or (Vptr ?b ?i) _] ] =>
+      rewrite or_equation_7
+  end).
+
+Ltac simpl_xor :=
+  (match goal with
+  | [ |- context [xor Vundef _] ] => 
+      rewrite xor_equation_1
+  | [ |- context [xor (Vint ?wz ?i) Vundef] ] => 
+      rewrite xor_equation_2
+
+  | [ |- context [xor (Vint ?wz ?i) (Vint ?wz0 ?i0)] ] =>
+      rewrite xor_equation_3;
+      unfold xor_obligation_3;
+      unfold xor_obligation_2;
+      destruct (eq_nat_dec wz wz0); subst
+  | [ |- context [xor_obligation_1] ] =>
+      unfold xor_obligation_1;
+      unfold solution_left;
+      unfold eq_rect_r;
+      unfold eq_rect;
+      simpl
+
+  | [ |- context [xor (Vint ?wz ?i) (Vfloat ?f)] ] =>
+      rewrite xor_equation_4
+  | [ |- context [xor (Vint ?wz ?i) (Vptr ?b ?i0)] ] =>
+      rewrite xor_equation_5
+  | [ |- context [xor (Vfloat ?f) _] ] =>
+      rewrite xor_equation_6
+  | [ |- context [xor (Vptr ?b ?i) _] ] =>
+      rewrite xor_equation_7
+  end).
+
+Ltac simpl_cmp :=
+  (match goal with
+  | [ |- context [cmp _ Vundef _] ] => 
+      rewrite cmp_equation_1
+  | [ |- context [cmp _ (Vint ?wz ?i) Vundef] ] => 
+      rewrite cmp_equation_2
+
+  | [ |- context [cmp _ (Vint ?wz ?i) (Vint ?wz0 ?i0)] ] =>
+      rewrite cmp_equation_3;
+      unfold cmp_obligation_3;
+      unfold cmp_obligation_2;
+      destruct (eq_nat_dec wz wz0); subst
+  | [ |- context [cmp_obligation_1] ] =>
+      unfold cmp_obligation_1;
+      unfold solution_left;
+      unfold eq_rect_r;
+      unfold eq_rect;
+      simpl
+
+  | [ |- context [cmp _ (Vint ?wz ?i) (Vfloat ?f)] ] =>
+      rewrite add_equation_4
+
+  | [ |- context [cmp _ (Vint ?wz ?i) (Vptr _ _)] ] =>
+    rewrite cmp_equation_5;
+    unfold cmp_obligation_6;
+    unfold cmp_obligation_5;
+    destruct (eq_nat_dec wz 31); subst
+  | [ |- context [cmp_obligation_4] ] =>
+    unfold cmp_obligation_4;
+    unfold solution_left;
+    unfold eq_rect_r;
+    unfold eq_rect;
+    simpl
+
+  | [ |- context [cmp _ (Vint ?wz ?i) (Vinttoptr ?i0)] ] =>
+  rewrite cmp_equation_6;
+  unfold cmp_obligation_9;
+  unfold cmp_obligation_8;
+  unfold cmp_obligation_7;
+  unfold solution_left;
+  unfold eq_rect_r;
+  unfold eq_rect;
+  destruct (eq_nat_dec wz 31); subst
+
+  | [ |- context [cmp _ (Vfloat ?f) _] ] =>
+      rewrite cmp_equation_7
+  | [ |- context [cmp _ (Vptr ?b ?i) Vundef] ] =>
+      rewrite cmp_equation_8
+
+  | [ |- context [cmp _ (Vptr _ _) (Vint ?wz ?i)] ] =>
+  rewrite cmp_equation_9;
+  unfold cmp_obligation_13;
+  unfold cmp_obligation_12;
+  unfold cmp_obligation_11;
+  unfold solution_left;
+  unfold eq_rect_r;
+  unfold eq_rect;
+  destruct (eq_nat_dec wz 31); subst
+
+  | [ |- context [cmp_obligation_8] ] =>
+  unfold cmp_obligation_8;
+  unfold solution_left;
+  unfold eq_rect_r;
+  unfold eq_rect;
+  simpl
+
+  | [ |- context [cmp _ (Vptr ?b ?i) (Vfloat ?f)] ] =>
+      rewrite cmp_equation_10
+  | [ |- context [cmp _ (Vptr ?b ?i) (Vptr ?b0 ?i0)] ] =>
+      rewrite cmp_equation_11
+  | [ |- context [cmp _ (Vptr ?b ?i) (Vinttoptr ?i0)] ] =>
+      rewrite cmp_equation_12
+  | [ |- context [cmp _ (Vinttoptr ?i) Vundef] ] =>
+      rewrite cmp_equation_13
+
+  | [ |- context [cmp _ (Vinttoptr ?i) (Vint ?wz0 ?i0)] ] =>
+  rewrite cmp_equation_14;
+  unfold cmp_obligation_17;
+  unfold cmp_obligation_16;
+  unfold cmp_obligation_15;
+  unfold solution_left;
+  unfold eq_rect_r;
+  unfold eq_rect;
+  destruct (eq_nat_dec wz0 31); subst
+
+  | [ |- context [cmp _ (Vinttoptr ?i) (Vfloat ?f0)] ] =>
+      rewrite cmp_equation_15
+  | [ |- context [cmp _ (Vinttoptr ?i) (Vptr ?b0 ?i0)] ] =>
+      rewrite cmp_equation_16
+  | [ |- context [cmp _ (Vinttoptr ?i) (Vinttoptr ?i0)] ] =>
+      rewrite cmp_equation_17
+
+  end).
+
+Ltac simpl_cmpu :=
+  (match goal with
+  | [ |- context [cmpu _ Vundef _] ] => 
+      rewrite cmpu_equation_1
+  | [ |- context [cmpu _ (Vint ?wz ?i) Vundef] ] => 
+      rewrite cmpu_equation_2
+
+  | [ |- context [cmpu _ (Vint ?wz ?i) (Vint ?wz0 ?i0)] ] =>
+      rewrite cmpu_equation_3;
+      unfold cmpu_obligation_3;
+      unfold cmpu_obligation_2;
+      destruct (eq_nat_dec wz wz0); subst
+  | [ |- context [cmpu_obligation_1] ] =>
+      unfold cmpu_obligation_1;
+      unfold solution_left;
+      unfold eq_rect_r;
+      unfold eq_rect;
+      simpl
+
+  | [ |- context [cmpu _ (Vint ?wz ?i) (Vfloat ?f)] ] =>
+      rewrite add_equation_4
+
+  | [ |- context [cmpu _ (Vint ?wz ?i) (Vptr _ _)] ] =>
+    rewrite cmpu_equation_5;
+    unfold cmpu_obligation_6;
+    unfold cmpu_obligation_5;
+    destruct (eq_nat_dec wz 31); subst
+  | [ |- context [cmpu_obligation_4] ] =>
+    unfold cmpu_obligation_4;
+    unfold solution_left;
+    unfold eq_rect_r;
+    unfold eq_rect;
+    simpl
+
+  | [ |- context [cmpu _ (Vint ?wz ?i) (Vinttoptr ?i0)] ] =>
+  rewrite cmpu_equation_6;
+  unfold cmpu_obligation_9;
+  unfold cmpu_obligation_8;
+  unfold cmpu_obligation_7;
+  unfold solution_left;
+  unfold eq_rect_r;
+  unfold eq_rect;
+  destruct (eq_nat_dec wz 31); subst
+
+  | [ |- context [cmpu _ (Vfloat ?f) _] ] =>
+      rewrite cmpu_equation_7
+  | [ |- context [cmpu _ (Vptr ?b ?i) Vundef] ] =>
+      rewrite cmpu_equation_8
+
+  | [ |- context [cmpu _ (Vptr _ _) (Vint ?wz ?i)] ] =>
+  rewrite cmpu_equation_9;
+  unfold cmpu_obligation_13;
+  unfold cmpu_obligation_12;
+  unfold cmpu_obligation_11;
+  unfold solution_left;
+  unfold eq_rect_r;
+  unfold eq_rect;
+  destruct (eq_nat_dec wz 31); subst
+
+  | [ |- context [cmpu_obligation_8] ] =>
+  unfold cmpu_obligation_8;
+  unfold solution_left;
+  unfold eq_rect_r;
+  unfold eq_rect;
+  simpl
+
+  | [ |- context [cmpu _ (Vptr ?b ?i) (Vfloat ?f)] ] =>
+      rewrite cmpu_equation_10
+  | [ |- context [cmpu _ (Vptr ?b ?i) (Vptr ?b0 ?i0)] ] =>
+      rewrite cmpu_equation_11
+  | [ |- context [cmpu _ (Vptr ?b ?i) (Vinttoptr ?i0)] ] =>
+      rewrite cmpu_equation_12
+  | [ |- context [cmpu _ (Vinttoptr ?i) Vundef] ] =>
+      rewrite cmpu_equation_13
+
+  | [ |- context [cmpu _ (Vinttoptr ?i) (Vint ?wz0 ?i0)] ] =>
+  rewrite cmpu_equation_14;
+  unfold cmpu_obligation_17;
+  unfold cmpu_obligation_16;
+  unfold cmpu_obligation_15;
+  unfold solution_left;
+  unfold eq_rect_r;
+  unfold eq_rect;
+  destruct (eq_nat_dec wz0 31); subst
+
+  | [ |- context [cmpu _ (Vinttoptr ?i) (Vfloat ?f0)] ] =>
+      rewrite cmpu_equation_15
+  | [ |- context [cmpu _ (Vinttoptr ?i) (Vptr ?b0 ?i0)] ] =>
+      rewrite cmpu_equation_16
+  | [ |- context [cmpu _ (Vinttoptr ?i) (Vinttoptr ?i0)] ] =>
+      rewrite cmpu_equation_17
+
+  end).
+
+Ltac simpl_equations := repeat 
+  (simpl || simpl_misc || 
+   simpl_add || simpl_sub || 
+   simpl_mul || simpl_divs || simpl_mods || simpl_divu || simpl_modu ||
+   simpl_shl || simpl_shr || simpl_shr_carry || simpl_shrx || simpl_shru || 
+   simpl_ror || simpl_and || simpl_or || simpl_xor ||
+   simpl_cmp || simpl_cmpu ).
+
+Ltac simpl_auto_equations := 
+  simpl_equations; try solve [auto | ctx_contradiction].
+
+
 (** [load_result] is used in the memory model (library [Mem])
   to post-process the results of a memory read.  For instance,
   consider storing the integer value [0xFFF] on 1 byte at a
@@ -388,12 +1476,9 @@
 
 Definition load_result (chunk: memory_chunk) (v: val) :=
   match chunk, v with
-  | Mint8signed, Vint n => Vint (Int.sign_ext 8 n)
-  | Mint8unsigned, Vint n => Vint (Int.zero_ext 8 n)
-  | Mint16signed, Vint n => Vint (Int.sign_ext 16 n)
-  | Mint16unsigned, Vint n => Vint (Int.zero_ext 16 n)
-  | Mint32, Vint n => Vint n
-  | Mint32, Vptr b ofs => Vptr b ofs
+  | Mint wz1, Vint wz2 n => Vint wz1 (Int.repr wz1 (Int.unsigned wz2 n))
+  | Mint wz, Vptr b ofs => if eq_nat_dec wz 31 then Vptr b ofs else Vundef
+  | Mint wz, Vinttoptr i => if eq_nat_dec wz 31 then Vinttoptr i else Vundef
   | Mfloat32, Vfloat f => Vfloat(Float.singleoffloat f)
   | Mfloat64, Vfloat f => Vfloat f
   | _, _ => Vundef
@@ -401,42 +1486,53 @@
 
 (** Theorems on arithmetic operations. *)
 
+Section ArithOperations.
+
+Variable x : val.
+
+Hypothesis x_is_int : get_wordsize x = Some 31%nat.
+
 Theorem cast8unsigned_and:
-  forall x, zero_ext 8 x = and x (Vint(Int.repr 255)).
+  zero_ext 8 x = and x (Vint 31 (Int.repr 31 255)).
 Proof.
-  destruct x; simpl; auto. decEq. 
-  change 255 with (two_p 8 - 1). apply Int.zero_ext_and. vm_compute; auto.
+  destruct x; simpl; auto.
+  funelim (and (Vint wz i) (Vint 31 (Int.repr 31 255))).
+    decEq. change 255 with (two_p 8 - 1). apply Int.zero_ext_and. vm_compute; auto.
+    inversion x_is_int; subst. contradiction f; auto.
 Qed.
 
 Theorem cast16unsigned_and:
-  forall x, zero_ext 16 x = and x (Vint(Int.repr 65535)).
+  zero_ext 16 x = and x (Vint 31 (Int.repr 31 65535)).
 Proof.
-  destruct x; simpl; auto. decEq. 
-  change 65535 with (two_p 16 - 1). apply Int.zero_ext_and. vm_compute; auto.
+  destruct x; simpl; auto. 
+  funelim (and (Vint wz i) (Vint 31 (Int.repr 31 65535))).
+    decEq. change 65535 with (two_p 16 - 1). apply Int.zero_ext_and. vm_compute; auto.
+    inversion x_is_int; subst. contradiction f; auto.
 Qed.
 
+End ArithOperations.
+
 Theorem istrue_not_isfalse:
   forall v, is_false v -> is_true (notbool v).
 Proof.
   destruct v; simpl; try contradiction.
-  intros. subst i. simpl. discriminate.
+  intros. subst i. simpl. apply Int.one_not_zero.
 Qed.
 
 Theorem isfalse_not_istrue:
   forall v, is_true v -> is_false (notbool v).
 Proof.
-  destruct v; simpl; try contradiction.
-  intros. generalize (Int.eq_spec i Int.zero).
-  case (Int.eq i Int.zero); intro.
-  contradiction. simpl. auto.
-  auto.
+  destruct v; simpl; try contradiction; auto.
+  intros. generalize (Int.eq_spec wz i (zero wz)).
+  case (Int.eq wz i (zero wz)); intro; simpl; auto.
+    contradiction. 
 Qed.
 
 Theorem bool_of_true_val:
   forall v, is_true v -> bool_of_val v true.
 Proof.
   intro. destruct v; simpl; intros; try contradiction.
-  constructor; auto. constructor.
+  constructor; auto. constructor. constructor.
 Qed.
 
 Theorem bool_of_true_val2:
@@ -468,7 +1564,7 @@
   forall v b, is_false v -> bool_of_val v b -> b = false.
 Proof.
   intros. inversion H0; subst v b; simpl in H.
-  congruence. auto. contradiction.
+  congruence. auto. contradiction. contradiction.
 Qed.
 
 Theorem notbool_negb_1:
@@ -493,235 +1589,267 @@
   forall x, notbool(notbool(notbool x)) = notbool x.
 Proof.
   destruct x; simpl; auto. 
-  case (Int.eq i Int.zero); reflexivity.
+  case (Int.eq wz i (zero wz)); reflexivity.
 Qed.
 
 Theorem add_commut: forall x y, add x y = add y x.
 Proof.
-  destruct x; destruct y; simpl; auto.
-  decEq. apply Int.add_commut.
+  destruct x; destruct y; simpl_auto_equations;
+    decEq; apply Int.add_commut.
 Qed.
 
 Theorem add_assoc: forall x y z, add (add x y) z = add x (add y z).
 Proof.
-  destruct x; destruct y; destruct z; simpl; auto.
-  rewrite Int.add_assoc; auto.
-  rewrite Int.add_assoc; auto.
-  decEq. decEq. apply Int.add_commut.
-  decEq. rewrite Int.add_commut. rewrite <- Int.add_assoc. 
-  decEq. apply Int.add_commut.
-  decEq. rewrite Int.add_assoc. auto.
+  destruct x; destruct y; destruct z; simpl_auto_equations;
+    try solve [
+      decEq; rewrite Int.add_assoc; auto |
+      decEq; rewrite Int.add_assoc; rewrite (Int.add_commut 31 i i0); auto |
+      decEq; rewrite Int.add_assoc; rewrite (Int.add_commut 31 i i1); 
+        rewrite <- Int.add_assoc; auto
+    ].
 Qed.
 
 Theorem add_permut: forall x y z, add x (add y z) = add y (add x z).
 Proof.
-  intros. rewrite (add_commut y z). rewrite <- add_assoc. apply add_commut.
+  intros. rewrite (add_commut y z). rewrite <- add_assoc.
+  apply (add_commut (add x z) y).
 Qed.
 
 Theorem add_permut_4:
   forall x y z t, add (add x y) (add z t) = add (add x z) (add y t).
 Proof.
-  intros. rewrite add_permut. rewrite add_assoc. 
-  rewrite add_permut. symmetry. apply add_assoc. 
+  intros. rewrite (add_permut (add x y) z t). rewrite add_assoc. 
+  rewrite (add_permut z x _). symmetry. apply (add_assoc x z (add y t)). 
 Qed.
 
-Theorem neg_zero: neg Vzero = Vzero.
+Theorem neg_zero: forall wz, neg (Vzero wz) = (Vzero wz).
 Proof.
   reflexivity.
 Qed.
 
 Theorem neg_add_distr: forall x y, neg(add x y) = add (neg x) (neg y).
 Proof.
-  destruct x; destruct y; simpl; auto. decEq. apply Int.neg_add_distr.
+  destruct x; destruct y; simpl_auto_equations.
+  decEq. apply Int.neg_add_distr.
 Qed.
 
-Theorem sub_zero_r: forall x, sub Vzero x = neg x.
+Theorem sub_zero_r: forall x wz, 
+  get_wordsize x = Some wz -> sub (Vzero wz) x = neg x.
 Proof.
-  destruct x; simpl; auto. 
+  destruct x; intros wz0 H; simpl_auto_equations.
 Qed.
 
-Theorem sub_add_opp: forall x y, sub x (Vint y) = add x (Vint (Int.neg y)).
+Theorem sub_add_opp: forall x wz y, 
+  get_wordsize x = Some wz -> 
+  sub x (Vint wz y) = add x (Vint wz (Int.neg wz y)).
 Proof.
-  destruct x; intro y; simpl; auto; rewrite Int.sub_add_opp; auto.
+  destruct x; intros wz0 y H; simpl_auto_equations;
+    rewrite Int.sub_add_opp; auto.
 Qed.
 
-Theorem sub_opp_add: forall x y, sub x (Vint (Int.neg y)) = add x (Vint y).
+Theorem sub_opp_add: forall x wz y, 
+  get_wordsize x = Some wz -> 
+  sub x (Vint wz (Int.neg wz y)) = add x (Vint wz y).
 Proof.
-  intros. unfold sub, add.
-  destruct x; auto; rewrite Int.sub_add_opp; rewrite Int.neg_involutive; auto.
+  intros x wz y H.
+  destruct x; simpl_auto_equations;
+    rewrite Int.sub_add_opp; rewrite Int.neg_involutive; auto.
 Qed.
 
 Theorem sub_add_l:
-  forall v1 v2 i, sub (add v1 (Vint i)) v2 = add (sub v1 v2) (Vint i).
-Proof.
-  destruct v1; destruct v2; intros; simpl; auto.
-  rewrite Int.sub_add_l. auto.
-  rewrite Int.sub_add_l. auto.
-  case (zeq b b0); intro. rewrite Int.sub_add_l. auto. reflexivity.
+  forall v1 v2 wz i, 
+  get_wordsize v1 = Some wz -> 
+  sub (add v1 (Vint wz i)) v2 = add (sub v1 v2) (Vint wz i).
+Proof.
+  destruct v1; destruct v2; intros wz5 i5 H; simpl_auto_equations;
+    try solve [
+      rewrite Int.sub_add_l; auto |
+      case (zeq b b0); intro; auto; rewrite Int.sub_add_l; auto
+    ].
 Qed.
 
 Theorem sub_add_r:
-  forall v1 v2 i, sub v1 (add v2 (Vint i)) = add (sub v1 v2) (Vint (Int.neg i)).
+  forall v1 v2 wz i,
+  get_wordsize v1 = Some wz -> 
+  sub v1 (add v2 (Vint wz i)) = add (sub v1 v2) (Vint wz (Int.neg wz i)).
 Proof.
-  destruct v1; destruct v2; intros; simpl; auto.
+  destruct v1; destruct v2; intros wz5 i5 H; simpl_auto_equations.
   rewrite Int.sub_add_r. auto.
   repeat rewrite Int.sub_add_opp. decEq. 
   repeat rewrite Int.add_assoc. decEq. apply Int.add_commut.
+
   decEq. repeat rewrite Int.sub_add_opp. 
   rewrite Int.add_assoc. decEq. apply Int.neg_add_distr.
-  case (zeq b b0); intro. simpl. decEq. 
-  repeat rewrite Int.sub_add_opp. rewrite Int.add_assoc. decEq.
+
+  case (zeq b b0); intro; simpl_auto_equations.
+  decEq. 
+  repeat rewrite Int.sub_add_opp.
+  rewrite Int.add_assoc. decEq. decEq. decEq.
   apply Int.neg_add_distr.
-  reflexivity.
+
+  rewrite Int.sub_add_r. auto.
+  repeat rewrite Int.sub_add_opp. decEq. 
+  repeat rewrite Int.add_assoc. decEq. apply Int.add_commut.
+
+  rewrite Int.sub_add_r. auto.
+  repeat rewrite Int.sub_add_opp. decEq. 
+  repeat rewrite Int.add_assoc. decEq. apply Int.add_commut.
 Qed.
 
 Theorem mul_commut: forall x y, mul x y = mul y x.
 Proof.
-  destruct x; destruct y; simpl; auto. decEq. apply Int.mul_commut.
+  destruct x; destruct y; simpl_auto_equations.
+  decEq. apply Int.mul_commut.
 Qed.
 
 Theorem mul_assoc: forall x y z, mul (mul x y) z = mul x (mul y z).
 Proof.
-  destruct x; destruct y; destruct z; simpl; auto.
+  destruct x; destruct y; destruct z; simpl_auto_equations.
   decEq. apply Int.mul_assoc.
 Qed.
 
 Theorem mul_add_distr_l:
   forall x y z, mul (add x y) z = add (mul x z) (mul y z).
 Proof.
-  destruct x; destruct y; destruct z; simpl; auto.
+  destruct x; destruct y; destruct z; simpl_auto_equations.
   decEq. apply Int.mul_add_distr_l.
 Qed.
 
-
 Theorem mul_add_distr_r:
   forall x y z, mul x (add y z) = add (mul x y) (mul x z).
 Proof.
-  destruct x; destruct y; destruct z; simpl; auto.
+  destruct x; destruct y; destruct z; simpl_auto_equations.
   decEq. apply Int.mul_add_distr_r.
 Qed.
 
 Theorem mul_pow2:
-  forall x n logn,
-  Int.is_power2 n = Some logn ->
-  mul x (Vint n) = shl x (Vint logn).
-Proof.
-  intros; destruct x; simpl; auto.
-  change 32 with (Z_of_nat Int.wordsize).
-  rewrite (Int.is_power2_range _ _ H). decEq. apply Int.mul_pow2. auto.
+  forall x wz n logn,
+  get_wordsize x = Some wz ->
+  Int.is_power2 wz n = Some logn ->
+  mul x (Vint wz n) = shl x (Vint wz logn).
+Proof.
+  intros x wz n logn H0 H; destruct x; simpl_auto_equations.
+  rewrite (Int.is_power2_range wz _ _ H). decEq. apply Int.mul_pow2. auto.
 Qed.  
 
 Theorem mods_divs:
   forall x y, mods x y = sub x (mul (divs x y) y).
 Proof.
-  destruct x; destruct y; simpl; auto.
-  case (Int.eq i0 Int.zero); simpl. auto. decEq. apply Int.mods_divs.
+  destruct x; destruct y; simpl_auto_equations.
+  case (Int.eq wz0 i0 (Int.zero wz0)); simpl; simpl_auto_equations.
+  decEq. apply Int.mods_divs.
 Qed.
 
 Theorem modu_divu:
   forall x y, modu x y = sub x (mul (divu x y) y).
 Proof.
-  destruct x; destruct y; simpl; auto.
-  generalize (Int.eq_spec i0 Int.zero);
-  case (Int.eq i0 Int.zero); simpl. auto. 
+  destruct x; destruct y; simpl_auto_equations.
+  generalize (Int.eq_spec wz0 i0 (Int.zero wz0));
+  case (Int.eq wz0 i0 (Int.zero wz0)); simpl_auto_equations.
   intro. decEq. apply Int.modu_divu. auto.
 Qed.
 
 Theorem divs_pow2:
-  forall x n logn,
-  Int.is_power2 n = Some logn ->
-  divs x (Vint n) = shrx x (Vint logn).
-Proof.
-  intros; destruct x; simpl; auto.
-  change 32 with (Z_of_nat Int.wordsize).
-  rewrite (Int.is_power2_range _ _ H). 
-  generalize (Int.eq_spec n Int.zero);
-  case (Int.eq n Int.zero); intro.
-  subst n. compute in H. discriminate.
+  forall x wz n logn,
+  get_wordsize x = Some wz ->
+  Int.is_power2 wz n = Some logn ->
+  divs x (Vint wz n) = shrx x (Vint wz logn).
+Proof.
+  intros x wz n logn H0 H; destruct x; simpl_auto_equations.
+  rewrite (Int.is_power2_range wz _ _ H). 
+  generalize (Int.eq_spec wz n (Int.zero wz));
+  case (Int.eq wz n (Int.zero wz)); intro.
+  subst n. rewrite Int.is_power2_zero in H. discriminate.
   decEq. apply Int.divs_pow2. auto.
 Qed.
 
 Theorem divu_pow2:
-  forall x n logn,
-  Int.is_power2 n = Some logn ->
-  divu x (Vint n) = shru x (Vint logn).
-Proof.
-  intros; destruct x; simpl; auto.
-  change 32 with (Z_of_nat Int.wordsize).
-  rewrite (Int.is_power2_range _ _ H). 
-  generalize (Int.eq_spec n Int.zero);
-  case (Int.eq n Int.zero); intro.
-  subst n. compute in H. discriminate.
+  forall x wz n logn,
+  get_wordsize x = Some wz ->
+  Int.is_power2 wz n = Some logn ->
+  divu x (Vint wz n) = shru x (Vint wz logn).
+Proof.
+  intros x wz n logn H0 H; destruct x; simpl_auto_equations.
+  rewrite (Int.is_power2_range wz _ _ H). 
+  generalize (Int.eq_spec wz n (Int.zero wz));
+  case (Int.eq wz n (Int.zero wz)); intro.
+  subst n. rewrite Int.is_power2_zero in H. discriminate.
   decEq. apply Int.divu_pow2. auto.
 Qed.
 
 Theorem modu_pow2:
-  forall x n logn,
-  Int.is_power2 n = Some logn ->
-  modu x (Vint n) = and x (Vint (Int.sub n Int.one)).
-Proof.
-  intros; destruct x; simpl; auto.
-  generalize (Int.eq_spec n Int.zero);
-  case (Int.eq n Int.zero); intro.
-  subst n. compute in H. discriminate.
+  forall x wz n logn,
+  get_wordsize x = Some wz ->
+  Int.is_power2 wz n = Some logn ->
+  modu x (Vint wz n) = and x (Vint wz (Int.sub wz n (Int.one wz))).
+Proof.
+  intros x wz n logn H0 H; destruct x; simpl_auto_equations.
+  generalize (Int.eq_spec wz n (Int.zero wz));
+  case (Int.eq wz n (Int.zero wz)); intro.
+  subst n. rewrite Int.is_power2_zero in H. discriminate.
   decEq. eapply Int.modu_and; eauto.
 Qed.
 
 Theorem and_commut: forall x y, and x y = and y x.
 Proof.
-  destruct x; destruct y; simpl; auto. decEq. apply Int.and_commut.
+  destruct x; destruct y; simpl_auto_equations. decEq. apply Int.and_commut.
 Qed.
 
 Theorem and_assoc: forall x y z, and (and x y) z = and x (and y z).
 Proof.
-  destruct x; destruct y; destruct z; simpl; auto.
+  destruct x; destruct y; destruct z; simpl_auto_equations.
   decEq. apply Int.and_assoc.
 Qed.
 
 Theorem or_commut: forall x y, or x y = or y x.
 Proof.
-  destruct x; destruct y; simpl; auto. decEq. apply Int.or_commut.
+  destruct x; destruct y; simpl_auto_equations. decEq. apply Int.or_commut.
 Qed.
 
 Theorem or_assoc: forall x y z, or (or x y) z = or x (or y z).
 Proof.
-  destruct x; destruct y; destruct z; simpl; auto.
+  destruct x; destruct y; destruct z; simpl_auto_equations.
   decEq. apply Int.or_assoc.
 Qed.
 
 Theorem xor_commut: forall x y, xor x y = xor y x.
 Proof.
-  destruct x; destruct y; simpl; auto. decEq. apply Int.xor_commut.
+  destruct x; destruct y; simpl_auto_equations. decEq. apply Int.xor_commut.
 Qed.
 
 Theorem xor_assoc: forall x y z, xor (xor x y) z = xor x (xor y z).
 Proof.
-  destruct x; destruct y; destruct z; simpl; auto.
+  destruct x; destruct y; destruct z; simpl_auto_equations.
   decEq. apply Int.xor_assoc.
 Qed.
 
-Theorem shl_mul: forall x y, Val.mul x (Val.shl Vone y) = Val.shl x y.
-Proof.
-  destruct x; destruct y; simpl; auto. 
-  case (Int.ltu i0 Int.iwordsize); auto.
+Theorem shl_mul: forall wz x y, 
+  get_wordsize x = Some wz ->
+  Val.mul x (Val.shl (Vone wz) y) = Val.shl x y.
+Proof.
+  intros wz x y H.
+  destruct x; destruct y; simpl_auto_equations.
+  case (Int.ltu wz1 i0 (Int.iwordsize wz1)); simpl_auto_equations.
   decEq. symmetry. apply Int.shl_mul.
 Qed.
 
 Theorem shl_rolm:
   forall x n,
-  Int.ltu n Int.iwordsize = true ->
-  shl x (Vint n) = rolm x n (Int.shl Int.mone n).
+  get_wordsize x = Some 31%nat ->
+  Int.ltu 31 n (Int.iwordsize 31) = true ->
+  shl x (Vint 31 n) = rolm x n (Int.shl 31 (Int.mone 31) n).
 Proof.
-  intros; destruct x; simpl; auto.
+  intros x n H0 H; destruct x; simpl_auto_equations.
   rewrite H. decEq. apply Int.shl_rolm. exact H.
 Qed.
 
 Theorem shru_rolm:
   forall x n,
-  Int.ltu n Int.iwordsize = true ->
-  shru x (Vint n) = rolm x (Int.sub Int.iwordsize n) (Int.shru Int.mone n).
+  get_wordsize x = Some 31%nat ->
+  Int.ltu 31 n (Int.iwordsize 31) = true ->
+  shru x (Vint 31 n) = rolm x (Int.sub 31 (Int.iwordsize 31) n) (Int.shru 31 (Int.mone 31) n).
 Proof.
-  intros; destruct x; simpl; auto.
+  intros x n H0 H; destruct x; simpl_auto_equations.
   rewrite H. decEq. apply Int.shru_rolm. exact H.
 Qed.
 
@@ -729,35 +1857,38 @@
   forall x y,
   add (shr x y) (shr_carry x y) = shrx x y.
 Proof.
-  destruct x; destruct y; simpl; auto.
-  case (Int.ltu i0 Int.iwordsize); auto.
+  destruct x; destruct y; simpl_auto_equations.
+  case (Int.ltu wz0 i0 (Int.iwordsize wz0)); simpl_auto_equations.
   simpl. decEq. apply Int.shrx_carry.
 Qed.
 
 Theorem or_rolm:
   forall x n m1 m2,
-  or (rolm x n m1) (rolm x n m2) = rolm x n (Int.or m1 m2).
+  get_wordsize x = Some 31%nat ->
+  or (rolm x n m1) (rolm x n m2) = rolm x n (Int.or 31 m1 m2).
 Proof.
-  intros; destruct x; simpl; auto.
+  intros; destruct x; simpl_auto_equations.
   decEq. apply Int.or_rolm.
 Qed.
 
 Theorem rolm_rolm:
   forall x n1 m1 n2 m2,
+  get_wordsize x = Some 31%nat ->
   rolm (rolm x n1 m1) n2 m2 =
-    rolm x (Int.modu (Int.add n1 n2) Int.iwordsize)
-           (Int.and (Int.rol m1 n2) m2).
+    rolm x (Int.modu 31 (Int.add 31 n1 n2) (Int.iwordsize 31))
+           (Int.and 31 (Int.rol 31 m1 n2) m2).
 Proof.
-  intros; destruct x; simpl; auto.
-  decEq. 
-  apply Int.rolm_rolm. apply int_wordsize_divides_modulus.
+  intros; destruct x; simpl_auto_equations.
+  decEq. apply Int.rolm_rolm. apply int32_wordsize_divides_modulus.
 Qed.
 
 Theorem rolm_zero:
   forall x m,
-  rolm x Int.zero m = and x (Vint m).
+  get_wordsize x = Some 31%nat ->
+  rolm x (Int.zero 31) m = and x (Vint 31 m).
 Proof.
-  intros; destruct x; simpl; auto. decEq. apply Int.rolm_zero.
+  intros; destruct x; simpl_auto_equations.
+  decEq. apply Int.rolm_zero.
 Qed.
 
 Theorem addf_commut: forall x y, addf x y = addf y x.
@@ -776,26 +1907,32 @@
   forall c x y,
   cmp (negate_comparison c) x y = notbool (cmp c x y).
 Proof.
-  destruct x; destruct y; simpl; auto.
-  rewrite Int.negate_cmp. apply notbool_negb_1.
-  case (Int.eq i Int.zero). apply negate_cmp_mismatch. reflexivity.
-  case (Int.eq i0 Int.zero). apply negate_cmp_mismatch. reflexivity.
-  case (zeq b b0); intro.
-  rewrite Int.negate_cmp. apply notbool_negb_1.
-  apply negate_cmp_mismatch.
+  destruct x; destruct y; simpl_auto_equations; try solve [
+    rewrite Int.negate_cmp; apply notbool_negb_1 |
+    case (Int.eq 31 i (Int.zero 31)); try solve [
+      apply negate_cmp_mismatch | reflexivity ] |
+    case (Int.eq 31 i0 (Int.zero 31)); try solve [
+      apply negate_cmp_mismatch | reflexivity ] |
+    case (zeq b b0); intro; try solve [
+      rewrite Int.negate_cmp; apply notbool_negb_1 |
+      apply negate_cmp_mismatch ]
+    ].
 Qed.
 
 Theorem negate_cmpu:
   forall c x y,
   cmpu (negate_comparison c) x y = notbool (cmpu c x y).
 Proof.
-  destruct x; destruct y; simpl; auto.
-  rewrite Int.negate_cmpu. apply notbool_negb_1.
-  case (Int.eq i Int.zero). apply negate_cmp_mismatch. reflexivity.
-  case (Int.eq i0 Int.zero). apply negate_cmp_mismatch. reflexivity.
-  case (zeq b b0); intro.
-  rewrite Int.negate_cmpu. apply notbool_negb_1.
-  apply negate_cmp_mismatch.
+  destruct x; destruct y; simpl_auto_equations; try solve [
+      rewrite Int.negate_cmpu; apply notbool_negb_1
+    ].
+    case (Int.eq 31 i (Int.zero 31)); try solve [
+      apply negate_cmp_mismatch | reflexivity ].
+    case (Int.eq 31 i0 (Int.zero 31)); try solve [
+      apply negate_cmp_mismatch | reflexivity ].
+    case (zeq b b0); intro; try solve [
+      rewrite Int.negate_cmpu; apply notbool_negb_1 |
+      apply negate_cmp_mismatch ].
 Qed.
 
 Lemma swap_cmp_mismatch:
@@ -808,32 +1945,34 @@
   forall c x y,
   cmp (swap_comparison c) x y = cmp c y x.
 Proof.
-  destruct x; destruct y; simpl; auto.
-  rewrite Int.swap_cmp. auto.
-  case (Int.eq i Int.zero). apply swap_cmp_mismatch. auto.
-  case (Int.eq i0 Int.zero). apply swap_cmp_mismatch. auto.
+  destruct x; destruct y; simpl_auto_equations; try solve [
+      rewrite Int.swap_cmp; auto
+    ].
+  case (Int.eq 31 i (Int.zero 31)). apply swap_cmp_mismatch. auto.
+  case (Int.eq 31 i0 (Int.zero 31)). apply swap_cmp_mismatch. auto.
   case (zeq b b0); intro.
-  subst b0. rewrite zeq_true. rewrite Int.swap_cmp. auto.
-  rewrite zeq_false. apply swap_cmp_mismatch. auto.
+    subst b0. rewrite zeq_true. rewrite Int.swap_cmp. auto.
+    rewrite zeq_false. apply swap_cmp_mismatch. auto.
 Qed.
 
 Theorem swap_cmpu:
   forall c x y,
   cmpu (swap_comparison c) x y = cmpu c y x.
 Proof.
-  destruct x; destruct y; simpl; auto.
-  rewrite Int.swap_cmpu. auto.
-  case (Int.eq i Int.zero). apply swap_cmp_mismatch. auto.
-  case (Int.eq i0 Int.zero). apply swap_cmp_mismatch. auto.
+  destruct x; destruct y; simpl_auto_equations; try solve [
+      rewrite Int.swap_cmpu; auto
+    ].
+  case (Int.eq 31 i (Int.zero 31)). apply swap_cmp_mismatch. auto.
+  case (Int.eq 31 i0 (Int.zero 31)). apply swap_cmp_mismatch. auto.
   case (zeq b b0); intro.
-  subst b0. rewrite zeq_true. rewrite Int.swap_cmpu. auto.
-  rewrite zeq_false. apply swap_cmp_mismatch. auto.
+    subst b0. rewrite zeq_true. rewrite Int.swap_cmpu. auto.
+    rewrite zeq_false. apply swap_cmp_mismatch. auto.
 Qed.
 
 Theorem negate_cmpf_eq:
   forall v1 v2, notbool (cmpf Cne v1 v2) = cmpf Ceq v1 v2.
 Proof.
-  destruct v1; destruct v2; simpl; auto.
+  destruct v1; destruct v2; simpl_auto_equations.
   rewrite Float.cmp_ne_eq. rewrite notbool_negb_1. 
   apply notbool_idem2.
 Qed.
@@ -841,27 +1980,27 @@
 Theorem negate_cmpf_ne:
   forall v1 v2, notbool (cmpf Ceq v1 v2) = cmpf Cne v1 v2.
 Proof.
-  destruct v1; destruct v2; simpl; auto.
+  destruct v1; destruct v2; simpl_auto_equations.
   rewrite Float.cmp_ne_eq. rewrite notbool_negb_1. auto. 
 Qed.
 
 Lemma or_of_bool:
   forall b1 b2, or (of_bool b1) (of_bool b2) = of_bool (b1 || b2).
 Proof.
-  destruct b1; destruct b2; reflexivity.
+  destruct b1; destruct b2; simpl_auto_equations.
 Qed.
 
 Theorem cmpf_le:
   forall v1 v2, cmpf Cle v1 v2 = or (cmpf Clt v1 v2) (cmpf Ceq v1 v2).
 Proof.
-  destruct v1; destruct v2; simpl; auto.
+  destruct v1; destruct v2; simpl_auto_equations.
   rewrite or_of_bool. decEq. apply Float.cmp_le_lt_eq.
 Qed.
 
 Theorem cmpf_ge:
   forall v1 v2, cmpf Cge v1 v2 = or (cmpf Cgt v1 v2) (cmpf Ceq v1 v2).
 Proof.
-  destruct v1; destruct v2; simpl; auto.
+  destruct v1; destruct v2; simpl_auto_equations.
   rewrite or_of_bool. decEq. apply Float.cmp_ge_gt_eq.
 Qed.
 
@@ -888,61 +2027,124 @@
 Lemma cmp_is_bool:
   forall c v1 v2, is_bool (cmp c v1 v2).
 Proof.
-  destruct v1; destruct v2; simpl; try apply undef_is_bool.
-  apply of_bool_is_bool.
-  case (Int.eq i Int.zero). apply cmp_mismatch_is_bool. apply undef_is_bool.
-  case (Int.eq i0 Int.zero). apply cmp_mismatch_is_bool. apply undef_is_bool.
-  case (zeq b b0); intro. apply of_bool_is_bool. apply cmp_mismatch_is_bool.
+  destruct v1; destruct v2; simpl_auto_equations; try apply undef_is_bool;
+    try solve [apply of_bool_is_bool].
+  case (Int.eq 31 i (Int.zero 31)). 
+    apply cmp_mismatch_is_bool. 
+    apply undef_is_bool.
+  case (Int.eq 31 i0 (Int.zero 31)). 
+    apply cmp_mismatch_is_bool. 
+    apply undef_is_bool.
+  case (zeq b b0); intro. 
+    apply of_bool_is_bool. 
+    apply cmp_mismatch_is_bool.
 Qed.
 
 Lemma cmpu_is_bool:
   forall c v1 v2, is_bool (cmpu c v1 v2).
 Proof.
-  destruct v1; destruct v2; simpl; try apply undef_is_bool.
-  apply of_bool_is_bool.
-  case (Int.eq i Int.zero). apply cmp_mismatch_is_bool. apply undef_is_bool.
-  case (Int.eq i0 Int.zero). apply cmp_mismatch_is_bool. apply undef_is_bool.
-  case (zeq b b0); intro. apply of_bool_is_bool. apply cmp_mismatch_is_bool.
+  destruct v1; destruct v2; simpl_auto_equations; try apply undef_is_bool;
+    try solve [apply of_bool_is_bool].
+  case (Int.eq 31 i (Int.zero 31)). 
+    apply cmp_mismatch_is_bool. 
+    apply undef_is_bool.
+  case (Int.eq 31 i0 (Int.zero 31)). 
+    apply cmp_mismatch_is_bool. 
+    apply undef_is_bool.
+  case (zeq b b0); intro. 
+    apply of_bool_is_bool. 
+    apply cmp_mismatch_is_bool.
 Qed.
 
 Lemma cmpf_is_bool:
   forall c v1 v2, is_bool (cmpf c v1 v2).
 Proof.
-  destruct v1; destruct v2; simpl;
+  destruct v1; destruct v2; simpl_auto_equations;
   apply undef_is_bool || apply of_bool_is_bool.
 Qed.
 
 Lemma notbool_is_bool:
   forall v, is_bool (notbool v).
 Proof.
-  destruct v; simpl.
+  destruct v; simpl_auto_equations.
   apply undef_is_bool. apply of_bool_is_bool. 
   apply undef_is_bool. unfold is_bool; tauto.
+  unfold is_bool. auto.
 Qed.
 
 Lemma notbool_xor:
-  forall v, is_bool v -> v = xor (notbool v) Vone.
+  forall v wz, 
+  get_wordsize v = Some wz ->
+  is_bool v -> v = xor (notbool v) (Vone wz).
 Proof.
-  intros. elim H; intro.  
-  subst v. reflexivity.
-  elim H0; intro; subst v; reflexivity.
+  intros v wz H0 H. elim H; intro.
+  subst v. simpl_auto_equations.
+  elim H1; intro; subst v; simpl_auto_equations.
 Qed.
 
-Lemma rolm_lt_zero:
-  forall v, rolm v Int.one Int.one = cmp Clt v (Vint Int.zero).
+Lemma Vundef__eq_Vbool__Vundef : forall wz, eq_Vbool wz Vundef Vundef.
+Proof.
+  intros wz. unfold eq_Vbool.
+  split; split; intro J; inversion J.
+Qed.
+
+Lemma Vone_not_Vzero : forall wz, Vone wz <> Vzero wz.
+Proof.
+  intros wz. unfold Vone. unfold Vzero.
+  intro J. inversion J.
+  change (1 mod Int.modulus wz) with (Int.unsigned wz (Int.one wz)) in H0.
+  change (0 mod Int.modulus wz) with (Int.unsigned wz (Int.zero wz)) in H0.
+  rewrite (Int.unsigned_one wz) in H0.
+  rewrite (Int.unsigned_zero wz) in H0.
+  inversion H0.
+Qed.
+
+Lemma Vone__eq_Vbool__Vtrue : forall wz, eq_Vbool wz (Vone wz) Vtrue.
+Proof.
+  intros wz. unfold eq_Vbool.
+  split; split; intro J; try solve [auto | inversion J].
+    contradict J. apply Vone_not_Vzero.
+Qed.
+
+Lemma Vzero__eq_Vbool__Vfalse : forall wz, eq_Vbool wz (Vzero wz) Vfalse.
 Proof.
-  intros. destruct v; simpl; auto.
-  transitivity (Vint (Int.shru i (Int.repr (Z_of_nat Int.wordsize - 1)))).
-  decEq. symmetry. rewrite Int.shru_rolm. auto. auto. 
-  rewrite Int.shru_lt_zero. destruct (Int.lt i Int.zero); auto. 
+  intros wz. unfold eq_Vbool.
+  split; split; intro J; try solve [auto | inversion J].
+    symmetry in J. contradict J. apply Vone_not_Vzero.
+Qed.
+
+Lemma rolm_lt_zero:
+  forall v, 
+  get_wordsize v = Some 31%nat ->
+  eq_Vbool 31 (rolm v (Int.one 31) (Int.one 31)) 
+              (cmp Clt v (Vint 31 (Int.zero 31))).
+Proof.
+  intros. destruct v; simpl_auto_equations; 
+    try solve [apply Vundef__eq_Vbool__Vundef].
+
+  assert (Vint 31 (Int.shru 31 i (Int.repr 31 (Z_of_nat 32 - 1))) =
+          Vint 31 (Int.rolm 31 i (Int.one 31) (Int.one 31))) as EQ.
+    decEq. symmetry. rewrite Int.shru_rolm. auto. auto.
+  rewrite <- EQ.
+  rewrite Int.shru_lt_zero. destruct (Int.lt 31 i (Int.zero 31)).
+    apply Vone__eq_Vbool__Vtrue. apply Vzero__eq_Vbool__Vfalse. 
 Qed.
 
 Lemma rolm_ge_zero:
   forall v,
-  xor (rolm v Int.one Int.one) (Vint Int.one) = cmp Cge v (Vint Int.zero).
-Proof.
-  intros. rewrite rolm_lt_zero. destruct v; simpl; auto.
-  destruct (Int.lt i Int.zero); auto.
+  get_wordsize v = Some 31%nat ->
+  eq_Vbool 31 (xor (rolm v (Int.one 31) (Int.one 31)) (Vint 31 (Int.one 31))) 
+              (cmp Cge v (Vint 31 (Int.zero 31))).
+Proof.
+  intros. destruct v; simpl_auto_equations; try solve [apply Vundef__eq_Vbool__Vundef].
+
+  assert ((Int.shru 31 i (Int.repr 31 (Z_of_nat 32 - 1))) =
+          (Int.rolm 31 i (Int.one 31) (Int.one 31))) as EQ.
+    symmetry. rewrite Int.shru_rolm. auto. auto.
+  rewrite <- EQ.
+  rewrite Int.shru_lt_zero. destruct (Int.lt 31 i (Int.zero 31)); simpl.
+    rewrite Int.xor_one_one. apply Vzero__eq_Vbool__Vfalse. 
+    rewrite Int.xor_zero_one. apply Vone__eq_Vbool__Vtrue. 
 Qed.
 
 (** The ``is less defined'' relation between values. 
@@ -997,6 +2199,288 @@
   intros; inv H; simpl; auto.
 Qed.
 
+Definition has_chunk := fun (v : val) (chk : memory_chunk) =>
+match v with
+| Vundef => True
+| Vint wz i0 => match chk with
+              | Mint wz' => wz = wz' /\
+                            0 <= Int.unsigned wz i0 < Int.modulus wz
+              | _ => False
+              end
+| Vfloat f => match chk with
+              | Mint _ => False
+              | Mfloat32 => f = Float.singleoffloat f
+              | Mfloat64 => True
+              end
+| _ => match chk with
+       | Mint wz => wz = 31%nat
+       | _ => False
+       end
+end.
+
+Definition has_chunkb (v : val) (chk : AST.memory_chunk) : bool :=
+match v with
+| Vundef => true
+| Vint wz i0 => match chk with
+                | AST.Mint wz' => 
+                   eq_nat_dec wz wz' &&
+                   zle 0 (Int.unsigned wz i0) &&
+                   zlt (Int.unsigned wz i0) (Int.modulus wz)
+                | _ => false
+                end
+| Vfloat f => match chk with
+              | AST.Mint _ => false
+              | AST.Mfloat32 => 
+                  Floats.Float.eq_dec f (Floats.Float.singleoffloat f)
+              | AST.Mfloat64 => true
+              end
+| _ => match chk with
+       | AST.Mint wz => eq_nat_dec wz 31%nat
+       | _ => false
+       end
+end.
+
+Lemma load_result_determ: forall (v1 v2 : val) (m : memory_chunk) 
+  (Hchk1 : has_chunk v1 m) (Hchk2 : has_chunk v2 m)
+  (Heq : load_result m v1 = load_result m v2), v1 = v2.
+Proof.
+  intros.
+  destruct m, v1, v2; try inv Hchk1; try inv Hchk2; inv Heq; auto.
+    destruct i. destruct i0. simpl in *.
+    repeat (rewrite Zmod_small in H2; auto).
+    subst.
+    f_equal. f_equal. apply proof_irr.
+
+    simpl in *. congruence.
+Qed.
+
+Lemma has_chunk__has_typ: forall v chk
+  (Hchk: has_chunk v chk), has_type v (type_of_chunk chk).
+Proof.
+  intros.
+  destruct v, chk; simpl; auto.
+Qed.
+
+Lemma has_chunkb__has_chunk: forall v chk,
+  has_chunkb v chk = true ->
+  has_chunk v chk.
+Proof.
+  destruct v, chk; simpl; intros; try solve [auto | congruence].
+    apply andb_true_iff in H. destruct H as [H1 H2].
+    apply andb_true_iff in H1. destruct H1 as [H1 H3].
+    destruct (eq_nat_dec wz n); try inv H1. subst.
+    destruct (zle 0 (Int.unsigned n i)); try inv H3.
+    destruct (zlt (Int.unsigned n i) (Int.modulus n)); try inv H2.
+    auto.
+
+    destruct (Float.eq_dec f (Float.singleoffloat f));
+      try inv H; auto.
+
+    destruct (eq_nat_dec n 31); try inv H. auto.
+    destruct (eq_nat_dec n 31); try inv H. auto.
+Qed.
+
+Lemma cmp_has_Mint0: forall c0 v1 v2,
+  has_chunk (Val.cmp c0 v1 v2) (Mint 0).
+Proof.
+  intros.
+  match goal with
+  | |- context [cmp ?c ?v1 ?v2] => assert (J:=cmp_is_bool c v1 v2)
+  end. 
+    destruct J as [J | [ J | J ]]; rewrite J; constructor; try solve [
+      auto |
+      unfold Int.unsigned, one, zero, Int.one, Int.zero, Int.repr; simpl;
+      apply Z_mod_lt; apply Int.modulus_pos
+    ].
+Qed.
+
+Lemma cmpu_has_Mint0: forall c0 v1 v2,
+  has_chunk (cmpu c0 v1 v2) (Mint 0).
+Proof.
+  intros.
+  match goal with
+  | |- context [cmpu ?c ?v1 ?v2] => assert (J:=cmpu_is_bool c v1 v2)
+  end. 
+    destruct J as [J | [ J | J ]]; rewrite J; constructor; try solve [
+      auto |
+      unfold Int.unsigned, one, zero, Int.one, Int.zero, Int.repr; simpl;
+      apply Z_mod_lt; apply Int.modulus_pos
+    ].
+Qed.
+
+Lemma cmpf_has_Mint0: forall c0 v1 v2,
+  has_chunk (cmpf c0 v1 v2) (Mint 0).
+Proof.
+  intros.
+  match goal with
+  | |- context [cmpf ?c ?v1 ?v2] => assert (J:=cmpf_is_bool c v1 v2)
+  end. 
+    destruct J as [J | [ J | J ]]; rewrite J; constructor; try solve [
+      auto |
+      unfold Int.unsigned, one, zero, Int.one, Int.zero, Int.repr; simpl;
+      apply Z_mod_lt; apply Int.modulus_pos
+    ].
+Qed.
+
+Ltac bop_has_chunk :=
+  intros;
+  simpl_equations; simpl; try solve [
+    auto |
+    match goal with
+    | |- context [if ?e then _ else _] =>
+      destruct e; simpl; eauto
+    | |- _ => idtac
+    end;
+    split; try solve [
+      auto |
+      apply Z_mod_lt; apply Int.modulus_pos
+    ]
+  ].
+
+Lemma add_has_chunk1 : forall wz i0 wz0 i1,
+  has_chunk (add (Vint wz i0) (Vint wz0 i1)) (Mint wz).
+Proof. bop_has_chunk. Qed.
+
+Lemma add_has_chunk2 : forall wz i0 wz0 i1,
+  has_chunk (add (Vint wz i0) (Vint wz0 i1)) (Mint wz0).
+Proof. bop_has_chunk. Qed.
+
+Lemma sub_has_chunk1 : forall wz i0 wz0 i1,
+  has_chunk (sub (Vint wz i0) (Vint wz0 i1)) (Mint wz).
+Proof. bop_has_chunk. Qed.
+
+Lemma sub_has_chunk2 : forall wz i0 wz0 i1,
+  has_chunk (sub (Vint wz i0) (Vint wz0 i1)) (Mint wz0).
+Proof. bop_has_chunk. Qed.
+
+Lemma mul_has_chunk1 : forall wz i0 wz0 i1,
+  has_chunk (mul (Vint wz i0) (Vint wz0 i1)) (Mint wz).
+Proof. bop_has_chunk. Qed.
+
+Lemma mul_has_chunk2 : forall wz i0 wz0 i1,
+  has_chunk (mul (Vint wz i0) (Vint wz0 i1)) (Mint wz0).
+Proof. bop_has_chunk. Qed.
+
+Lemma divs_has_chunk1 : forall wz i0 wz0 i1,
+  has_chunk (divs (Vint wz i0) (Vint wz0 i1)) (Mint wz).
+Proof. bop_has_chunk. Qed.
+
+Lemma divs_has_chunk2 : forall wz i0 wz0 i1,
+  has_chunk (divs (Vint wz i0) (Vint wz0 i1)) (Mint wz0).
+Proof. bop_has_chunk. Qed.
+
+Lemma mods_has_chunk1 : forall wz i0 wz0 i1,
+  has_chunk (mods (Vint wz i0) (Vint wz0 i1)) (Mint wz).
+Proof. bop_has_chunk. Qed.
+
+Lemma mods_has_chunk2 : forall wz i0 wz0 i1,
+  has_chunk (mods (Vint wz i0) (Vint wz0 i1)) (Mint wz0).
+Proof. bop_has_chunk. Qed.
+
+Lemma divu_has_chunk1 : forall wz i0 wz0 i1,
+  has_chunk (divu (Vint wz i0) (Vint wz0 i1)) (Mint wz).
+Proof. bop_has_chunk. Qed.
+
+Lemma divu_has_chunk2 : forall wz i0 wz0 i1,
+  has_chunk (divu (Vint wz i0) (Vint wz0 i1)) (Mint wz0).
+Proof. bop_has_chunk. Qed.
+
+Lemma modu_has_chunk1 : forall wz i0 wz0 i1,
+  has_chunk (modu (Vint wz i0) (Vint wz0 i1)) (Mint wz).
+Proof. bop_has_chunk. Qed.
+
+Lemma modu_has_chunk2 : forall wz i0 wz0 i1,
+  has_chunk (modu (Vint wz i0) (Vint wz0 i1)) (Mint wz0).
+Proof. bop_has_chunk. Qed.
+
+Lemma and_has_chunk1 : forall wz i0 wz0 i1,
+  has_chunk (and (Vint wz i0) (Vint wz0 i1)) (Mint wz).
+Proof. bop_has_chunk. Qed.
+
+Lemma and_has_chunk2 : forall wz i0 wz0 i1,
+  has_chunk (and (Vint wz i0) (Vint wz0 i1)) (Mint wz0).
+Proof. bop_has_chunk. Qed.
+
+Lemma or_has_chunk1 : forall wz i0 wz0 i1,
+  has_chunk (or (Vint wz i0) (Vint wz0 i1)) (Mint wz).
+Proof. bop_has_chunk. Qed.
+
+Lemma or_has_chunk2 : forall wz i0 wz0 i1,
+  has_chunk (or (Vint wz i0) (Vint wz0 i1)) (Mint wz0).
+Proof. bop_has_chunk. Qed.
+
+Lemma xor_has_chunk1 : forall wz i0 wz0 i1,
+  has_chunk (xor (Vint wz i0) (Vint wz0 i1)) (Mint wz).
+Proof. bop_has_chunk. Qed.
+
+Lemma xor_has_chunk2 : forall wz i0 wz0 i1,
+  has_chunk (xor (Vint wz i0) (Vint wz0 i1)) (Mint wz0).
+Proof. bop_has_chunk. Qed.
+
+Lemma shl_has_chunk1 : forall wz i0 wz0 i1,
+  has_chunk (shl (Vint wz i0) (Vint wz0 i1)) (Mint wz).
+Proof. bop_has_chunk. Qed.
+
+Lemma shl_has_chunk2 : forall wz i0 wz0 i1,
+  has_chunk (shl (Vint wz i0) (Vint wz0 i1)) (Mint wz0).
+Proof. bop_has_chunk. Qed.
+
+Lemma shr_has_chunk1 : forall wz i0 wz0 i1,
+  has_chunk (shr (Vint wz i0) (Vint wz0 i1)) (Mint wz).
+Proof. bop_has_chunk. Qed.
+
+Lemma shr_has_chunk2 : forall wz i0 wz0 i1,
+  has_chunk (shr (Vint wz i0) (Vint wz0 i1)) (Mint wz0).
+Proof. bop_has_chunk. Qed.
+
+Lemma shr_carry_has_chunk1 : forall wz i0 wz0 i1,
+  has_chunk (shr_carry (Vint wz i0) (Vint wz0 i1)) (Mint wz).
+Proof. bop_has_chunk. Qed.
+
+Lemma shr_carry_has_chunk2 : forall wz i0 wz0 i1,
+  has_chunk (shr_carry (Vint wz i0) (Vint wz0 i1)) (Mint wz0).
+Proof. bop_has_chunk. Qed.
+
+Lemma shrx_has_chunk1 : forall wz i0 wz0 i1,
+  has_chunk (shrx (Vint wz i0) (Vint wz0 i1)) (Mint wz).
+Proof. bop_has_chunk. Qed.
+
+Lemma shrx_has_chunk2 : forall wz i0 wz0 i1,
+  has_chunk (shrx (Vint wz i0) (Vint wz0 i1)) (Mint wz0).
+Proof. bop_has_chunk. Qed.
+
+Lemma shru_has_chunk1 : forall wz i0 wz0 i1,
+  has_chunk (shru (Vint wz i0) (Vint wz0 i1)) (Mint wz).
+Proof. bop_has_chunk. Qed.
+
+Lemma shru_has_chunk2 : forall wz i0 wz0 i1,
+  has_chunk (shru (Vint wz i0) (Vint wz0 i1)) (Mint wz0).
+Proof. bop_has_chunk. Qed.
+
+Lemma ror_has_chunk1 : forall wz i0 wz0 i1,
+  has_chunk (ror (Vint wz i0) (Vint wz0 i1)) (Mint wz).
+Proof. bop_has_chunk. Qed.
+
+Lemma ror_has_chunk2 : forall wz i0 wz0 i1,
+  has_chunk (ror (Vint wz i0) (Vint wz0 i1)) (Mint wz0).
+Proof. bop_has_chunk. Qed.
+
+Lemma zero_ext'_has_chunk : forall nbits v,
+  has_chunk (zero_ext' nbits v) (Mint nbits).
+Proof.
+  destruct v; simpl; auto.
+  split; auto.
+    apply Z_mod_lt; apply Int.modulus_pos.
+Qed.
+
+Lemma sign_ext'_has_chunk : forall nbits v,
+  has_chunk (sign_ext' nbits v) (Mint nbits).
+Proof.
+  destruct v; simpl; auto.
+  split; auto.
+    apply Z_mod_lt; apply Int.modulus_pos.
+Qed.
+
 End Val.
 
 (** * Values and memory injections *)
@@ -1018,18 +2502,20 @@
 
 Inductive val_inject (mi: meminj): val -> val -> Prop :=
   | val_inject_int:
-      forall i, val_inject mi (Vint i) (Vint i)
+      forall wz i, val_inject mi (Vint wz i) (Vint wz i)
   | val_inject_float:
       forall f, val_inject mi (Vfloat f) (Vfloat f)
   | val_inject_ptr:
       forall b1 ofs1 b2 ofs2 delta,
       mi b1 = Some (b2, delta) ->
-      ofs2 = Int.add ofs1 (Int.repr delta) ->
+      ofs2 = Int.add 31 ofs1 (Int.repr 31 delta) ->
       val_inject mi (Vptr b1 ofs1) (Vptr b2 ofs2)
+  | val_inject_inttoptr:
+      forall i, val_inject mi (Vinttoptr i) (Vinttoptr i)
   | val_inject_undef: forall v,
       val_inject mi Vundef v.
 
-Hint Resolve val_inject_int val_inject_float val_inject_ptr 
+Hint Resolve val_inject_int val_inject_float val_inject_ptr val_inject_inttoptr 
              val_inject_undef.
 
 Inductive val_list_inject (mi: meminj): list val -> list val-> Prop:= 
@@ -1046,7 +2532,9 @@
   val_inject f v1 v2 ->
   val_inject f (Val.load_result chunk v1) (Val.load_result chunk v2).
 Proof.
-  intros. inv H; destruct chunk; simpl; econstructor; eauto.
+  intros. inv H; destruct chunk; simpl; try econstructor; eauto.
+    destruct (eq_nat_dec n 31); try econstructor; eauto.
+    destruct (eq_nat_dec n 31); try econstructor; eauto.
 Qed.
 
 (** Monotone evolution of a memory injection. *)
@@ -1085,3 +2573,201 @@
 
 Hint Resolve inject_incr_refl val_inject_incr val_list_inject_incr.
 
+(** More properties for Val. *)
+
+Lemma add_isnt_ptr : forall wz i0 wz0 i1 b ofs,
+  Val.add (Vint wz i0) (Vint wz0 i1) <> Vptr b ofs.
+Proof.
+  intros.
+  Val.simpl_add; try congruence.
+    unfold Val.add_obligation_1. 
+    unfold DepElim.solution_left.
+    unfold eq_rect_r. simpl. congruence.
+Qed.
+
+Lemma sub_isnt_ptr : forall wz i0 wz0 i1 b ofs,
+  Val.sub (Vint wz i0) (Vint wz0 i1) <> Vptr b ofs.
+Proof.
+  intros.
+  Val.simpl_sub; try congruence.
+    unfold Val.sub_obligation_1. 
+    unfold DepElim.solution_left.
+    unfold eq_rect_r. simpl. congruence.
+Qed.
+
+Lemma mul_isnt_ptr : forall wz i0 wz0 i1 b ofs,
+  Val.mul (Vint wz i0) (Vint wz0 i1) <> Vptr b ofs.
+Proof.
+  intros.
+  Val.simpl_mul; try congruence.
+    unfold Val.mul_obligation_1. 
+    unfold DepElim.solution_left.
+    unfold eq_rect_r. simpl. congruence.
+Qed.
+
+Lemma divu_isnt_ptr : forall wz i0 wz0 i1 b ofs,
+  Val.divu (Vint wz i0) (Vint wz0 i1) <> Vptr b ofs.
+Proof.
+  intros.
+  Val.simpl_divu; try congruence.
+    unfold Val.divu_obligation_1. 
+    unfold DepElim.solution_left.
+    unfold eq_rect_r. simpl. 
+    destruct (Int.eq wz0 i1 (Int.zero wz0)); congruence.
+Qed.
+
+Lemma divs_isnt_ptr : forall wz i0 wz0 i1 b ofs,
+  Val.divs (Vint wz i0) (Vint wz0 i1) <> Vptr b ofs.
+Proof.
+  intros.
+  Val.simpl_divs; try congruence.
+    unfold Val.divs_obligation_1. 
+    unfold DepElim.solution_left.
+    unfold eq_rect_r. simpl. 
+    destruct (Int.eq wz0 i1 (Int.zero wz0)); congruence.
+Qed.
+
+Lemma modu_isnt_ptr : forall wz i0 wz0 i1 b ofs,
+  Val.modu (Vint wz i0) (Vint wz0 i1) <> Vptr b ofs.
+Proof.
+  intros.
+  Val.simpl_modu; try congruence.
+    unfold Val.modu_obligation_1. 
+    unfold DepElim.solution_left.
+    unfold eq_rect_r. simpl. 
+    destruct (Int.eq wz0 i1 (Int.zero wz0)); congruence.
+Qed.
+
+Lemma mods_isnt_ptr : forall wz i0 wz0 i1 b ofs,
+  Val.mods (Vint wz i0) (Vint wz0 i1) <> Vptr b ofs.
+Proof.
+  intros.
+  Val.simpl_mods; try congruence.
+    unfold Val.mods_obligation_1. 
+    unfold DepElim.solution_left.
+    unfold eq_rect_r. simpl. 
+    destruct (Int.eq wz0 i1 (Int.zero wz0)); congruence.
+Qed.
+
+Lemma shl_isnt_ptr : forall wz i0 wz0 i1 b ofs,
+  Val.shl (Vint wz i0) (Vint wz0 i1) <> Vptr b ofs.
+Proof.
+  intros.
+  Val.simpl_shl; try congruence.
+    unfold Val.shl_obligation_1. 
+    unfold DepElim.solution_left.
+    unfold eq_rect_r. simpl. 
+    destruct (Int.ltu wz0 i1 (Int.iwordsize wz0)); congruence.
+Qed.
+
+Lemma shrx_isnt_ptr : forall wz i0 wz0 i1 b ofs,
+  Val.shrx (Vint wz i0) (Vint wz0 i1) <> Vptr b ofs.
+Proof.
+  intros.
+  Val.simpl_shrx; try congruence.
+    unfold Val.shrx_obligation_1. 
+    unfold DepElim.solution_left.
+    unfold eq_rect_r. simpl. 
+    destruct (Int.ltu wz0 i1 (Int.iwordsize wz0)); congruence.
+Qed.
+
+Lemma shr_isnt_ptr : forall wz i0 wz0 i1 b ofs,
+  Val.shr (Vint wz i0) (Vint wz0 i1) <> Vptr b ofs.
+Proof.
+  intros.
+  Val.simpl_shr; try congruence.
+    unfold Val.shr_obligation_1. 
+    unfold DepElim.solution_left.
+    unfold eq_rect_r. simpl. 
+    destruct (Int.ltu wz0 i1 (Int.iwordsize wz0)); congruence.
+Qed.
+
+Lemma and_isnt_ptr : forall wz i0 wz0 i1 b ofs,
+  Val.and (Vint wz i0) (Vint wz0 i1) <> Vptr b ofs.
+Proof.
+  intros.
+  Val.simpl_and; try congruence.
+    unfold Val.and_obligation_1. 
+    unfold DepElim.solution_left.
+    unfold eq_rect_r. simpl. 
+    congruence.
+Qed.
+
+Lemma or_isnt_ptr : forall wz i0 wz0 i1 b ofs,
+  Val.or (Vint wz i0) (Vint wz0 i1) <> Vptr b ofs.
+Proof.
+  intros.
+  Val.simpl_or; try congruence.
+    unfold Val.or_obligation_1. 
+    unfold DepElim.solution_left.
+    unfold eq_rect_r. simpl. 
+    congruence.
+Qed.
+
+Lemma xor_isnt_ptr : forall wz i0 wz0 i1 b ofs,
+  Val.xor (Vint wz i0) (Vint wz0 i1) <> Vptr b ofs.
+Proof.
+  intros.
+  Val.simpl_xor; try congruence.
+    unfold Val.xor_obligation_1. 
+    unfold DepElim.solution_left.
+    unfold eq_rect_r. simpl. 
+    congruence.
+Qed.
+
+Lemma cmp_isnt_ptr : forall c wz i0 wz0 i1 b ofs,
+  Val.cmp c (Vint wz i0) (Vint wz0 i1) <> Vptr b ofs.
+Proof.
+  intros.
+  Val.simpl_cmp; try congruence.
+    unfold Val.cmp_obligation_1. 
+    unfold DepElim.solution_left.
+    unfold eq_rect_r. simpl. 
+    unfold Val.of_bool.
+    destruct (Int.cmp wz0 c i0 i1).
+      unfold Vtrue. unfold Vone. congruence.
+      unfold Vfalse. unfold Vzero. congruence.
+Qed.
+
+Lemma cmpu_isnt_ptr : forall c wz i0 wz0 i1 b ofs,
+  Val.cmpu c (Vint wz i0) (Vint wz0 i1) <> Vptr b ofs.
+Proof.
+  intros.
+  Val.simpl_cmpu; try congruence.
+    unfold Val.cmpu_obligation_1. 
+    unfold DepElim.solution_left.
+    unfold eq_rect_r. simpl. 
+    unfold Val.of_bool.
+    destruct (Int.cmpu wz0 c i0 i1).
+      unfold Vtrue. unfold Vone. congruence.
+      unfold Vfalse. unfold Vzero. congruence.
+Qed.
+
+Lemma val_of_bool_isnt_ptr : forall v b ofs,
+  Val.of_bool v <> Vptr b ofs.
+Proof.
+  intros. unfold Val.of_bool. destruct v. 
+    unfold Vtrue. unfold Vone. congruence.
+    unfold Vfalse. unfold Vzero. congruence.
+Qed.
+
+Lemma Vfalse_isnt_ptr : forall b ofs,
+  Vfalse <> Vptr b ofs.
+Proof.
+  intros. unfold Vfalse. unfold Vzero. congruence.
+Qed.
+
+Lemma Vtrue_isnt_ptr : forall b ofs,
+  Vtrue <> Vptr b ofs.
+Proof.
+  intros. unfold Vtrue. unfold Vone. congruence.
+Qed.
+
+Lemma val_list_inject_app : forall mi vs1 vs1' vs2 vs2',
+  val_list_inject mi vs1 vs2 ->
+  val_list_inject mi vs1' vs2' ->
+  val_list_inject mi (vs1++vs1') (vs2++vs2').
+Proof.
+  induction vs1; destruct vs2; simpl; intros; inv H; auto.
+Qed.
+
