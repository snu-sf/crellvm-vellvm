===========================================================================
                        GENERAL DESCRIPTION
===========================================================================

This is the formal specification of LLVM IR (syntax, operational semantics, and 
well-formedness).

    * Formalism: http://www.cis.upenn.edu/~jianzhou/vol/release.tgz
    * Modified LLVM2.6: http://www.cis.upenn.edu/~jianzhou/vol/llvm-2.6z.tgz

===========================================================================
                              CONTENTS
===========================================================================

VOL = $(WHERE_RELEASE_IS)/vol

theory/metatheory_8.3 : Metatheory libraries http://www.plclub.org/metalib

vol/doc : documentations that must be out of date...

vol/examples/HowToCallOCamlFromLLVM/llvm-2.6 : 
  the modified llvm2.6 source code:
  * Calling the OCaml Passes extracted from verified transformations: 
        lib/OCamlPass/ConstantPropTV
  * Other simple OCaml passes : lib/OCamlPass/*
  * Extended OCaml bindings to translate LLVM ASTs into Coq ASTs 
  * More OCaml bindings for LLVM Execution Engines, which can be used by 
    the extracted interpreter: arbitrary precision integer/floats, memory
    operations...

vol/examples/HowToCallOCamlFromLLVM/llvm-2.6.patch : a patch of llvm2.6 (out-of-date)

vol/examples/HowToCallOCamlFromLLVM/llvm-2.6-ocamlbindings.patch : 
  a patch of only llvm2.6 OCaml bindings, but out-of-date

vol/examples/CoCaml : How to mix C and OCaml

vol/examples/CoqExtraction : Coq extraction

vol/examples/LLgen : Generating LLVM IR from OCaml

vol/examples/LLVMOCamlBindingsTutorial : How to use LLVM OCaml bindings

vol/examples/OCamlPass : How to call an OCaml pass from LLVM

vol/examples/SimpleOpt : How to define optimizations via OCaml bindings.

vol/extralibs : Coq plug-ins -- Float and Equations

vol/src/ssa/compcert : The modified Compcert Memory Model (1.8)
  http://compcert.inria.fr/release/compcert-1.8.tgz 
  which supports int with parameterized bitwidth.

vol/src/ssa/ott : The modified coq libraries from Ott installation,
  which define properties of lists generated by Ott, but fixed some bugs.

vol/src/ssa/monads : Monads operations for 'imperative' programming

vol/src/ssa        : The Formalisms of LLVM IR

  ssa_def.ott       : The definitions of LLVM IR in Ott

  ssa_coq_lib.v     : Operations over LLVM IR, such as, returning types and
                      operands of an instruction, classifying instructions, 
                      traversing functions, checking if an instruction dominates
                      others, building explicit CFGs, ...

  ssa_props.v       : Properties of LLVM IR, such as, decidability of equivalence
                      over types, instructions, and other components, uniqueness 
                      of IDs, inclusion between functions and modules, ...
                      
  assoclist.v       : A map from IDs to data, which is used to represent locals and
                      globals.

  targetdata.v	    : Calculating bitsize, alignment, padding information in term 
                      of user-defined data layout in IR.

  genericvalues.v   : Representations of run-time values used in the operational 
                      semantics

  ssa_mem.v         : The LLVM memory model, which is actually a wrapper of the 
                      CompCert memory model, with conversion between LLVM datatypes
                      and datatypes that CompCert memory model can handle.

  trace.v           : I/O events that track observable behaviors of an execution

  ssa_dynamic.v     : Four styles of operations semantics ---
                        big-step/small-step deterministic/non-deterministic

  tactics.v         : Tacticals 

  opsem_conv.v      : Equivalence between big-step and small-step semantics

  opsem_pp.v        : Operational semantics preserve uniqueness and inclusion properties

  ssa_interpreter.v : An interpreter that is consistent with operational semantics 

  ssa_extract.v     : Extracting an OCaml interpreter into 
                        vol/src/Interpreter

  ssa_static.ott    : A verifier that checks if an LLVM IR is well-formed

vol/src/ssa/llvm_op : Obsolete

vol/src/Interpreter : Extracted interpreter
  llvm_aux.ml/llvm_pretty_printer.ml : printing llvm AST
  coq_pretty_printer.ml  : printing Coq AST
  coq2llvm.ml            : Translating Coq AST to LLVM AST
  llvm2coq.ml            : Translating LLVM AST to Coq AST
  llvmcaml.ml/Camlcoq.ml : Realizing performance-sensitive operations into C++ definitions,
                           for example, memory operations, int/float operations
  ssa_main.ml            : The main entry that reads in an LLVM IR, converts it into 
                           the Coq representation, and interpretes it.
  testcases              : Simple testcases

vol/src/Interpreter/testcases: Simple test cases of this interpreter, run 'make'
  

vol/src/TV/         : A simple trivial translation validator, which only checks equivalence
                      between corresponding blocks of an input program and the transformed
                      program. The optimization under validation cannot change CFGs.
  symexe_def.v      : Defining symbolic values and states of LLVM IR, and an operational 
                      semantics that simplifies the proofs about this TV.
  seop_llvmop.v     : Proved that this special operational semantics is equivalent to 
                      the ones defined in vol/src/ssa/ssa_dynamic.v
  symexe_dec.v      : Decidability of equations over symbolic values and states
  symexe_sound.v/symexe_complete.v  : Symbolic states are sound/complete wrt concrete states
  symexe_correct.v  : If the TV returns true, the two programs are indeed equivalent.
  symexe_extract.v  : Extracting an OCaml TV into 
                        vol/src/ssa/extraction

vol/src/Parser/     : The main entry of the TV, which reads the original and transformed IRs,
                      converts them into the Coq ASTs, and validates them.

vol/src/BigSmallStep : Reproved generic relations between the bigstep and the smallstep in CompCert,
                       which is not used in this project

vol/scripts : Obsolete

vol/tests : Potential test cases for a verified Softbound
                        http://www.cis.upenn.edu/acg/softbound/


===========================================================================
                              DEPENDENCIES
===========================================================================

* OCaml 3.12.0
  http://caml.inria.fr/pub/distrib/ocaml-3.12/ocaml-3.12.0.tar.gz

* Coq 8.3pl1

* Two plug-ins of Coq 8.3 to install
  1) Float  $(VOL)/extralibs/Float8.2-1.2r.tgz  
     A modified version from (https://lipforge.ens-lyon.fr/projects/pff/) to 
     compile in 8.3
  2) Equations $(VOL)/extralibs/mattam82-Coq-Equations-e52679e.tgz
     Same to https://github.com/mattam82/Coq-Equations/tree/8.3

* Ott, which generates Coq definitions from *.ott in $(VOL)/src/ssa
  * Download http://www.cl.cam.ac.uk/~pes20/ott/ott_distro_0.20.1.tar.gz
  * Install following its instructions
  * Add Ott to PATH

* Metalib, $WHERE_RELEASE_IS$/theory/metatheory_8.3

* libffi
  http://sourceware.org/libffi/
  The extracted interpreter needs libffi to call external functions.
  This is optional if you don't call the extracted interpreter with external
  fuctions.

  If you install libffi after installing LLVM, you need re-configure and 
  recompile the LLVM.
 
* The modified LLVM 2.6 
    * Download the http://www.cis.upenn.edu/~jianzhou/vol/llvm-2.6z.tgz
    * tar zfxv llvm-2.6z.tgz
    * mkdir llvm-2.6z-obj
    * mkdir $WHERE_TO_INSTALL
    * cd llvm-2.6z-obj
    * ../llvm-2.6z/configure --prefix=$WHERE_TO_INSTALL

    The llvm-2.6z-obj/lib/OCamlPass depends on the LLVM IR formalism, while the LLVM IR Coq
    code also depends on the modified llvm-2.6. To break the circularity, when
    building llvm before compiling, we can set 
      DIRS = 
    in llvm-2.6z-obj/lib/OCamlPass/Makefile at this point. 

    * make ENABLE_OPTIMIZED=0    // this is to build a debugging version of
                                 // llvm, in case the modification is buggy...
                                 // 'make' or 'make ENABLE_OPTIMIZED=1' will
                                 // build a release version
    * make ENABLE_OPTIMIZED=0 install

* OcaIDE (Optional)
  http://www.algo-prog.info/ocaide/
  It could be used as a GUI for OCaml extractions.

* LNgen (Optional)
  www.cis.upenn.edu/~baydemir/papers/lngen
  It is used in $(VOL)/src/BigSmallStep, but LNgen only works with Ott (<=0.17).
  If using Ott 0.17, we need to removed '-i' and '-o' options for Ott in
  the corresponding Makefiles.

===========================================================================
                              COMPILING
===========================================================================

First, in $(VOL)/src/Makefile.config, set the following variables:

OTT = ott
COQC = coqc
COQDEP = coqdep
COQDOC = coqdoc
LNGEN = lngen # optional

RELEASE = $(WHERE_RELEASE_IS)
METALIB = $(RELEASE)/theory/metatheory_8.3
LLVM_LIB = $(WHERE_LLVM_IS)/lib/
LLVM_OCAML_LIB = $(LLVM_LIB)/ocaml/
TV_LIB = $(RELEASE)/vol/src/TV/extraction/_build/

Then, in $(VOL)/src

  make

After compiling Coq code, 
* in llvm-2.6z-obj/lib/OCamlPass/Makefile, reset
  DIRS = CoCaml Nihao Hola ConstantPropVC ConstantPropTV
* in llvm-2.6z-obj/lib/OCamlPass/CoCaml/Makefile set
  SSALIB:=$(VOL)/src/ssa/
  METALIB:=$(WHERE_RELEASE_IS)/theory/metatheory_8.3/
* in llvm-2.6z-obj/lib/OCamlPass
  make ENABLE_OPTIMIZED=0 clean
  make ENABLE_OPTIMIZED=0 
  make ENABLE_OPTIMIZED=0 install


===========================================================================
                              LLVM TestSuite
===========================================================================

To evaluate the extracted interpreter,
* INSTALL LLVM GCC Frontend at $(WHERE_LLVMGCC_IS)
  http://www.llvm.org/releases/2.6/llvm-gcc-4.2-2.6.source.tar.gz

* Download the llvm testsuite (which should already included in
    http://www.cis.upenn.edu/~jianzhou/vol/llvm-2.6z.tgz)
  cd $(WHERE_LLVM_SRC_IS)/projects
  Download http://www.llvm.org/releases/2.6/llvm-test-2.6.tar.gz
  tar xfzv llvm-test-2.6.tar.gz
  mv llvm-test-2.6 testsuite
  cd $(WHERE_LLVM_OBJ_IS)/projects/testsuite
  $(WHERE_LLVM_SRC_IS)/projects/testsuite/configure --prefix=$(WHERE_TO_INSTALL) --with-llvmgccdir=$(WHERE_LLVMGCC_IS)  
  cp $(VOL)/example/HowToCallOCamlFromLLVM/llvm-2.6/project/testsuite/Makefile.programs .
  cp $(VOL)/example/HowToCallOCamlFromLLVM/llvm-2.6/project/testsuite/Makefile.rules .
  cp $(VOL)/example/HowToCallOCamlFromLLVM/llvm-2.6/project/testsuite/TEST.lynx.* .
  make TEST=lynx report report.html

  Most testcases in SingleSource are passed.
  However, only a few of the test cases in MultiSource can be passed.

===========================================================================
                              NOTE
===========================================================================

If OcaIDE is installed, at $(VOL), you can open a eclipse project : src.
   Setting: Property -> project
    -libs: llvm,llvm_analysis,llvm_executionengine,llvm_target,llvm_bitreader,llvm_bitwriter,llvm_scalar_opts
    -cflags: -I /home/jianzhou/Tools/llvm-2.6/lib/ocaml/
    -lflags: -cc g++ -I,/home/jianzhou/Tools/llvm-2.6/lib/ocaml/,-cclib,-lffi,-cclib,-L/home/jianzhou/Tools/llvm-2.6/lib/
    others: -Is Extraction,Parser

If the patch of llvm2.6 is available, we can also patch LLVM as the following:
(But, usually the patch is out-of-date...)
    * Download http://www.llvm.org/releases/2.6/llvm-2.6.tar.gz
    * tar zfxv llvm-2.6.tar.gz
    * patch -p0 -i $(VOL)/examples/HowToCallOCamlFromLLVM/llvm-2.6.patch
    * mkdir llvm-2.6-obj
    * mkdir $WHERE_TO_INSTALL
    * cd llvm-2.6-obj
    * ../llvm-2.6/configure --prefix=$WHERE_TO_INSTALL

    The llvm-2.6z-obj/lib/OCamlPass depends on the LLVM IR formalism, while the LLVM IR Coq
    code also depends on the modified llvm-2.6. To break the circularity, when
    building llvm before compiling, we can set 
      DIRS = 
    in llvm-2.6z-obj/lib/OCamlPass/Makefile at this point. 

    * make ENABLE_OPTIMIZED=0    
    * make ENABLE_OPTIMIZED=0 install

    NOTE: the patch was generated by
      diff -crBN ./llvm-2.6 ./llvm-2.6patch > llvm-2.6.patch
      where llvm-2.6patch is the updated src wrt the original code ./llvm-2.6/

