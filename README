===========================================================================
                        GENERAL DESCRIPTION
===========================================================================

This is the formalized LLVM IR.

    * Formalism (the Coq code): 
        http://www.cis.upenn.edu/~jianzhou/Vellvm/release.tgz
    * LLVM 2.6 with extended OCaml-LLVM bindings: 
        http://www.cis.upenn.edu/~jianzhou/Vellvm/llvm-2.6z.tgz

===========================================================================
                              CONTENTS
===========================================================================

decompress release.tgz to $(WHERE_RELEASE_IS)

VOL = $(WHERE_RELEASE_IS)/vol

in $(WHERE_RELEASE_IS)

theory/metatheory_8.3 : 
  The Penn Metatheory library, which can also be downloaded from
  * http://www.cis.upenn.edu/~jianzhou/Vellvm/metatheory.tgz

vol/extralibs : Coq plug-ins -- Float and Equations

vol/src/Vellvm/compcert : The modified Compcert Memory Model (1.8)
  http://compcert.inria.fr/release/compcert-1.8.tgz 

vol/src/Vellvm/ott : The modified coq libraries from Ott installation,
  which define properties of lists generated by Ott, but fixed some bugs.

vol/src/Vellvm/monads : Monads operations for 'imperative' programming

vol/src/Vellvm/GraphBasics : Graph theory libraries from
  http://coq.inria.fr/pylons/contribs/view/GraphBasics/v8.3

vol/src/Vellvm        : The Formalisms of LLVM IR

  syntax.ott       : The definitions of LLVM IR in Ott

  infrastructure.v : Operations over LLVM IR, such as, returning types and
                      operands of an instruction, classifying instructions, 
                      traversing functions, checking if an instruction dominates
                      others, building explicit CFGs, ...

  infrastructure_props.v : Properties of LLVM IR, such as, decidability of 
        	     equivalence over types, instructions, and other components,
                     uniqueness of IDs, inclusion between functions and modules,
                     ...
                      
  targetdata.v	    : Calculating bitsize, alignment, padding information in 
                      term of user-defined data layout in IR.

  genericvalues.v   : Representations of run-time values used in the operational
                      semantics, and the LLVM memory model, which is actually a 
                      wrapper of the CompCert memory model, with conversion 
                      between LLVM datatypes and datatypes that CompCert memory 
                      model can handle.

  analysis          : Domination/reachability analysis

  typings.ott       : LLVM IR typings

  opsem.v           : A generic semantics (small-step/big-step) that can be 
                      instantiated as either a deterministic version or a non-
                      deterministic version.

  dopsem.v          : A deterministic instance of Opsem.

  opsem_inst.v      : deterministic instances are included by non-deterministic 
                      instances.

  tactics.v         : Tacticals 

  opsem_props/wf.v  : Progress and preservation of operational semantics

  interpreter.v     : An interpreter that is consistent with small-step 
                      deterministic operational semantics.

vol/src/Interpreter : Extracted interpreter
  main.ml           : The main entry that reads in an LLVM IR, converts it into 
                      the Coq representation, and interpretes it.
  testcases         : Simple testcases

vol/src/Interpreter/testcases: Simple test cases of this interpreter, run 'make'
  
vol/src/SoftBound   : A verified Softbound pass.

  sb_def/pp*.v      : SBspec and its correctness
  sb_ns_ds.v        : det SBspec is an instance of nondet SBspec
  sb_ds_trans.v     : a SoftBound instrumentation pass and its correctness
  sb_ds_trans_correct.v 
                    : Correctness of the SoftBound instrumentation pass w.r.t 
                      a deterministic instance of SBspec.

vol/src/TV/         : A simple trivial translation validator (eq_tv*), which only
                      checks equivalence between corresponding blocks of an input 
                      program and the transformed program. The optimization under 
                      validation cannot change CFGs.

  symexe_def.v      : Defining symbolic values and states of LLVM IR, and a sub-
                      blocked oriented operational semantics that simplifies the
                      proofs about this TV.

  seop_llvmop.v     : Proved that this special operational semantics is equivalent to 
                      the ones defined in vol/src/Vellvm/opsem.v

  symexe_dec.v      : Decidability of equations over symbolic values and states

  symexe_sound.v/symexe_complete.v  : Symbolic states are sound/complete wrt 
                                      concrete states

  eq_tv_correct.v  : If the TV returns true, the two programs are indeed equivalent.

vol/src/Vminus      : A subset of Vellvm for studying SSA-based optimizations.
  subst.v            : Constant substitution
  vsubst.v           : Variable substitution
  renaming.v         : Renaming variables
  insert.v           : Inserting fresh instructions
  removal.v          : Deleting instructions
  motion.v           : Code motion
  vminus.v           : Including all the above libraries

  The following are simplified code from vol/src/Vellvm for the subset of Vellvm.
  analysis.v  opsem.v  infrastructure_props.v  interpreter.v opsem_props.v 
  opsem_wf.v typings.v genericvalues.v infrastructure_aux.v  infrastructure.v  
  typings_props.v 

vol/src/Transforms   : Optimizations for Vellvm
  dtree.v                 : Dominator trees crearion
  primitives.v            : The primitives same to vol/src/Vminus
  gvn.v                   : Global value numbering
  mem2reg.v               : Mem2reg
  promotable_props.v      : Promotatable allocation is not aliasing
  phiplacement_correct.v  : phinode-placement is correct

vol/src/Extraction  :
  extraction_core.v           : Extracting an OCaml interpreter
  extraction_sb.v                    : Extracting an OCaml SoftBound
  extraction_trans.v                 : Extracting an OCaml Vellvm Optimizor
  llvm_aux.ml/llvm_pretty_printer.ml : printing LLVM AST
  coq_pretty_printer.ml              : printing Coq AST
  coq2llvm.ml                        : Translating Coq AST to LLVM AST
  llvm2coq.ml                        : Translating LLVM AST to Coq AST
  llvmcaml.ml/Camlcoq.ml             : Realizing performance-sensitive operations
      into C++ definitions, for example, memory operations, int/float operations

===========================================================================
                              DEPENDENCIES
===========================================================================

* OCaml 3.12.0
  http://caml.inria.fr/pub/distrib/ocaml-3.12/ocaml-3.12.0.tar.gz

* Coq 8.3pl1

* Two plug-ins of Coq 8.3 to install
  1) Float  $(VOL)/extralibs/Float8.2-1.2r.tgz  
     A modified version from (https://lipforge.ens-lyon.fr/projects/pff/) to 
     compile in 8.3
  2) Equations $(VOL)/extralibs/mattam82-Coq-Equations-e52679e.tgz
     Same to https://github.com/mattam82/Coq-Equations/tree/8.3

* Ott, which generates Coq definitions from *.ott in $(VOL)/src/Vellvm
  * Download http://www.cl.cam.ac.uk/~pes20/ott/ott_distro_0.20.1.tar.gz
  * Install following its instructions
  * Add Ott to PATH

* The Penn Metatheory library: 
  * $WHERE_RELEASE_IS$/theory/metatheory_8.3
  * or download from http://www.cis.upenn.edu/~jianzhou/Vellvm/metatheory.tgz

* libffi
  http://sourceware.org/libffi/
  The extracted interpreter needs libffi to call external functions.
  This is optional if you don't call the extracted interpreter with external
  fuctions.

  If you install libffi after installing LLVM, you need re-configure and 
  recompile the LLVM. 
 
* The modified LLVM 2.6 
    * Download the http://www.cis.upenn.edu/~jianzhou/Vellvm/llvm-2.6z.tgz
    * tar zfxv llvm-2.6z.tgz
    * mkdir llvm-2.6z-obj
    * mkdir $WHERE_TO_INSTALL
    * cd llvm-2.6z-obj
    * ../llvm-2.6z/configure --prefix=$WHERE_TO_INSTALL --enable-libffi
    * make ENABLE_OPTIMIZED=0    // this is to build a debugging version of
                                 // llvm, in case the modification is buggy...
                                 // 'make' or 'make ENABLE_OPTIMIZED=1' will
                                 // build a release version
    * make ENABLE_OPTIMIZED=0 install

* OcaIDE (Optional)
  http://www.algo-prog.info/ocaide/
  It could be used as a GUI for OCaml extractions.

* LNgen (Optional)
  www.cis.upenn.edu/~baydemir/papers/lngen
  It is used in $(VOL)/src/BigSmallStep, but LNgen only works with Ott (<=0.17).
  If using Ott 0.17, we need to removed '-i' and '-o' options for Ott in
  the corresponding Makefiles.

===========================================================================
                              COMPILING
===========================================================================

First, in $(VOL)/src/Makefile.config, set the following variables:

OTT = ott
COQC = coqc
COQDEP = coqdep
COQDOC = coqdoc
LNGEN = lngen # optional

RELEASE = $(WHERE_RELEASE_IS)
METALIB = $(RELEASE)/theory/metatheory_8.3
LLVM_LIB = $(WHERE_LLVM_IS)/lib/
LLVM_OCAML_LIB = $(LLVM_LIB)/ocaml/
EXTRACTION_LIB = $(RELEASE)/vol/src/TV/extraction/_build/

Then, in $(VOL)/src

  make

===========================================================================
                              LLVM TestSuite
===========================================================================

To evaluate the extracted interpreter,
* INSTALL LLVM GCC Frontend at $(WHERE_LLVMGCC_IS)
  http://www.llvm.org/releases/2.6/llvm-gcc-4.2-2.6.source.tar.gz

* Download the llvm testsuite (which should already included in
    http://www.cis.upenn.edu/~jianzhou/Vellvm/llvm-2.6z.tgz)
  cd $(WHERE_LLVM_SRC_IS)/projects
  Download http://www.llvm.org/releases/2.6/llvm-test-2.6.tar.gz
  tar xfzv llvm-test-2.6.tar.gz
  mv llvm-test-2.6 testsuite
  cd $(WHERE_LLVM_OBJ_IS)/projects/testsuite
  $(WHERE_LLVM_SRC_IS)/projects/testsuite/configure --prefix=$(WHERE_TO_INSTALL) --with-llvmgccdir=$(WHERE_LLVMGCC_IS)  
  cp $(VOL)/example/HowToCallOCamlFromLLVM/llvm-2.6/project/testsuite/Makefile.programs .
  cp $(VOL)/example/HowToCallOCamlFromLLVM/llvm-2.6/project/testsuite/Makefile.rules .
  cp $(VOL)/example/HowToCallOCamlFromLLVM/llvm-2.6/project/testsuite/TEST.lynx.* .
  make TEST=lynx report report.html

  Most testcases in SingleSource are passed.
  However, only a few of the test cases in MultiSource can be passed.

===========================================================================
                              NOTE
===========================================================================

If OcaIDE is installed, at $(VOL)/src, you can open three eclipse projects : 
Parser, SoftBound, and Transforms.
   Setting: Property -> project
    -libs: llvm,llvm_analysis,llvm_executionengine,llvm_target,llvm_bitreader,llvm_bitwriter,llvm_scalar_opts,sub_tv,coq2llvm,coq_pretty_printer,eq_tv
    -cflags: -I /home/jianzhou/Tools/llvm-2.6/lib/ocaml/ -I /home/jianzhou/SVN/sol/vol/src/_build/Extraction/
    -lflags: -cc g++ -I,/home/jianzhou/Tools/llvm-2.6/lib/ocaml/,-I,/home/jianzhou/SVN/sol/vol/src/_build/Extraction/,-cclib,-lffi,-cclib,-L/home/jianzhou/Tools/llvm-2.6/lib/

