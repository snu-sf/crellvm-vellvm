------------------------------------------------------------------------
r3001 | jianzhou | 2011-06-24 13:54:34 -0400 (Fri, 24 Jun 2011) | 68 lines

simplified the SBpass design
  1) at the beginning of a function, always allocates two slots for loading 
metadata of pointers from memory, so we do not need to prove that it is
safe to ignore them when there are no pointer-loading in the function.
  2) We had a problem about proving malloc does not change constant
values. The case is like this
   suppose the original code is 
     %1 = malloc typ, i32 const ;; here const is the size to allocate,
   if the instrumentation is 
     %1 = malloc typ, i32 const
     %base = %1
     %bound gep %1, i32 const
   we need to argument that the value represented by const is the 'same'
before and after this malloc, which is obvious, but needs some work.
   Currently, we transformed it by
     %tmp = bitcast i32 cosnt to i32
     %1 = malloc typ, i32 %tmp
     %base = %1
     %bound gep %1, i32 %tmp
   Now the result is trivial, since registered values are unchanged for
sure.
  3) decomposed the dependency with sb_db_trans.v, which will be removed
when sb_ds_trans is proved.
  4) The requirememt of shadow-stack:

caller pushes normal base/bound for ptr parameters, but, rather than
skipping nptr parameters, also pushes null/null for them.
 for example, if a caller thinks a call has signature
     i8 %1 = foo (i8* a) (i8 b) (i8* c)
 it does
     allocate_ss (1 + 3) // 1 for ret, 3 for parameters
     set_ss_basebound a_metadata 1
     set_ss_basebound null 2
     set_ss_basebound c_metadata 3
     call foo...
     deallocate_ss

If the allocate_ss always zero-outs allocated shadow-stack, caller does
not need to push null/null additionally.

callee pops ptr argument's metadata w.r.t its index (the index of the
whole arg lists, not only args with ptr typs)
 e.g. if a call has signature
      %1 foo (i8 a) (i8* b) (i8* c) { .. }
 it does, at its beginning
     b_metadata = get_ss_basebound 2
     c_metadata = get_ss_basebound 3

 If callee wants to pop more than caller pushs, it returns null/null
 the default metadata for return is null/null in the case caller sets
nothing to its return.

To make the wrapper just work (for the program with matched function types), 
We simply changed in softbound.c @ main to be

__softboundcetswithss_allocate_shadow_stack_space(3);   // from 2 to 3
__softboundcetswithss_store_base_shadow_stack(NULL, 1); // added
__softboundcetswithss_store_bound_shadow_stack(NULL, 1); // added
__softboundcetswithss_store_base_shadow_stack(&new_argv[0], 2); // 1 to 2
__softboundcetswithss_store_bound_shadow_stack(temp_ptr, 2); // 1 to 2
return_value = softbound_pseudo_main(argc, new_argv);
__softboundcetswithss_deallocate_shadow_stack_space();

All existing wrappers only have ptr args as its first argument, so we do not 
need to change them. But if not so, we need to ensure indices are
matched.


------------------------------------------------------------------------
r2998 | jianzhou | 2011-06-24 01:32:28 -0400 (Fri, 24 Jun 2011) | 13 lines

finished the first stage of the SoftBound proofs
 1) SB semantics back-simulates LLVM opsem if it does not abort
 2) SB opsem is not stuck because of spatial memory violation, although
it can still be stuck by temporal violation or alignment failtures

The version and the last checkin added some new well-formedness rules :
  all types are well-formed --- can be allocated, and well-alignmented;
  plus, recursive types are not cyclic.

The proofs assume 1) external calls are spatial memory safe, 2)
extractValue and insertValue do nothing about pointers.


------------------------------------------------------------------------
r2997 | jianzhou | 2011-06-23 21:25:39 -0400 (Thu, 23 Jun 2011) | 3 lines

checkpoint for updating typing rules.


------------------------------------------------------------------------
r2995 | jianzhou | 2011-06-22 21:22:08 -0400 (Wed, 22 Jun 2011) | 4 lines

Checkpoint of SoftBound p&p w.r.t memory safety.
We need to change some typing rules.


------------------------------------------------------------------------
r2993 | jianzhou | 2011-06-22 01:38:39 -0400 (Wed, 22 Jun 2011) | 3 lines

fixed the broken lemma in the last check-in


------------------------------------------------------------------------
r2992 | jianzhou | 2011-06-22 01:26:51 -0400 (Wed, 22 Jun 2011) | 5 lines

1) proved SB spec's preservation and progress w/o considering memory
violation aborts.
2) fixed the issue of generating metadata for bitcast @global to ptr*


------------------------------------------------------------------------
r2990 | jianzhou | 2011-06-20 15:09:08 -0400 (Mon, 20 Jun 2011) | 4 lines

added the small-step SoftBound spec, and proved that it back-simulates
llvm dsop if it does not abort via memort safety violation.


------------------------------------------------------------------------
r2989 | jianzhou | 2011-06-20 02:14:21 -0400 (Mon, 20 Jun 2011) | 4 lines

1) fixed a bug of llvmop, params2GV should be partial
2) split eq_tv and sub_tv, so removed the unprovable lemmas from sub_tv.


------------------------------------------------------------------------
r2984 | jianzhou | 2011-06-19 19:19:19 -0400 (Sun, 19 Jun 2011) | 5 lines

finished progress & preservation of the standard LLVM semantics.
There is still one admitted lemma in src/ssa, which needs the proof
irrelevance axiom.


------------------------------------------------------------------------
r2978 | jianzhou | 2011-06-18 20:02:31 -0400 (Sat, 18 Jun 2011) | 12 lines


1) redesigned computation by the undef values ideas, proved that
const2GV is not stuck
2) supported LLVM names with escaped chars
3) recovered interpreter regression, which is failed from version 2964,
from then, the constant null's type is restricted to be pointer types
syntactially, while interpreter was not consistent with this invariant.
4) A known problem of OCaml llvm bindings, the translation of 129.compress 
outputs a strange '^@' where it should print '0', this could be by some
illegal memory access from ocaml-llvm bindings.


------------------------------------------------------------------------
r2974 | jianzhou | 2011-06-16 22:12:31 -0400 (Thu, 16 Jun 2011) | 4 lines

fixed some bugs of computing data layout, and flattenning data values.
fixed cyclic dependence in ssa/Makefile.


------------------------------------------------------------------------
r2969 | jianzhou | 2011-06-15 01:04:05 -0400 (Wed, 15 Jun 2011) | 14 lines

Keep linkage, visibility, call conversion and all other attributes for
functions, arguments and callsites during translation.

Need to update the following LLVM source code, and recompile:
  vol/examples/HowToCallOCamlFromLLVM/llvm-2.6/include/llvm-c/Core.h
  vol/examples/HowToCallOCamlFromLLVM/llvm-2.6/lib/VMCore/Core.cpp
  vol/examples/HowToCallOCamlFromLLVM/llvm-2.6/bindings/ocaml/llvm/llvm.ml
  vol/examples/HowToCallOCamlFromLLVM/llvm-2.6/bindings/ocaml/llvm/llvm_ocaml.c
  vol/examples/HowToCallOCamlFromLLVM/llvm-2.6/bindings/ocaml/llvm/llvm.mli

The optimization result is not changed, -O3 does not lead to observable 
operformance improvement. 


------------------------------------------------------------------------
r2967 | jianzhou | 2011-06-14 16:49:12 -0400 (Tue, 14 Jun 2011) | 3 lines

renamed assoclist.v to alist.v


------------------------------------------------------------------------
r2966 | jianzhou | 2011-06-14 10:24:26 -0400 (Tue, 14 Jun 2011) | 5 lines

simplified bitcast in SBpass, we do not additional bitcast for metadata
variables to change them to i8*, we only need constant bitcast
expressions for constant metadata.


------------------------------------------------------------------------
r2964 | jianzhou | 2011-06-14 01:40:39 -0400 (Tue, 14 Jun 2011) | 14 lines

1) add linkage attributes for globals: for example, external, appending,
weak, ...
2) used the -lower-switch flag to replace switch by br
3) implemented a C++ floating point printer with its OCaml binding
(almost copied from VMCore/AsmWriter.cpp)
4) fixed a bug in SBpass, we need one more bitcast before set_mmetadata. 
5) made power, perimeter, tsp in olden-ccured work

Two more things to fix:
1) bitcast metadata in phinodes 
2) correctly print the char \01 in function names, for example
"\01__isoc99_scanf"


------------------------------------------------------------------------
r2963 | jianzhou | 2011-06-13 09:04:06 -0400 (Mon, 13 Jun 2011) | 7 lines

added -no-sbpass flag for debugging. for example

_build/SoftBound/main.d.byte -no-sbpass input.bc >& output.ll

it disables instrumentation in input.bc.


------------------------------------------------------------------------
r2962 | jianzhou | 2011-06-13 00:54:11 -0400 (Mon, 13 Jun 2011) | 3 lines

cp


------------------------------------------------------------------------
r2960 | jianzhou | 2011-06-12 00:33:53 -0400 (Sun, 12 Jun 2011) | 5 lines

redefined some typing rules (phi nodes, ssa properties) in Ott, s.t. Ott
can generate simple and easy to prove Coq code... also redesigned a lot
of helper functions in ssa_coq_lib.v to simplify proofs.


------------------------------------------------------------------------
r2957 | jianzhou | 2011-06-10 12:04:20 -0400 (Fri, 10 Jun 2011) | 3 lines

cleaned testing script


------------------------------------------------------------------------
r2956 | jianzhou | 2011-06-10 11:32:48 -0400 (Fri, 10 Jun 2011) | 21 lines

fixed a bug in the llvm2coq translation, which should check global
variables are always of pointer typ, so we can safely use its element
typ. In the formal syntax, a global constant can only have a pointer
type synatically.

Now SBpass works for all olden-ccured cases that we should support.
Times:
./bisort.exe 5000000 0;    7.8s
./em3d.exe 30000 300 50;   47.8s
./health.exe 8 250 1;      14.2s
./mst.exe 4000;            7.8s
./treeadd.exe 24 10;       5.6s
This is much slower (2-4x)than SoftBound. And the instrumented code is not
optimized before linking, because the LLVM optimizer gets failed at -O1 level,
the failure is from its Global Variable Opt pass..

The instrumentation of 129.compress is still failed, because the printer
of float value does not generate a right format that LLVM asm reader can
understand.


------------------------------------------------------------------------
r2955 | jianzhou | 2011-06-10 01:41:36 -0400 (Fri, 10 Jun 2011) | 4 lines

supported var_arg syntactically to allow SBpass for more test cases
(bisort, treeadd, health), not defined its semantics yet.


------------------------------------------------------------------------
r2953 | jianzhou | 2011-06-09 23:04:32 -0400 (Thu, 09 Jun 2011) | 3 lines

added the missing file.


------------------------------------------------------------------------
r2949 | jianzhou | 2011-06-07 17:00:24 -0400 (Tue, 07 Jun 2011) | 6 lines

fixed the problems about recursive type and type definitions. 
1) take one pass to collect all mapping from named types to their
definition.
2) take the second pass to substitute type names by their definitions.


------------------------------------------------------------------------
r2926 | jianzhou | 2011-06-04 00:53:43 -0400 (Sat, 04 Jun 2011) | 14 lines

1) SoftBound interfaces w/o shadow-stack were moved to
src/Parser/tvcases/softbound-nss
2) *.c/h @ src/Parser/tvcases is the SoftBound with shadow stack
3) the src/Parser/tvcases/compileall.sh recompiles all cases under
tvcases, setpath needs to be 'source' first. 
4) extended SBpass to support functions, src/SoftBound/test.sh runs all
available cases, fixed some bugs along the development.
  Unfixed problems:
  a) vargs is not supported, but all cases in olden-ccured/spec95 need
this feathure.
  b) failed for mutual recursive types, t1 = {t2*}  t2 = {t1*}
  These two features disallow all large examples...


------------------------------------------------------------------------
r2914 | jianzhou | 2011-05-28 17:31:00 -0400 (Sat, 28 May 2011) | 11 lines

switched to small-step semantics.
The big-step semantics is good when proving validation, but hard for
progress proofs. Progress proofs do induction over syntactic terms
(instructions): one problematic case is callsite 
   call func-name args ...
Here, func-name does not give us the expected IH --- properties of
calling the function 'func-name' with one big-step.

Small-step could solve the problem.


------------------------------------------------------------------------
r2913 | jianzhou | 2011-05-27 20:21:51 -0400 (Fri, 27 May 2011) | 5 lines

1) updated SBpass design with 'subblock' ideas, to make it provable.
2) added the mutual proofs for the correctness of blocks-transformation.
3) split sb_trans.v to be sb_trans/sb_trans_correct.v.


------------------------------------------------------------------------
r2911 | jianzhou | 2011-05-26 13:31:57 -0400 (Thu, 26 May 2011) | 5 lines

1) strengthened simrel: every valid block must be mapped; delta is
always 0; bounds are not changed; globals are id-mapped.
2) fixed most of admit's about freshness.


------------------------------------------------------------------------
r2907 | jianzhou | 2011-05-24 23:37:00 -0400 (Tue, 24 May 2011) | 3 lines

changed int2ptr and ptr2int, so they are not cleared on free.


------------------------------------------------------------------------
r2905 | jianzhou | 2011-05-23 23:30:04 -0400 (Mon, 23 May 2011) | 5 lines

split memory error to be spatial and temporal errors.
Spatial error: accessing out-of-bound offsets of a valid block
Temporal error: accessing released blocks


------------------------------------------------------------------------
r2904 | jianzhou | 2011-05-23 15:21:06 -0400 (Mon, 23 May 2011) | 6 lines

defined wf constants that disallow inttoptr, and wf values/cmds as well.
defined wf globals where all globals have blocks less than other
heap-allocated blocks at runtime.
mem-simulation are defined w.r.t them.


------------------------------------------------------------------------
r2903 | jianzhou | 2011-05-22 20:06:25 -0400 (Sun, 22 May 2011) | 5 lines

1) removed the backward part from the simuluation relations
2) defined wellformed meminj
3) extracted axioms for metadata space interfaces.


------------------------------------------------------------------------
r2901 | jianzhou | 2011-05-21 15:30:21 -0400 (Sat, 21 May 2011) | 3 lines

cp before some more changes of simulation relations.


------------------------------------------------------------------------
r2897 | jianzhou | 2011-05-19 22:00:36 -0400 (Thu, 19 May 2011) | 37 lines

Another problem: How to make ptr2int to be total.

The current ptr2int has two cases
 ptr2int (Vint2ptr i) = i // the easy case
 ptr2int (Vptr b ofs) = ..?

The later case searchs the mapping from block-ofs to addresses, which
can be None if b does not exist. For example
  p = malloc ...;
  free p;
  i = ptrtoint p; // Here, the p is not valid, so we are stuck.

For the current proof (proving a value is not changed before and after a
malloc), this does not seem to be matter. Because,
1) if ptrtoint is legal before malloc, it should returns the same thing
after malloc, because malloc does not break existing blocks
2) if ptrtoint is None by pointing to a dead block, it should still
point to the dead block since malloc does not reuse any old blocks.

The rest reasoning is to show that a well-formed program cannot forge a
ptr to a blk-ofs out-of-thin-air, which could be a hard proof.

But, even the above idea works, it is not extensible to a practical
memory model that reuses memory.
 
One idea is to split Vint to be a normal Vint and a Vptrtoint b ofs;
keeping track free-ed blocks. But we still need to argue that a program
cannot 'create' a ptr w/o malloc --- pointing to a block that is not
form malloc. Secondly, this is not extensible to reallocating malloc
either, because at the case, a blk can be mapped to more than one
concrete addresses. 

The other idea is to let Vptr to be
  blk -> ofs -> addr -> val
here, the addr is its concrete addr.


------------------------------------------------------------------------
r2893 | jianzhou | 2011-05-18 23:16:13 -0400 (Wed, 18 May 2011) | 3 lines

added Vinttoptr in the memory model.


------------------------------------------------------------------------
r2886 | jianzhou | 2011-05-18 12:13:35 -0400 (Wed, 18 May 2011) | 29 lines

1) Fixed rmap to be parial
2) simplified simulation relations, s.t. they consider both value_id and
value_const cases, which reduces 1/3 size of the proofs

Checkpoint before another change.

Here is the problem. The SoftBound instrumentation of malloc is like
this:
%p = malloc i8, i32 (ptrtoint (i32* (inttoptr (i32 42 to i32*)) %to i32))
%b = bitcast i8* %p to i8*
%e = gep i8* %p, i32 (ptrtoint (i32* (inttoptr (i32 42 to i32*)) %to i32))

[NOTE: The ptrtoint and inttoptr things are optimized away by llvm-as
-disable-opt. From the log of llvm-as, I cannot find which pass it runs
to do such constant-fold. Maybe by default such folding should happen.
So we cannot create a case to show the problem.]

In term of the current memory model, if 42 is not a valid address for
any allocated blocks, inttoptr returns null, and the final reresult
before malloc is 0. Suppose the malloc turns 42 to be an allocated
address, the constant returns 42 after the malloc. This is inconsistent
with LLVM.

To fix it, we are intruducing a new value, Vint2ptr : int -> val. Given
an inttoptr i, if the i is within a good memory block b with ofs, it
returns Vptr b ofs, otherwise it returns Vint2ptr i. In such an way, we
turned int2ptr to be total w/o losing any information.


------------------------------------------------------------------------
r2884 | jianzhou | 2011-05-17 11:24:14 -0400 (Tue, 17 May 2011) | 12 lines

Update:
  mem_simulation takes MM as a total function : addr -> metadata, the
default value is (null, null). In SoftBound this means that loading an
unused metadata returns an illegal range.

Checkpoint before updating reg_simulation:
 The rmap in reg_simulation must be a partial function (r -> option (r*r)), 
although a well-formed code is not stuck at this partial behavior (a use
must be defined). The current rmap in sb_def.v is a total function
(incorrect). 


------------------------------------------------------------------------
r2881 | jianzhou | 2011-05-16 20:54:25 -0400 (Mon, 16 May 2011) | 21 lines


checkpoint before some more updates of mem-simulation.

NOTE: found an inconsistent between this proof and the old proofs. The
old proofs assume that malloc zeros-out all metadata indiced by the
address in the allocation range. Otherwise, if malloc reuses free-ed
addresses that have old metadata, then runtime can load wrong metadata
for the reused address.

The SoftBound implementation for llvm-2.6 does not create wrappers for
malloc, so the above assumption (zero-out metadata) is not true. This is
because llvm 2.6 takes malloc as a primitive insn. SoftBound supports
malloc wrapper for llvm 2.7>=, which takes malloc as intrinsic
functions.

This is not a problem for the current memory model because it has
infinite memory, and does not reuse any deallocated address. But this
must be a problem to prove CETS for llvm 2.6 since we need a more
realistic memory model that reuses memory.


------------------------------------------------------------------------
r2879 | jianzhou | 2011-05-15 09:57:14 -0400 (Sun, 15 May 2011) | 6 lines

1) solved some admit's
2) replaced Int.unsigned with Int.signed when converting Int to Z
because CompCertMM allows negative offset.
2) checkpoint before checking the mem-simulation relation.


------------------------------------------------------------------------
r2878 | jianzhou | 2011-05-13 22:55:09 -0400 (Fri, 13 May 2011) | 21 lines

a SoftBound pass for memory accesses (no function pointers), and a
translation from Coq AST to *.ll bitcode.

SoftBound/test.sh uses this pass for milli and micro test cases, whose
result is in SoftBound/log.

Problems:
1) validating outputs of this SoftBound and the real SoftBound needs to
solve the following problems:
  renaming of local variables, additional temps from both sides,
value-numbering, dead-code eliminations, and ...

We can reuse PLDI11's LLVM validator to check such equivalence,
although that validator is not formally verified. Verifying such a
validator has different interests than designing a memory model.

2) @ssa/genericvalues.v, the utyp <-> typ translation does not work for
recursive types. We need to fix them. For example, micro/linklist is
failed because of this problem. utyp <-> typ is used to defined GEP.


------------------------------------------------------------------------
r2872 | jianzhou | 2011-05-13 00:02:03 -0400 (Fri, 13 May 2011) | 3 lines

print Coq AST to *.ll


------------------------------------------------------------------------
r2870 | jianzhou | 2011-05-11 15:09:18 -0400 (Wed, 11 May 2011) | 3 lines

a release to Greg.


------------------------------------------------------------------------
r2869 | jianzhou | 2011-05-10 23:33:04 -0400 (Tue, 10 May 2011) | 20 lines

1) proving forward-simulation of sb_trans. Given a deterministic opsem,
forward-simulation also implies backward-simulation. This proof requires
a simulation relation over registers and memory states, which is a
relation different from the injection and extension relations of
CompCert memory model, because it allows possibly more blocks in a
transformed program.

We need this relation because SoftBound uses additional memory blocks to
keep track meta data. This makes back-simulation failed: for example,
given a
  inttoptr ((i32 42) to i32*)
42 could be a valid address in those additional blocks of a transformed
program, but not a valid address of its original one.

2) fixed a bug of llvm bindings: should use Int64_val to convert Caml
value to a unsiged long long.

3) One more case for an inttoptr constant expression


------------------------------------------------------------------------
r2868 | jianzhou | 2011-05-09 22:48:06 -0400 (Mon, 09 May 2011) | 5 lines

1) added the design of SoftBound pass
2) added one more binding of APInt --- of_int64
3) changed the structure of extracted code


------------------------------------------------------------------------
r2865 | jianzhou | 2011-05-07 21:01:53 -0400 (Sat, 07 May 2011) | 4 lines

1) defined mgep/mset/mget
2) check point of progress


------------------------------------------------------------------------
r2859 | jianzhou | 2011-05-05 23:58:11 -0400 (Thu, 05 May 2011) | 3 lines

check point of preservation.


------------------------------------------------------------------------
r2856 | jianzhou | 2011-05-05 14:23:33 -0400 (Thu, 05 May 2011) | 3 lines

SB's spec back-simulates SimpleSE.opsem.


------------------------------------------------------------------------
r2853 | jianzhou | 2011-05-04 23:59:12 -0400 (Wed, 04 May 2011) | 3 lines

A spec for softbound


------------------------------------------------------------------------
