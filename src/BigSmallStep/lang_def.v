(* generated by Ott 0.10.16 ***locally nameless*** from: lang.ott *)

Require Import Metatheory.

(** syntax *)
Definition expvar := var.

Inductive exp : Set := 
 | const : exp
 | var_b : nat -> exp
 | var_f : expvar -> exp
 | abs : exp -> exp
 | app : exp -> exp -> exp.

Inductive object : Set := 
 | object_bot : object
 | object_err : object
 | object_const : object
 | object_abs : exp -> object.

(* EXPERIMENTAL *)

(** subrules *)
Definition is_value_of_exp (e_5:exp) : Prop :=
  match e_5 with
  | const => (True)
  | (var_b nat) => False
  | (var_f x) => False
  | (abs e) => (True)
  | (app e1 e2) => False
end.


(** opening up abstractions *)
Fixpoint open_exp_wrt_exp_rec (k:nat) (e_5:exp) (e__6:exp) {struct e__6}: exp :=
  match e__6 with
  | const => const 
  | (var_b nat) => 
      match lt_eq_lt_dec nat k with
        | inleft (left _) => var_b nat
        | inleft (right _) => e_5
        | inright _ => var_b (nat - 1)
      end
  | (var_f x) => var_f x
  | (abs e) => abs (open_exp_wrt_exp_rec (S k) e_5 e)
  | (app e1 e2) => app (open_exp_wrt_exp_rec k e_5 e1) (open_exp_wrt_exp_rec k e_5 e2)
end.

Definition open_object_wrt_exp_rec (k:nat) (e5:exp) (o5:object) : object :=
  match o5 with
  | object_bot => object_bot 
  | object_err => object_err 
  | object_const => object_const 
  | (object_abs e) => object_abs (open_exp_wrt_exp_rec (S k) e5 e)
end.

Definition open_exp_wrt_exp e_5 e__6 := open_exp_wrt_exp_rec 0 e__6 e_5.

Definition open_object_wrt_exp e5 o5 := open_object_wrt_exp_rec 0 o5 e5.


(** terms are locally-closed pre-terms *)
(** definitions *)

(* defns LC_exp *)
Inductive lc_exp : exp -> Prop :=    (* defn lc_exp *)
 | lc_const : 
     (lc_exp const)
 | lc_var_f : forall (x:expvar),
     (lc_exp (var_f x))
 | lc_abs : forall (e:exp),
      ( forall x , lc_exp  ( open_exp_wrt_exp e (var_f x) )  )  ->
     (lc_exp (abs e))
 | lc_app : forall (e1 e2:exp),
     (lc_exp e1) ->
     (lc_exp e2) ->
     (lc_exp (app e1 e2)).

(* defns LC_object *)
Inductive lc_object : object -> Prop :=    (* defn lc_object *)
 | lc_object_bot : 
     (lc_object object_bot)
 | lc_object_err : 
     (lc_object object_err)
 | lc_object_const : 
     (lc_object object_const)
 | lc_object_abs : forall (e:exp),
      ( forall x , lc_exp  ( open_exp_wrt_exp e (var_f x) )  )  ->
     (lc_object (object_abs e)).

(** free variables *)
Fixpoint fv_exp (e_5:exp) : vars :=
  match e_5 with
  | const => {}
  | (var_b nat) => {}
  | (var_f x) => {{x}}
  | (abs e) => (fv_exp e)
  | (app e1 e2) => (fv_exp e1) \u (fv_exp e2)
end.

Definition fv_object (o5:object) : vars :=
  match o5 with
  | object_bot => {}
  | object_err => {}
  | object_const => {}
  | (object_abs e) => (fv_exp e)
end.


(** substitutions *)
Fixpoint subst_exp (e_5:exp) (x5:expvar) (e__6:exp) {struct e__6} : exp :=
  match e__6 with
  | const => const 
  | (var_b nat) => var_b nat
  | (var_f x) => (if eq_var x x5 then e_5 else (var_f x))
  | (abs e) => abs (subst_exp e_5 x5 e)
  | (app e1 e2) => app (subst_exp e_5 x5 e1) (subst_exp e_5 x5 e2)
end.

Definition subst_object (e5:exp) (x5:expvar) (o5:object) : object :=
  match o5 with
  | object_bot => object_bot 
  | object_err => object_err 
  | object_const => object_const 
  | (object_abs e) => object_abs (subst_exp e5 x5 e)
end.


(** definitions *)

(* defns Jsmallstep *)
Inductive smallstep : exp -> exp -> Prop :=    (* defn smallstep *)
 | smallstep_app_1 : forall (e1 e2 e1':exp),
     lc_exp e2 ->
     smallstep e1 e1' ->
     smallstep (app e1 e2) (app e1' e2)
 | smallstep_app_2 : forall (e2 e2' v1:exp),
     is_value_of_exp v1 ->
     lc_exp v1 ->
     smallstep e2 e2' ->
     smallstep (app v1 e2) (app v1 e2')
 | smallstep_beta : forall (e1 v2:exp),
     is_value_of_exp v2 ->
     lc_exp (abs e1) ->
     lc_exp v2 ->
     smallstep (app  ( (abs e1) )  v2)  (open_exp_wrt_exp  e1   v2 ) .

(* defns Jsmallstep_converging *)
Inductive smallstep_converging : exp -> exp -> Prop :=    (* defn smallstep_converging *)
 | smallstep_c_refl : forall (e:exp),
     lc_exp e ->
     smallstep_converging e e
 | smallstep_c_trans : forall (e e'' e':exp),
     smallstep e e' ->
     smallstep_converging e' e'' ->
     smallstep_converging e e''.

(* defns Jbigstep_converging *)
Inductive bigstep_converging : exp -> exp -> Prop :=    (* defn bigstep_converging *)
 | bigstep_c_const : 
     bigstep_converging const const
 | bigstep_c_abs : forall (e:exp),
     lc_exp (abs e) ->
     bigstep_converging (abs e) (abs e)
 | bigstep_c_app : forall (e1 e2 v e1' v2:exp),
     is_value_of_exp v ->
     is_value_of_exp v2 ->
     bigstep_converging e1  ( (abs e1') )  ->
     bigstep_converging e2 v2 ->
     bigstep_converging  (open_exp_wrt_exp  e1'   v2 )  v ->
     bigstep_converging (app e1 e2) v.

(* defns Jbigstep_goingwrong *)
Inductive bigstep_goingwrong : exp -> Prop :=    (* defn bigstep_goingwrong *)
 | bigstep_w_app1_wrong : forall (e1 e2:exp),
     lc_exp e2 ->
     bigstep_goingwrong e1 ->
     bigstep_goingwrong (app e1 e2)
 | bigstep_w_app1_const : forall (e1 e2:exp),
     lc_exp e2 ->
     bigstep_converging e1 const ->
     bigstep_goingwrong (app e1 e2)
 | bigstep_w_app2_wrong : forall (e1 e2 e1':exp),
     bigstep_converging e1  ( (abs e1') )  ->
     bigstep_goingwrong e2 ->
     bigstep_goingwrong (app e1 e2)
 | bigstep_w_appf : forall (e1 e2 e1' v2:exp),
     is_value_of_exp v2 ->
     bigstep_converging e1  ( (abs e1') )  ->
     bigstep_converging e2 v2 ->
     bigstep_goingwrong  (open_exp_wrt_exp  e1'   v2 )  ->
     bigstep_goingwrong (app e1 e2).

(* defns Jobjects_order *)
Inductive objects_order : object -> object -> Prop :=    (* defn objects_order *)
 | object_order_refl : forall (o:object),
     lc_object o ->
     objects_order o o
 | object_order_bot : forall (o:object),
     lc_object o ->
     objects_order object_bot o.

(** infrastructure *)

(* additional definitions *)


(* instanciation of tactics *)

Ltac gather_atoms ::=
  let A := gather_atoms_with (fun x : vars => x) in
  let B := gather_atoms_with (fun x : var => {{ x }}) in
  let D1 := gather_atoms_with (fun x => fv_exp x) in
  let D2 := gather_atoms_with (fun x => fv_object x) in
  constr:(A \u B \u D1 \u D2).

Hint Constructors smallstep smallstep_converging bigstep_converging bigstep_goingwrong objects_order lc_exp lc_object.




