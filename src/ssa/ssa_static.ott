
% Static Semantics of Static Single Assignment(SSA)

embed
{{coq

Require Import ssa_def.
Require Import ssa_lib.
Require Import ListSet.

Module LLVMwf.
Export LLVMsyntax.
Export LLVMlib.

}}

defns
Jwf_typ :: '' ::=
      defn
      system |- typ :: :: wf_typ :: '' {{ com [[typ]] is well-formed }} by  

      sz > 0
      -------------------- :: wf_typ_int
      system |- int sz

      -------------------- :: wf_typ_floatpoint
      system |- floating_point

      -------------------- :: wf_typ_void
      system |- void

      -------------------- :: wf_typ_label
      system |- label

      -------------------- :: wf_typ_metadate
      system |- metadata

      -------------------- :: wf_typ_opaque
      system |- opaque

      isValidReturnTyp typ     
      system |- typ
      </ isValidArgumentTyp typj // j />
      </ system |- typj // j /> 
      -------------------------------------------------- :: wf_typ_function
      system |- typ ( </ typj // j /> ) 
     
      </ isValidElementTyp typj // j />
      </ system |- typj // j /> 
      -------------------------------------------------- :: wf_typ_structure
      system |- { </ typj // j /> }

      system |- typ
      isValidElementTyp typ
      ------------------- :: wf_typ_array
      system |- [ sz * typ ]

      system |- typ
      isValidElementTyp typ
      ------------------- :: wf_typ_pointer
      system |- typ * 

      % |- typ
      % isValidElementTyp typ
      % ------------------- :: wf_typ_vector
      % |- < INT * typ >

      lookupTypViaIDFromSystem system id = opt_typ
      ---------------------------------------------- :: wf_typ_namedt
      system |- id


defns
Jwf_const :: '' ::=
      defn 
      system |-c const : typ :: :: wf_const :: ''
      {{ com [[const]] has [[typ]] }} by

      system |- typ
      ------------------------------------- :: wf_const_zeroinitializer
      system |-c typ zeroinitializer : typ


      system |- int sz
      sz > 0
      ----------------------------- :: wf_const_int
      system |-c (int sz) INT : int sz

      ------------------------------------------------- :: wf_const_floatpoint
      system |-c floating_point Float : floating_point

      system |- typ
      -------------------- :: wf_const_undef
      system |-c typ undef : typ

      system |- typ*
      ---------------------- :: wf_const_null
      system |-c (typ*) null : typ*


      </ system |-c constj : typ // j />
      length </ constj // j /> = sz
      -------------------------------------------------- :: wf_const_arr
      system |-c typ [ </ constj // j /> ] : [sz * typ]

      </ system |-c constj : typj // j IN n />
      ------------------------------------------------------------ :: wf_const_struct
      system |-c { </ constj // j IN n /> } : { </ typj // j IN n /> }


      system |- typ*
      lookupTypViaIDFromSystem system id = typ*
      ------------------------------------------- :: wf_const_gid
      system |-c typ * id : typ*

      system |-c const : int sz1
      system |- int sz2
      sz2 < sz1
      -------------------------------------------------- :: wf_const_trunc_int
      system |-c trunc_int const to (int sz2) : int sz2

      system |-c const : floating_point1
      floating_point2 < floating_point1
      ---------------------------------------------------------------- :: wf_const_trunc_fp
      system |-c trunc_int const to floating_point2 : floating_point2

      system |-c const : int sz1
      system |- int sz2
      sz1 < sz2
      --------------------------------------- :: wf_const_zext
      system |-c zext const to typ : int sz2

      system |-c const : int sz1
      system |- int sz2
      sz1 < sz2
      --------------------------------------- :: wf_const_sext
      system |-c sext const to typ : int sz2

      system |-c const : floating_point1
      floating_point1 < floating_point2
      -------------------------------------------------- :: wf_const_fpext
      system |-c fpext const to typ : floating_point2

      system |-c const : floating_point
      system |- int sz
      --------------------------------------------- :: wf_const_fptoui
      system |-c fptoui const to (int sz) : int sz

      system |-c const : floating_point
      system |- int sz
      --------------------------------------------- :: wf_const_fptosi
      system |-c fptosi const to (int sz) : int sz

      system |-c const : int sz
      ----------------------------------------------------------- :: wf_const_uitofp
      system |-c uitofp const to floating_point : floating_point

      system |-c const : int sz
      ----------------------------------------------------------- :: wf_const_sitofp
      system |-c sitofp const to floating_point : floating_point

      system |-c const : typ*
      system |- int sz
      ----------------------------------------------- :: wf_const_ptrtoint
      system |-c ptrtoint const to (int sz) : int sz

      system |-c const : int sz
      system |- typ*
      ----------------------------------------------- :: wf_const_inttoptr
      system |-c ptrtoint const to (typ*) : typ*

      % Check typs
      system |-c const : typ1
      system |- typ2
      % BitCast implies a no-op cast of type only. No bits change.
      % However, you can't cast pointers to anything but pointers.
      Typ.getPrimitiveSizeInBits typ1 = sz1 /\ Typ.getPrimitiveSizeInBits typ2 = sz2 /\ sz1 = sz2
      % Bitcast requires types of same width.
      isPointerTyp typ1 iff isPointerTyp typ2 
      % Disallow aggregates.
      (not isAggregateTyp typ1) /\ (not isAggregateTyp typ2)
      ------------------------------------------------------- :: wf_const_bitcast
      system |-c ptrtoint const to typ2 : typ2

      % Check typs
      system |-c const : typ*
      </ system |-c constj : int sz /\ sz = 32 // j />
      % Check indexs
      getConstGEPTyp </ constj // j /> (typ*) = typ'
      ----------------------------------------------------------------- :: wf_const_gep
      system |-c getelementptr inbounds const </ constj // j />	: typ'

      % Check typs
      system |-c const0 : int sz /\ sz = 1
      system |-c const1 : typ
      system |-c const2 : typ
      --------------------------------------------- :: wf_const_select
      system |-c select const0 const1 const2 : typ

      % Check typs
      system |-c const1 : typ
      system |-c const2 : typ
      % types can only be int, vector or ptr
      Typ.isIntOrIntVector typ \/ isPointerTyp typ
      --------------------------------------------- :: wf_const_icmp
      system |-c icmp cond const1 const2 : typ

      % Check typs
      system |-c const1 : floating_point
      system |-c const2 : floating_point
      ----------------------------------------------------- :: wf_const_fcmp
      system |-c fcmp fcond const1 const2 : floating_point


      % Check typs
      system |-c const : typ
      </ system |-c constj : int sz /\ sz = 32 // j />
      % Check indexs
      getSubTypFromConstIdxs </ constj // j /> typ = typ'
      ------------------------------------------------------- :: wf_const_extractvalue
      system |-c extractvalue const </ constj // j /> : typ'


      % Check typs
      system |-c const : typ
      system |-c const' : typ'
      </ system |-c constj : int sz /\ sz = 32 // j />
      % Check indexs
      getSubTypFromConstIdxs </ constj // j /> typ = typ'
      ------------------------------------------------------------ :: wf_const_insertvalue
      system |-c insertvalue const const' </ constj // j /> : typ

      % Check typs
      system |-c const1 : int sz
      system |-c const2 : int sz
      --------------------------------------- :: wf_const_bop
      system |-c bop const1 const2 : int sz

      % Check typs
      system |-c const1 : floating_point
      system |-c const2 : floating_point
      ----------------------------------------------- :: wf_const_fbop
      system |-c fbop const1 const2 : floating_point

defns
Jwf_value :: '' ::=
      defn
      system |- value : typ :: :: wf_value :: ''
      {{ com [[value]] has [[typ]] wrt [[system]] }} by

      system |-c const : typ
      ------------------------------------------ :: wf_value_const
      system |- const : typ

      system |- typ
      lookupTypViaIDFromSystem system id = typ
      ------------------------------------------ :: wf_value_id
      system |- id : typ

defns
Jwf_ssa :: '' ::=
      defn
      intrinsic_funs , system , module_info , fdef_info , block , insn |- insn' :: :: wf_ssa :: ''
      {{ com [[insn']] is well-formed w.r.t [[insn]] [[block]] in [[fdef_info]] in [[module_info]] [[system]] }} by

      getInsnID insn' = id'
      lookupBlockViaIDFromFdef fdef id' = block'
      % Check that a definition dominates all of its uses *)
      %
      % PHI nodes are more difficult than other nodes because they actually
      % "use" the value in the predecessor basic blocks they correspond to. 
<<
      (isPhiNode insn) implies 
        (getLabelViaIDPhiNode insn id' = l'' /\ 
         lookupBlockViaLabelFromSystem system l'' = block'' /\ 
         (
          (blockDominates dt block' block'') \/ 
          (not (isReachableFromEntry (fdef, dt) block )) 
         ) 
        )
>>
      % if insn is not PhiNode, make sure that the definition comes before the use
      (notT isPhiNode insn) implies (insnDominates insn' insn block \/ (not (isReachableFromEntry (fdef, dt) block)))
      ------------------------------------------------------------------------------------------------------------- :: wf_ssa_intro
      intrinsic_funs , system , module_info , (fdef, dt) , block , insn |- insn' 

defns
Jwf_operand :: '' ::=
      defn
      intrinsic_funs , system , module_info , fdef_info , block , insn |- id' :: :: wf_operand :: ''
      {{ com [[id']] is well-formed w.r.t [[insn]] [[block]] in [[fdef_info]] in [[module_info]] [[system]] }} by

      module = (layouts namedts products)
      insn in system , (module, usedef_id, usedef_block) , (fdef, dt) , block
      getInsnOperands insn = ids
      id' in ids
      % FIXME: lookupBindingViaIDFromSystem is not correct, it should only search bindings within the current
      % scopes where id' is, rather than seaching any functions, because in other function, there could be 
      % variables with same names
      lookupBindingViaIDFromSystem system id' = id_binding'
      % Check to make sure that only first-class-values are operands to instructions.
      getBindingTyp id_binding' = typ'     
      isFirstClassTyp typ'
      % Valid use of metadata pointer.
      (getPointerEltTyp typ' = typ'') implies (not typ'' =t= metadata)
      % Check to make sure that the "address of" an intrinsic function is never
      % taken, and referencing function exists in current module!
      (isBindingFdec id_binding' = fdec) implies (getFdecID fdec = id0 /\ (id0 notin intrinsic_funs \/ getCalledValueID insn = id') /\ fdec in products)
      % Referring to an argument in the current function
      (isBindingArg id_binding' = arg) implies (argInFdef arg fdef)
      % Referencing global in the current module
      (isBindingGvar id_binding' = gvar) implies (gvar in products)
      %
      % Check when id_binding' is insn
      (isBindingInsn id_binding' = insn') implies (intrinsic_funs , system , (module, usedef_id, usedef_block), (fdef, dt), block , insn |- insn')
      ----------------------------------------------------------------------------------------------------------------------- :: wf_operand_intro
      intrinsic_funs , system , (module, usedef_id, usedef_block) , (fdef, dt) , block , insn |- id'

defns
Jwf_insn_base :: '' ::=
      defn
      intrinsic_funs , system , module_info , fdef_info , block |-i insn :: :: wf_insn_base :: '' 
      {{ com [[insn]] is well-formed w.r.t [[block]] in [[fdef_info]] in [[module_info]] [[system]] }} by  
      % Verifier::visitInstruction

      % Instruction must be embedded in basic block!
      insn in system , module_info , fdef_info , block
      % Check that non-phi nodes are not self referential in wf_insn_base::PhiNode
      %
      % Verify that if this is a terminator that it is at the end of the block in wf_block
      %
      % Check that void typed values don't have names
      % We dont need to check this in Ott
      %
      % Check that the return value of the instruction is either void or a legal value type.
      getInsnTyp insn = typ
      typ =t= void \/ isFirstClassTyp typ
      % Check that the instruction doesn't produce metadata or metadata*. Calls
      % all already checked against the callee type.
      (not typ =t= metadata) \/ isCallInsn insn 
      % Instructions may not produce pointer to metadata.
      (isPointerTyp typ) implies (getPointerEltTyp typ = typ' /\ (not typ' =t= metadata)) 
      % Check that all uses of the instruction, if they are instructions
      % themselves, actually have parent basic blocks.  If the use is not an
      % instruction, it is an error!
      % We should prove a lemma for this later.
      %
      % Check operands
      getInsnOperands insn = ids
      ids <-> </ idj // j />
      </ intrinsic_funs , system , module_info , fdef_info , block , insn |- idj // j />
      -------------------------------------------------------------------------------------- :: wf_insn_base_intro
      intrinsic_funs , system , module_info , fdef_info , block |-i insn

defns
Jwf_cast :: '' ::=
      defn
      intrinsic_funs , system , module_info , fdef_info , block |-cast insn :: :: wf_cast :: '' 
      {{ com cast [[insn]] is well-formed w.r.t [[block]] in [[fdef_info]] in [[module_info]] [[system]] }} by  

      % Check typs
      system |- value1 : typ *
      % Check invariance for instructions 
      intrinsic_funs , system , module_info , fdef_info , block |-i id = ptrtoint ( typ * ) value1 to ( int sz )
      ------------------------------------------------------------------------------------------------------- :: wf_cast_ptrtoint
      intrinsic_funs , system , module_info , fdef_info , block |-cast id = ptrtoint ( typ * ) value1 to ( int sz )	


      % Check typs
      system |- value1 : int sz
      % Check invariance for instructions 
      intrinsic_funs , system , module_info , fdef_info , block |-i id = inttoptr ( int sz ) value1 to ( typ * )	
      ------------------------------------------------------------------------------------------------------------ :: wf_cast_inttoptr
      intrinsic_funs , system , module_info , fdef_info , block |-cast id = inttoptr ( int sz ) value1 to ( typ * )


      % Check typs
      system |- value1 : typ1
      % BitCast implies a no-op cast of type only. No bits change.
      % However, you can't cast pointers to anything but pointers.
      Typ.getPrimitiveSizeInBits typ1 = sz1 /\ Typ.getPrimitiveSizeInBits typ2 = sz2 /\ sz1 = sz2
      % Bitcast requires types of same width.
      isPointerTyp typ1 iff isPointerTyp typ2 
      % Disallow aggregates.
      (not isAggregateTyp typ1) /\ (not isAggregateTyp typ2)
      % Check invariance for instructions 
      intrinsic_funs , system , module_info , fdef_info , block |-i id = bitcast typ1 value1 to typ2		
      ----------------------------------------------------------------------------------------------- :: wf_cast_bitcast
      intrinsic_funs , system , module_info , fdef_info , block |-cast id = bitcast typ1 value1 to typ2		

defns
Jwf_trunc :: '' ::=
      defn
      intrinsic_funs , system , module_info , fdef_info , block |-trunc insn :: :: wf_trunc :: '' 
      {{ com trunc [[insn]] is well-formed w.r.t [[block]] in [[fdef_info]] in [[module_info]] [[system]] }} by  

      % Check typs
      system |- value1 : int sz1 
      % bitwidth of dest typ is less then src typ
      sz2 < sz1
      % Check invariance for instructions 
      intrinsic_funs , system , module_info , fdef_info , block |-i id = trunc_int ( int sz1 ) value1 to ( int sz2 )
      ----------------------------------------------------------------------------------------------- :: wf_trunc_int
      intrinsic_funs , system , module_info , fdef_info , block |-trunc id = trunc_int ( int sz1 ) value1 to ( int sz2 )	

      % Check typs
      system |- value1 : floating_point11 
      % bitwidth of dest typ is less then src typ
      floating_point2 < floating_point1
      % Check invariance for instructions 
      intrinsic_funs , system , module_info , fdef_info , block |-i id = trunc_fp floating_point1 value1 to floating_point2
      ----------------------------------------------------------------------------------------------- :: wf_trunc_fp
      intrinsic_funs , system , module_info , fdef_info , block |-trunc id = trunc_fp floating_point1 value1 to floating_point2	

defns
Jwf_ext :: '' ::=
      defn
      intrinsic_funs , system , module_info , fdef_info , block |-ext insn :: :: wf_ext :: '' 
      {{ com ext [[insn]] is well-formed w.r.t [[block]] in [[fdef_info]] in [[module_info]] [[system]] }} by  

      % Check typs
      system |- value1 : int sz1 
      % bitwidth of src typ is less then dest typ
      sz1 < sz2
      % Check invariance for instructions 
      intrinsic_funs , system , module_info , fdef_info , block |-i id = zext ( int sz1 ) value1 to ( int sz2 )
      ------------------------------------------------------------------------------------------------------- :: wf_ext_z
      intrinsic_funs , system , module_info , fdef_info , block |-ext id = zext ( int sz1 ) value1 to ( int sz2 )	

      % Check typs
      system |- value1 : int sz1 
      % bitwidth of src typ is less then dest typ
      sz1 < sz2
      % Check invariance for instructions 
      intrinsic_funs , system , module_info , fdef_info , block |-i id = sext ( int sz1 ) value1 to ( int sz2 )
      ------------------------------------------------------------------------------------------------------- :: wf_ext_s
      intrinsic_funs , system , module_info , fdef_info , block |-ext id = sext ( int sz1 ) value1 to ( int sz2 )	

      % Check typs
      system |- value1 : floating_point1 
      % bitwidth of src typ is less then dest typ
      floating_point1 < floating_point2
      % Check invariance for instructions 
      intrinsic_funs , system , module_info , fdef_info , block |-i id = fpext floating_point1 value1 to floating_point2
      ------------------------------------------------------------------------------------------------------- :: wf_ext_fp
      intrinsic_funs , system , module_info , fdef_info , block |-ext id = fpext floating_point1 value1 to floating_point2	

defns
Jwf_insn :: '' ::=
      defn
      intrinsic_funs , system , module_info , fdef_info , block |- insn :: :: wf_insn :: '' 
      {{ com [[insn]] is well-formed w.r.t [[block]] in [[fdef_info]] in [[module_info]] [[system]] }} by  

      % Check typs
      system |- value : typ
      % Exactly one return value and it matches the return type. Good. 
      Function.getDefReturnType fdef = typ
      % Check invariance for instructions
      intrinsic_funs , system , module_info , (fdef, dt) , block |-i id = ret typ value
      ------------------------------------------------------ :: wf_insn_return
      intrinsic_funs , system , module_info , (fdef, dt) , block |- id = ret typ value

      % return instr that returns void in Function can be of void return type! 
      Function.getDefReturnType fdef = void
      % Check invariance for instructions
      intrinsic_funs , system , module_info , (fdef, dt) , block |-i id = ret void
      ------------------------------------------------------- :: wf_insn_return_void
      intrinsic_funs , system , module_info , (fdef, dt) , block |- id = ret void

      % Check typs
      system |- value : int sz /\ sz = 1
      % Check labels
      lookupBlockViaLabelFromFdef fdef l1 = block1
      lookupBlockViaLabelFromFdef fdef l2 = block2
      not (l1 = l2)
      % Check invariance for instructions
      intrinsic_funs , system , module_info , (fdef, dt) , block |-i id = br value l1 l2
      -------------------------------------------------------------------------------------- :: wf_insn_br
      intrinsic_funs , system , module_info , (fdef, dt) , block |- id = br value l1 l2	

      % Check labels
      lookupBlockViaLabelFromFdef fdef l = block
      % Check invariance for instructions
      intrinsic_funs , system , module_info , (fdef, dt) , block |-i id = br l
      -------------------------------------------------------------------------------------- :: wf_insn_br_uncond
      intrinsic_funs , system , module_info, (fdef, dt) , block |- id = br l		

      % intrinsic_funs , system , module_info , fdef_info , block |-i id = invoke typ0 id0 params to l1 unwind l2
      % -------------------------------------------------------------------------------------- :: wf_insn_invoke
      % intrinsic_funs , system , module_info, fdef_info , block |- id = invoke typ0 id0 params to l1 unwind l2

      % Check invariance for instructions
      intrinsic_funs , system , module_info , fdef_info , block |-i id = unreachable
      -------------------------------------------------------------------------------------- :: wf_insn_unreachable
      intrinsic_funs , system , module_info, fdef_info , block |- id = unreachable

      % Check typs
      system |- value1 : int sz
      system |- value2 : int sz
      % Check that integer arithmetic operators are only used with integral operands.
      % Integer arithmetic operators only work with integral types 
      % Typ.isIntOrIntVector typ
      % Check invariance for instructions
      intrinsic_funs , system , module_info , fdef_info , block |-i id = bop (int sz) value1 value2
      -------------------------------------------------------------------------------------- :: wf_insn_bop
      intrinsic_funs , system , module_info, fdef_info , block |- id = bop (int sz) value1 value2

      % Check typs
      system |- value1 : floating_point
      system |- value2 : floating_point
      % Check that integer arithmetic operators are only used with integral operands.
      % Integer arithmetic operators only work with integral types 
      % Typ.isIntOrIntVector typ
      % Check invariance for instructions
      intrinsic_funs , system , module_info , fdef_info , block |-i id = fbop floating_point value1 value2
      ----------------------------------------------------------------------------------------------------- :: wf_insn_fbop
      intrinsic_funs , system , module_info, fdef_info , block |- id = fbop floating_point value1 value2

      % Check typs
      system |- value : typ
      </ system |- constj : int sz /\ sz = 32 // j />
      % Check indexs
      getSubTypFromConstIdxs </ constj // j /> typ = typ'
      % Check invariance for instructions
      intrinsic_funs , system , module_info , fdef_info , block |-i id = extractvalue typ value </ constj // j />
      -------------------------------------------------------------------------------------- :: wf_insn_extractvalue
      intrinsic_funs , system , module_info , fdef_info , block |- id = extractvalue typ value </ constj // j />

      % Check typs
      system |- value : typ
      system |- value' : typ'
      </ system |- constj : int sz /\ sz = 32 // j />
      % Check indexs
      getSubTypFromConstIdxs </ constj // j /> typ = typ'
      % Check invariance for instructions
      intrinsic_funs , system , module_info , fdef_info , block |-i id = insertvalue typ value typ' value' </ constj // j />
      -------------------------------------------------------------------------------------- :: wf_insn_insertvalue
      intrinsic_funs , system , module_info , fdef_info , block |- id = insertvalue typ value typ' value' </ constj // j />

      % Allocation instruction pointer not in the generic address space!
      %
      % Alloca array size must be i32
      system |- value : int sz /\ sz = 32
      %
      % Cannot allocate unsized type"
      system |- typ
      Typ.isSized typ
      % Check invariance for instructions
      intrinsic_funs , system , module_info , fdef_info , block |-i id = malloc typ value align 
      -------------------------------------------------------------------------------------- :: wf_insn_malloc
      intrinsic_funs , system , module_info , fdef_info , block |- id = malloc typ value align 

      % Check typs
      system |- value : typ*
      % Check invariance for instructions
      intrinsic_funs , system , module_info , fdef_info , block |-i id = free (typ*) value
      -------------------------------------------------------------------------------------- :: wf_insn_free
      intrinsic_funs , system , module_info , fdef_info , block |- id = free (typ*) value

      % Allocation instruction pointer not in the generic address space!
      %
      % Alloca array size must be i32
      system |- value : int sz /\ sz = 32
      %
      % Cannot allocate unsized type"
      system |- typ
      Typ.isSized typ
      % Check invariance for instructions
      intrinsic_funs , system , module_info , fdef_info , block |-i id = alloca typ value align 
      -------------------------------------------------------------------------------------- :: wf_insn_alloca
      intrinsic_funs , system , module_info , fdef_info , block |- id = alloca typ value align 

      % Load operand must be a pointer.
      % Load result type does not match pointer operand type!
      system |- value1 : typ1*
      % Check invariance for instructions
      intrinsic_funs , system , module_info , fdef_info , block |-i id = load (typ1*) value1 align
      ---------------------------------------------------------------------------------------------- :: wf_insn_load
      intrinsic_funs , system , module_info , fdef_info , block |- id = load (typ1*) value1 align		

      % Store operand must be a pointer.
      % Stored value type does not match pointer operand type!
      system |- value1 : typ
      system |- value2 : typ*
      % Check invariance for instructions
      intrinsic_funs , system , module_info , fdef_info , block |-i id = store typ value1 value2 align
      ------------------------------------------------------------------------------------------------- :: wf_insn_store
      intrinsic_funs , system , module_info , fdef_info , block |- id = store typ value1 value2 align

      % Check typs
      system |- value : typ*
      </ system |- valuej : int sz /\ sz = 32 // j />
      % Check indexs
      getGEPTyp </ valuej // j /> (typ*) = typ'
      % Check invariance for instructions
      intrinsic_funs , system , module_info , fdef_info , block |-i id = getelementptr inbounds (typ*) value </ valuej // j />
      ---------------------------------------------------------------------------------------- :: wf_insn_gep
      intrinsic_funs , system , module_info , fdef_info , block |- id = getelementptr inbounds (typ*) value </ valuej // j />


      intrinsic_funs , system , module_info , fdef_info , block |-trunc id = truncop typ1 value1 to typ2
      ---------------------------------------------------------------------------------------------------- :: wf_insn_trunc
      intrinsic_funs , system , module_info , fdef_info , block |- id = truncop typ1 value1 to typ2

      intrinsic_funs , system , module_info , fdef_info , block |-ext id = extop typ1 value1 to typ2
      ---------------------------------------------------------------------------------------------------- :: wf_insn_ext
      intrinsic_funs , system , module_info , fdef_info , block |- id = extop typ1 value1 to typ2


      intrinsic_funs , system , module_info , fdef_info , block |-cast id = castop typ1 value1 to typ2
      ---------------------------------------------------------------------------------------------------- :: wf_insn_cast
      intrinsic_funs , system , module_info , fdef_info , block |- id = castop typ1 value1 to typ2


      % Check typs
      system |- value1 : typ
      system |- value2 : typ
      % types can only be int, vector or ptr
      Typ.isIntOrIntVector typ \/ isPointerTyp typ
      % Check invariance for instructions
      intrinsic_funs , system , module_info , fdef_info , block |-i id = icmp cond typ value1 value2
      --------------------------------------------------------------------------------------------------- :: wf_insn_icmp
      intrinsic_funs , system , module_info , fdef_info , block |- id = icmp cond typ value1 value2


      % Check typs
      system |- value1 : floating_point
      system |- value2 : floating_point
      % Check invariance for instructions
      intrinsic_funs , system , module_info , fdef_info , block |-i id = fcmp fcond floating_point value1 value2
      ------------------------------------------------------------------------------------------------------- :: wf_insn_fcmp
      intrinsic_funs , system , module_info , fdef_info , block |- id = fcmp fcond floating_point value1 value2


      % Check typs
      </ system |- valuej : typ // j />
      % LLVM::visitInstruction checks that non-phi nodes are not self referential 
      getPhiNodeOperands (id = phi typ </ [ valuej , lj ] // j />) = ids'
      ids' <-> </ id'i // i />
      </ (not id == id'i) \/ (not (isReachableFromEntry fdef_info block)) // i />
      % The following properties 1-4 are checked in visitBlock by LLVM, but we check them here. 
      % 1 Ensure that PHI nodes have at least one entry! 
      {{ (PHINode.getNumIncomingValues ([[:user_syntax__phinode:(id = phi typ </ [ valuej , lj ] // j />)]]) > 0)%nat }}
      % 2 PHINode should have one entry for each predecessor of its parent basic block!
      predOfBlock block usedef_block = blocks
      {{ PHINode.getNumIncomingValues ([[:user_syntax__phinode:(id = phi typ </ [ valuej , lj ] // j />)]]) = length [[blocks]]}}
      % 3 Check to make sure that the predecessors and PHI node entries are matched up.
      getLabelsFromBlocks blocks = ls1
      getLabelsFromPhiNode (id = phi typ </ [ valuej , lj ] // j />) =ls2
      ls1 == ls2
      % 4 Check to make sure that if there is more than one entry for a
      %   particular basic block in this PHI node, that the incoming values are
      %   all identical.
      checkIdenticalIncomingValues (id = phi typ </ [ valuej , lj ] // j />)
      % Check that all of the operands of the PHI node have the same type as the result.
      </ lookupTypViaIDFromSystem system idj = typ // j />
      %
      % All other PHI node constraints are checked in the visitBasicBlock method.
      %
      % Check labels
      </ lookupBlockViaLabelFromSystem system lj = blockj /\ blockInFdef blockj fdef // j />
      % Check invariance for instructions
      intrinsic_funs , system , (module, usedef_id, usedef_block) , (fdef, dt) , block |-i id = phi typ </ [ valuej , lj ] // j />
      ------------------------------------------------------------------------------------------------ :: wf_insn_phi
      intrinsic_funs , system , (module, usedef_id, usedef_block), (fdef, dt) , block |- id = phi typ </ [ valuej , lj ] // j />
			        

      % Check typs
      system |- value0 : int sz /\ sz = 1
      system |- value1 : typ
      system |- value2 : typ
      % Check invariance for instructions
      intrinsic_funs , system , module_info , fdef_info , block |-i id = select value0 typ value1 value2
      ------------------------------------------------------------------------------------------------------- :: wf_insn_select
      intrinsic_funs , system , module_info , fdef_info , block |- id = select value0 typ value1 value2

      % LLVM checks that 
      %   "Called function must be a pointer!"
      %   "Called function has to be a pointer to function type!"
      system |- value0 : typ1
      isFunctionPointerTyp typ1
      % Verify that the correct number of arguments are being passed 
      % Correct number of arguments passed to called function! 
      {{ FunctionType.getNumParams [[:user_syntax__typ:typ1]] = Some (length [[params]]) }}
      % Verify that all arguments to the call match the function type... 
      params <-> </ (typj' valuej'') // j />
      typ1 = typ0 ( </ typj' // j /> )
      </ system |- valuej'' : typj' // j />
      % instructions returning void cannot have a name
      typ0 =t= void implies noret = yes
      % Will Verify call attributes later... 
      %
      % Verify that there's no metadata unless it's a direct call to an intrinsic. 
      %   Open soooon...
      %  
      % Check invariance for instructions
      intrinsic_funs , system , module_info , fdef_info , block |-i id = noret tailc call typ0 value0 params
      -------------------------------------------------------------------------------------------------- :: wf_insn_call
      intrinsic_funs , system , module_info , fdef_info , block |- id = noret tailc call typ0 value0 params

defns
Jwf_cmds :: '' ::=
      defn
      intrinsic_funs , system , module_info , fdef_info , block |- cmds :: :: wf_cmds :: ''
      {{ com [[cmds]] is well-formed w.r.t. [[block]] [[fdef_info]] in [[module_info]] [[system]] }} by

      --------------------------------------- :: wf_cmds_nil
      intrinsic_funs , system , module_info , fdef_info , block |- []

      intrinsic_funs , system , module_info , fdef_info , block |- cmd
      intrinsic_funs , system , module_info , fdef_info , block |- cmds
      ------------------------------------------------------------------------------ :: wf_cmds_cons
      intrinsic_funs , system , module_info , fdef_info , block |- cmds , cmd
 
defns
Jwf_phinodes :: '' ::=
      defn
      intrinsic_funs , system , module_info , fdef_info , block |- phinodes :: :: wf_phinodes :: ''
      {{ com [[phinodes]] is well-formed w.r.t. [[block]] [[fdef_info]] in [[module_info]] [[system]] }} by

      --------------------------------------- :: wf_phinodes_nil
      intrinsic_funs , system , module_info , fdef_info , block |- []

      intrinsic_funs , system , module_info , fdef_info , block |- phinode
      intrinsic_funs , system , module_info , fdef_info , block |- phinodes
      ------------------------------------------------------------------------------ :: wf_phinodes_cons
      intrinsic_funs , system , module_info , fdef_info , block |- phinodes , phinode

defns
Jwf_block :: '' ::=
      defn
      intrinsic_funs , system , module_info , fdef_info |- block :: :: wf_block :: '' 
      {{ com [[block]] is well-formed w.r.t. [[fdef_info]] in [[module_info]] [[system]] }} by

      % Inclusion
      (l phinodes cmds terminator) in system , module_info , fdef_info
      % Ensure that the PHI nodes are all grouped together at the top of the block.
      % This can be tested by checking whether the instruction before this is
      % either nonexistent (because this is begin()) or is a PHI node.  If not,
      % then there is some other instruction before a PHI.
      % LLVM checks this only in visitPHINode, we pull it up to block checking. 
      % It is easier than the one in LLVM::visitPHINode.
      %
      % Ensure that basic blocks have terminators! 
      %
      % We moved some assertions to visitPhiNode 
      %
      % Check instruction
      intrinsic_funs , system , module_info , fdef_info , block |- phinodes
      intrinsic_funs , system , module_info , fdef_info , block |- cmds
      intrinsic_funs , system , module_info , fdef_info , block |- terminator
      ----------------------------------------------------------------------- :: wf_block_intro
      intrinsic_funs , system , module_info , fdef_info |- l phinodes cmds terminator

defns
Jwf_blocks :: '' ::=
      defn
      intrinsic_funs , system , module_info , fdef_info |- blocks :: :: wf_blocks :: ''
      {{ com [[blocks]] is well-formed w.r.t. [[fdef_info]] in [[module_info]] [[system]] }} by

      --------------------------------------- :: wf_blocks_nil
      intrinsic_funs , system , module_info , fdef_info |- []

      intrinsic_funs , system , module_info , fdef_info |- block
      intrinsic_funs , system , module_info , fdef_info |- blocks
      ------------------------------------------------------------------------ :: wf_blocks_cons
      intrinsic_funs , system , module_info , fdef_info |- blocks , block
 

defns
Jwf_fdec :: '' ::=
      defn
      intrinsic_funs , system , module_info |-f fdec :: :: wf_fdec :: ''
      {{ com [[fdec]] is well-formed w.r.t. [[module_info]] [[system]] }} by

      % Inclusion
      (declare ( typ id ( args ) )) in system , (module, usedef_id, usedef_block)
      % Check function arguments.
      args <-> </ (typj idj) // j />
      </ system |- typj // j />      
      % Functions may not have common linkage 
      %
      % Formal arguments must match # of arguments for function type! 
      %
      % Functions cannot return aggregate values
      isFirstClassTyp typ \/ typ =t= void
      % "Invalid struct return type!" 
      %
      % Attributes after last parameter! 
      %
      % Check function attributes. 
      %
      % Check that this function meets the restrictions on this calling convention. 
      %
      % Function may not return metadata unless it's an intrinsic.
      %
      % Check that the argument values match the function type for this function... 
        % Argument value does not match function argument type! 
        % Function arguments must have first-class types! 
        % Function takes metadata but isn't an intrinsic 
      %
      % Verify that this function (which has a body) is not named "llvm.*".  It
      % is not legal to define intrinsics. 
      %
      % Check invalid linkage type for function declaration 
      -------------------------------------------------------------------------------------------------- :: wf_fdec_intro
      intrinsic_funs , system , (module, usedef_id, usedef_block) |-f declare ( typ id ( args ) )

defns
Jwf_fdef :: '' ::=
      defn
      intrinsic_funs , system , module_info |-f fdef :: :: wf_fdef :: ''
      {{ com [[fdef]] is well-formed w.r.t. [[module_info]] [[system]] }} by

      % Inclusion
      (define fheader { blocks } ) in system , (module, usedef_id, usedef_block)
      % Check function arguments.
      args <-> </ (typj idj) // j />
      </ system |- typj // j />      
      % Functions may not have common linkage 
      %
      % Formal arguments must match # of arguments for function type! 
      % 
      % Functions cannot return aggregate values
      isFirstClassTyp typ \/ typ =t= void
      %
      % "Invalid struct return type!" 
      %
      % Attributes after last parameter! 
      %
      % Check function attributes. 
      %
      % Check that this function meets the restrictions on this calling convention. 
      %
      % Function may not return metadata unless it's an intrinsic 
      %
      % Check that the argument values match the function type for this function... 
        % Argument value does not match function argument type! 
        % Function arguments must have first-class types! 
        % Function takes metadata but isn't an intrinsic 
      %
      % Verify that this function (which has a body) is not named "llvm.*".  It
      % is not legal to define intrinsics. 
      % 
      % Check the entry node 
      % Entry block to function must not have predecessors! 
      getEntryOfFdef (define fheader { blocks }) = block
      predOfBlock block usedef_block = blocks'
      {{ length [[blocks']] = 0%nat }}
      % Compute DT 
      {{ genDominatorTree [[:user_syntax__fdef:define fheader { blocks }]] [[module]] = [[dt]] }}
      % Checking function body
      intrinsic_funs , system , (module, usedef_id, usedef_block) , (define fheader { blocks }, dt) |- blocks
      ------------------------------------------------------------------------------------------------- :: wf_fdef_intro
      intrinsic_funs , system , (module, usedef_id, usedef_block) |-f define fheader { blocks }

defns
Jwf_g :: '' ::=     % visitGlobalValue
      defn
      intrinsic_funs , system , module_info |-g product :: :: wf_g :: ''
      {{ com common cases that [[product]] is well-formed w.r.t. [[module_info]] [[system]]}} by 

      -------------------------------------------------- :: wf_g_intro
      intrinsic_funs , system , module_info |-g product
      
defns
Jwf_gvar :: '' ::=  % visitGlobalVariable
      defn
      intrinsic_funs , system , module_info |-v gvar :: :: wf_gvar :: ''
      {{ com [[gvar]] is well-formed w.r.t. [[module_info]] [[system]]}} by 

      system |- const : typ
      ------------------------------------------------------------------------- :: wf_v_intro
      intrinsic_funs , system , module_info |-v id = gvar_spec typ const align

defns
Jwf_prod :: '' ::=
      defn
      intrinsic_funs , system , module_info |- product :: :: wf_prod :: ''
      {{ com [[product]] is well-formed w.r.t. [[module_info]] [[system]]}} by 

      intrinsic_funs , system , module_info |-g gvar
      intrinsic_funs , system , module_info |-v gvar      
      ------------------------------------------------ :: wf_prod_global_var
      intrinsic_funs , system , module_info |- gvar

      intrinsic_funs , system , module_info |-g fdec
      intrinsic_funs , system , module_info |-f fdec
      ---------------------------------------------- :: wf_prod_function_dec
      intrinsic_funs , system , module_info |- fdec

      intrinsic_funs , system , module_info |-g fdef
      intrinsic_funs , system , module_info |-f fdef
      ---------------------------------------------- :: wf_prod_function_def
      intrinsic_funs , system , module_info |- fdef   

      % -------------------------------------- :: wf_prod_namedtype
      % intrinsic_funs , system , module_info |- namedt     

defns
Jwf_prods :: '' ::=
      defn
      intrinsic_funs , system , module_info |- products :: :: wf_prods :: ''
      {{ com [[products]] is well-formed w.r.t. [[module_info]] [[system]]}} by 

      ------------------------------------------- :: wf_prods_nil
      intrinsic_funs , system , module_info |- []

      intrinsic_funs , system , module_info |- products
      intrinsic_funs , system , module_info |- product
      ---------------------------------------------------------------- :: wf_prods_cons
      intrinsic_funs , system , module_info |- products , product

defns
Jwf_namedts :: '' ::=
      defn
      |- namedts :: :: wf_namedts :: ''
      {{ com [[namedts]] is well-formed }} by

      %% FIXME: Check circularity
      -------------------------------- :: wf_namedts_intro
      |- namedts 

defns
Jwf_module :: '' ::=
      defn
      intrinsic_funs , system |- module :: :: wf_module :: ''
      {{ com [[module]] is well-formed w.r.t. [[system]] }} by

      %%
      |- namedts
      %%
      (layouts namedts products) in system
      {{ genIdUseDef [[:user_syntax__module:(layouts namedts products)]] = [[usedef_id]] }}
      {{ genBlockUseDef [[:user_syntax__module:(layouts namedts products)]] = [[usedef_block]] }}
      intrinsic_funs , system , ((layouts namedts products), usedef_id, usedef_block) |- products
      ------------------------------------------------------------------------------------ :: wf_module_intro
      intrinsic_funs , system |- (layouts namedts products)

defns
Jwf_modules :: '' ::=
      defn
      intrinsic_funs , system |- modules :: :: wf_modules :: ''
      {{ com [[modules]] is well-formed w.r.t. [[system]] }} by  

      ----------------------------- :: wf_modules_nil
      intrinsic_funs , system |- []

      intrinsic_funs , system |- module 
      intrinsic_funs , system |- modules
      ----------------------------------------------- :: wf_modules_cons
      intrinsic_funs, system |- modules , module
 
defns
Jwf_system :: '' ::=
      defn
      intrinsic_funs |- system :: :: wf_system :: ''
      {{ com [[system]] is well-formed }} by

      intrinsic_funs , modules |- modules
      uniqSystem modules
      ------------------------------ :: wf_system_intro
      intrinsic_funs |- modules
     
embed
{{coq

End LLVMwf.

}}

embed 
{{ coq
(*
*** Local Variables: ***
*** coq-prog-name: "coqtop" ***
*** coq-prog-args: ("-emacs-U" "-I" "./monads" "-I" "./ott" "-I" "./compcert" "-I" "/home/jianzhou/SVN/provers/metalib/branches/metatheory_8.3/") ***
*** End: ***
*)
}}

