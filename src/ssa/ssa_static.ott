% Static Semantics of Static Single Assignment(SSA)
defns
Jwf_typ :: '' ::=
      defn
      |- typ :: :: wf_typ :: '' {{ com [[typ]] is well-formed }} by  

      -------------------- :: wf_typ_int
      |- int INT

      % -------------------- :: wf_typ_float
      % |- float

      % -------------------- :: wf_typ_double
      % |- double

      % -------------------- :: wf_typ_fp128
      % |- fp128

      % -------------------- :: wf_typ_void
      % |- void

      % -------------------- :: wf_typ_label
      % |- label

      -------------------- :: wf_typ_metadate
      |- metadata

      % -------------------- :: wf_typ_opaque
      % |- opaque

      isValidReturnTyp typ     
      |- typ
      </ isValidArgumentTyp typj // j />
      </ |- typj // j /> 
      -------------------------------------------------- :: wf_typ_function
      |- typ ( </ typj // j /> ) 
     
      % </ isValidElementTyp typj // j />
      % </ |- typj // j /> 
      % -------------------------------------------------- :: wf_typ_structure
      % |- { </ typj // j /> }

      % |- typ
      % isValidElementTyp typ
      % ------------------- :: wf_typ_array
      % |- [ INT * typ ]

      % |- typ
      % isValidElementTyp typ
      % ------------------- :: wf_typ_pointer
      % |- typ * 

      % |- typ
      % isValidElementTyp typ
      % ------------------- :: wf_typ_vector
      % |- < INT * typ >


defns
Jwf_ssa :: '' ::=
      defn
      intrinsic_funs , system , module_info , fdef_info , block , insn |- insn' :: :: wf_ssa :: ''
      {{ com [[insn']] is well-formed w.r.t [[insn]] [[block]] in [[fdef_info]] in [[module_info]] [[system]] }} by

      getInsnID insn' = id'
      lookupBlockViaIDFromFdef fdef id' = block'
      % Check that a definition dominates all of its uses *)
      %
      % PHI nodes are more difficult than other nodes because they actually
      % "use" the value in the predecessor basic blocks they correspond to. 
<<
      (isPhiNode insn) implies 
        (getLabelViaIDPhiNode insn id' = l'' /\ 
         lookupBlockViaLabelFromSystem system l'' = block'' /\ 
         (
          (blockDominates dt block' block'') \/ 
          (not (isReachableFromEntry (fdef, dt) block )) 
         ) 
        )
>>
      % if insn is not PhiNode, make sure that the definition comes before the use
      (notT isPhiNode insn) implies (insnDominates insn' insn \/ (not (isReachableFromEntry (fdef, dt) block)))
      ------------------------------------------------------------------------------------------------------------- :: wf_ssa_intro
      intrinsic_funs , system , module_info , (fdef, dt) , block , insn |- insn' 

defns
Jwf_operand :: '' ::=
      defn
      intrinsic_funs , system , module_info , fdef_info , block , insn |- id' :: :: wf_operand :: ''
      {{ com [[id']] is well-formed w.r.t [[insn]] [[block]] in [[fdef_info]] in [[module_info]] [[system]] }} by

      insn in system , (module, usedef_insn, usedef_block) , (fdef, dt) , block
      getInsnOperands insn = ids
      id' in ids
      lookupBindingViaIDFromSystem system id' = id_binding'
      % Check to make sure that only first-class-values are operands to instructions.
      getBindingTyp id_binding' = typ'     
      isFirstClassTyp typ'
      % Valid use of metadata pointer.
      (getPointerEltTyp typ' = typ'') implies (not typ'' == metadata)
      % Check to make sure that the "address of" an intrinsic function is never
      % taken, and referencing function exists in current module!
      (isBindingFdec id_binding' = fdec) implies (getFdecID fdec = id0 /\ (id0 notin intrinsic_funs \/ getCallName insn = id0) /\ fdec in module)
      % Referring to an argument in the current function
      (isBindingArg id_binding' = arg) implies (argInFdef arg fdef)
      % Referencing global in the current module
      % (isBindingG id_binding' = g) implies (g in module)
      %
      % Check when id_binding' is insn
      (isBindingInsn id_binding' = insn') implies (intrinsic_funs , system , module_info , fdef_info , block , insn |- insn')
      ----------------------------------------------------------------------------------------------------------------------- :: wf_operand_intro
      intrinsic_funs , system , (module, usedef_insn, usedef_block) , (fdef, dt) , block , insn |- id'

defns
Jwf_insn_base :: '' ::=
      defn
      intrinsic_funs , system , module_info , fdef_info , block |-i insn :: :: wf_insn_base :: '' 
      {{ com [[insn]] is well-formed w.r.t [[block]] in [[fdef_info]] in [[module_info]] [[system]] }} by  
      % Verifier::visitInstruction

      % Instruction must be embedded in basic block!
      insn in system , (module, usedef_insn, usedef_block) , (fdef, dt) , block
      % Check that non-phi nodes are not self referential in wf_insn_base::PhiNode
      %
      % Verify that if this is a terminator that it is at the end of the block in wf_block
      %
      % Check that void typed values don't have names
      % We dont need to check this in Ott
      %
      % Check that the return value of the instruction is either void or a legal value type.
      getInsnTyp insn = typ
      typ == void \/ isFirstClassTyp typ
      % Check that the instruction doesn't produce metadata or metadata*. Calls
      % all already checked against the callee type.
      (not typ == metadata) \/ isCallInsn insn 
      % Instructions may not produce pointer to metadata.
      (isPointerTyp typ) implies (getPointerEltTyp typ = typ' /\ (not typ' == metadata)) 
      % Check that all uses of the instruction, if they are instructions
      % themselves, actually have parent basic blocks.  If the use is not an
      % instruction, it is an error!
      % We should prove a lemma for this later.
      %
      % Check operands
      getInsnOperands insn = ids
      ids <-> </ idj // j />
      </ intrinsic_funs , system , module_info , fdef_info , block , insn |- idj // j />
      -------------------------------------------------------------------------------------- :: wf_insn_base_intro
      intrinsic_funs , system , (module, usedef_insn, usedef_block) , (fdef, dt) , block |-i insn

defns
Jwf_insn :: '' ::=
      defn
      intrinsic_funs , system , module_info , fdef_info , block |- insn :: :: wf_insn :: '' 
      {{ com [[insn]] is well-formed w.r.t [[block]] in [[fdef_info]] in [[module_info]] [[system]] }} by  

      % Exactly one return value and it matches the return type. Good. 
      Function.getDefReturnType fdef = typ0
      typ == typ0 
      % Check invariance for instructions
      intrinsic_funs , system , module_info , (fdef, dt) , block |-i ret typ value
      ------------------------------------------------------ :: wf_insn_return
      intrinsic_funs , system , module_info , (fdef, dt) , block |- ret typ value

      % return instr that returns void in Function can be of void return type! 
      Function.getDefReturnType fdef = typ
      typ == void
      % Check invariance for instructions
      intrinsic_funs , system , module_info , (fdef, dt) , block |-i ret void
      ------------------------------------------------------ :: wf_insn_return_void
      intrinsic_funs , system , module_info , (fdef, dt) , block |- ret void

      % Check labels
      lookupBlockViaLabelFromSystem system l1 = block1
      blockInFdef block1 fdef
      lookupBlockViaLabelFromSystem system l2 = block2
      blockInFdef block2 fdef
      % Check invariance for instructions
      intrinsic_funs , system , module_info , (fdef, dt) , block |-i br typ value , l1 , l2
      -------------------------------------------------------------------------------------- :: wf_insn_br
      intrinsic_funs , system , (module, usedef_insn, usedef_block), (fdef, dt) , block |- br typ value , l1 , l2	

      % Check labels
      lookupBlockViaLabelFromSystem system l = block1
      blockInFdef block fdef
      % Check invariance for instructions
      intrinsic_funs , system , module_info , (fdef, dt) , block |-i br l
      -------------------------------------------------------------------------------------- :: wf_insn_br_uncond
      intrinsic_funs , system , (module, usedef_insn, usedef_block), (fdef, dt) , block |- br l		

      % intrinsic_funs , system , module_info , (fdef, dt) , block |-i id = invoke typ0 id0 list_param to l1 unwind l2
      % -------------------------------------------------------------------------------------- :: wf_insn_invoke
      % intrinsic_funs , system , (module, usedef_insn, usedef_block), fdef_info , block |- id = invoke typ0 id0 list_param to l1 unwind l2

      % LLVM checks that 
      %   "Called function must be a pointer!"
      %   "Called function is not pointer to function type!"
      %   We don't need to check this, but only ensure Call and FTy are valid
      CallSite.getCalledFunction (id = call typ0 id0 list_param) system = fdef1
      CallSite.getFdefTyp fdef1 = typ1
      % Verify that the correct number of arguments are being passed 
      % Correct number of arguments passed to called function! 
      FunctionType.getNumParams typ1 = INT1
      CallSite.arg_size fdef1 = INT2
      INT1 = INT2
      % Verify that all arguments to the call match the function type... 
      list_param <-> </ (typj'' valuej'') // j />
      typ1 = typ0 ( </ typj' // j /> )
      </ typj'' == typj' // j />
      % Will Verify call attributes later... 
      %
      % Verify that there's no metadata unless it's a direct call to an intrinsic. 
      %   Open soooon...
      %  
      % Check invariance for instructions
      intrinsic_funs , system , module_info , (fdef, dt) , block |-i id = call typ0 id0 list_param
      -------------------------------------------------------------------------------------- :: wf_insn_call
      intrinsic_funs , system , (module, usedef_insn, usedef_block), (fdef, dt) , block |- id = call typ0 id0 list_param

      % Check invariance for instructions
      intrinsic_funs , system , module_info , (fdef, dt) , block |-i unreachable
      -------------------------------------------------------------------------------------- :: wf_insn_unreachable
      intrinsic_funs , system , (module, usedef_insn, usedef_block), (fdef, dt) , block |- unreachable

      % "Both operands to a binary operator are of the same type"
      BinaryOperator.getFirstOperandType system (id = add typ value1 value2) = typ1
      BinaryOperator.getFirstOperandType system (id = add typ value1 value2) = typ2
      typ1 == typ2 
      % Check that integer arithmetic operators are only used with integral operands.
      % Integer arithmetic operators only work with integral types 
      Typ.isIntOrIntVector typ
      % Integer arithmetic operators must have same type for operands and result 
      typ == typ1
      % Check invariance for instructions
      intrinsic_funs , system , module_info , (fdef, dt) , block |-i id = add typ value1 value2
      -------------------------------------------------------------------------------------- :: wf_insn_add
      intrinsic_funs , system , (module, usedef_insn, usedef_block), (fdef, dt) , block |- id = add typ value1 value2

      % LLVM::visitInstruction checks that non-phi nodes are not self referential 
      getInsnUseDef usedef_insn (id = phi typ </ [ idj , lj ] // j />) = list_insn
      list_insn <-> </ insni // i />
      </ (not (id = phi typ </ [ idj , lj ] // j />) =id= insni) \/ (not (isReachableFromEntry fdef_info block)) // i />
      % The following properties 1-4 are checked in visitBlock by LLVM, but we check them here. 
      % 1 Ensure that PHI nodes have at least one entry! 
      PHINode.getNumIncomingValues (id = phi typ </ [ idj , lj ] // j />) = INT
      {{ [[INT]] >0 }}
      % 2 PHINode should have one entry for each predecessor of its parent basic block!
      predOfBlock block usedef_block = list_block
      {{ [[INT]] = length [[list_block]]}}
      % 3 Check to make sure that the predecessors and PHI node entries are matched up.
      getLabelsFromBlocks list_block = ls1
      getLabelsFromPhiNode (id = phi typ </ [ idj , lj ] // j />) = ls2
      ls1 == ls2
      % 4 Check to make sure that if there is more than one entry for a
      %   particular basic block in this PHI node, that the incoming values are
      %   all identical.
      checkIdenticalIncomingValues (id = phi typ </ [ idj , lj ] // j />)
      % Check that all of the operands of the PHI node have the same type as the result.
      </ lookupTypViaIDFromSystem system idj = typj /\ typj == typ // j />
      %
      % All other PHI node constraints are checked in the visitBasicBlock method.
      %
      % Check labels
      </ lookupBlockViaLabelFromSystem system lj = blockj /\ blockInFdef blockj fdef // j />
      % Check invariance for instructions
      intrinsic_funs , system , module_info , (fdef, dt) , block |-i id = phi typ </ [ idj , lj ] // j />
      -------------------------------------------------------------------------------------- :: wf_insn_phi
      intrinsic_funs , system , (module, usedef_insn, usedef_block), (fdef, dt) , block |- id = phi typ </ [ idj , lj ] // j />
			        
defns
Jwf_list_insn :: '' ::=
      defn
      intrinsic_funs , system , module_info , fdef_info , block |- list_insn :: :: wf_list_insn :: ''
      {{ com [[list_insn]] is well-formed w.r.t. [[block]] [[fdef_info]] in [[module_info]] [[system]] }} by

      --------------------------------------- :: wf_list_insn_nil
      intrinsic_funs , system , module_info , fdef_info , block |- []

      intrinsic_funs , system , module_info , fdef_info , block |- insn
      intrinsic_funs , system , module_info , fdef_info , block |- list_insn
      ------------------------------------------------------- :: wf_list_insn_cons
      intrinsic_funs , system , module_info , fdef_info , block |- list_insn , insn
 
defns
Jwf_block :: '' ::=
      defn
      intrinsic_funs , system , module_info , fdef_info |- block :: :: wf_block :: '' 
      {{ com [[block]] is well-formed w.r.t. [[fdef_info]] in [[module_info]] [[system]] }} by

      % Inclusion
      (l list_insn) in system , module_info , fdef_info
      % Ensure that the PHI nodes are all grouped together at the top of the block.
      % This can be tested by checking whether the instruction before this is
      % either nonexistent (because this is begin()) or is a PHI node.  If not,
      % then there is some other instruction before a PHI.
      % LLVM checks this only in visitPHINode, we pull it up to block checking. 
      % It is easier than the one in LLVM::visitPHINode.
      blockChecksTerminatorInsn (l list_insn)
      % Ensure that basic blocks have terminators! 
      blockStartsWithPhiNode (l list_insn)
      % We moved some assertions to visitPhiNode 
      %
      % Check instructions
      intrinsic_funs , system , module_info , fdef_info , block |- list_insn
      ----------------------------------------------------------------------- :: wf_block_intro
      intrinsic_funs , system , module_info , fdef_info |- l list_insn

defns
Jwf_list_block :: '' ::=
      defn
      intrinsic_funs , system , module_info , fdef_info |- list_block :: :: wf_list_block :: ''
      {{ com [[list_block]] is well-formed w.r.t. [[fdef_info]] in [[module_info]] [[system]] }} by

      --------------------------------------- :: wf_list_block_nil
      intrinsic_funs , system , module_info , fdef_info |- []

      intrinsic_funs , system , module_info , fdef_info |- block
      intrinsic_funs , system , module_info , fdef_info |- list_block
      ------------------------------------------------------- :: wf_list_block_cons
      intrinsic_funs , system , module_info , fdef_info |- list_block , block
 

defns
Jwf_fdec :: '' ::=
      defn
      intrinsic_funs , system , module_info |-f fdec :: :: wf_fdec :: ''
      {{ com [[fdec]] is well-formed w.r.t. [[module_info]] [[system]] }} by

      % Inclusion
      (declare ( typ id ( list_arg ) )) in system , (module, usedef_insn, usedef_block)
      % Check function arguments.
      list_arg <-> </ (typj idj) // j />
      </ |- typj // j />      
      % Functions may not have common linkage 
      %
      % Formal arguments must match # of arguments for function type! 
      %
      % Functions cannot return aggregate values
      isFirstClassTyp typ \/ typ == void
      % "Invalid struct return type!" 
      %
      % Attributes after last parameter! 
      %
      % Check function attributes. 
      %
      % Check that this function meets the restrictions on this calling convention. 
      %
      % Function may not return metadata unless it's an intrinsic.
      %
      % Check that the argument values match the function type for this function... 
        % Argument value does not match function argument type! 
        % Function arguments must have first-class types! 
        % Function takes metadata but isn't an intrinsic 
      %
      % Verify that this function (which has a body) is not named "llvm.*".  It
      % is not legal to define intrinsics. 
      %
      % Check invalid linkage type for function declaration 
      ------------------------------------------------------ :: wf_fdec_intro
      intrinsic_funs , system , (module, usedef_insn, usedef_block) |-f declare ( typ id ( list_arg ) )

defns
Jwf_fdef :: '' ::=
      defn
      intrinsic_funs , system , module_info |-f fdef :: :: wf_fdef :: ''
      {{ com [[fdef]] is well-formed w.r.t. [[module_info]] [[system]] }} by

      % Inclusion
      (define fheader { list_block} ) in system , (module, usedef_insn, usedef_block)
      % Check function arguments.
      list_arg <-> </ (typj idj) // j />
      </ |- typj // j />      
      % Functions may not have common linkage 
      %
      % Formal arguments must match # of arguments for function type! 
      % 
      % Functions cannot return aggregate values
      isFirstClassTyp typ \/ typ == void
      %
      % "Invalid struct return type!" 
      %
      % Attributes after last parameter! 
      %
      % Check function attributes. 
      %
      % Check that this function meets the restrictions on this calling convention. 
      %
      % Function may not return metadata unless it's an intrinsic 
      %
      % Check that the argument values match the function type for this function... 
        % Argument value does not match function argument type! 
        % Function arguments must have first-class types! 
        % Function takes metadata but isn't an intrinsic 
      %
      % Verify that this function (which has a body) is not named "llvm.*".  It
      % is not legal to define intrinsics. 
      % 
      % Check the entry node 
      % Entry block to function must not have predecessors! 
      getEntryOfFdef (define fheader { list_block }) = block
      predOfBlock block usedef_block = list_block'
      {{ length [[list_block']] = 0 }}
      % Compute DT 
      {{ genDominatorTree [[:user_syntax__fdef:define fheader { list_block }]] [[module]] = [[dt]] }}
      % Checking function body
      intrinsic_funs , system , (module, usedef_insn, usedef_block) , (define fheader { list_block }, dt) |- list_block      
      ------------------------------------------------------ :: wf_fdef_intro
      intrinsic_funs , system , (module, usedef_insn, usedef_block) |-f define fheader { list_block }

defns
Jwf_prod :: '' ::=
      defn
      intrinsic_funs , system , module_info |- product :: :: wf_prod :: ''
      {{ com [[product]] is well-formed w.r.t. [[module_info]] [[system]]}} by 

      % ----------------------------- :: wf_prod_global_var
      % intrinsic_funs , system , module_info |- g

      intrinsic_funs , system , module_info |-f fdec
      ----------------------------- :: wf_prod_function_dec
      intrinsic_funs , system , module_info |- fdec

      intrinsic_funs , system , module_info |-f fdef
      ----------------------------- :: wf_prod_function_def
      intrinsic_funs , system , module_info |- fdef   

      % -------------------------------------- :: wf_prod_namedtype
      % intrinsic_funs , system , module_info |- namedt     

defns
Jwf_prods :: '' ::=
      defn
      intrinsic_funs , system , module_info |- list_product :: :: wf_prods :: ''
      {{ com [[list_product]] is well-formed w.r.t. [[module_info]] [[system]]}} by 

      --------------------------- :: wf_prods_nil
      intrinsic_funs , system , module_info |- []

      intrinsic_funs , system , module_info |- list_product
      intrinsic_funs , system , module_info |- product
      ------------------------------------------- :: wf_prods_cons
      intrinsic_funs , system , module_info |- list_product , product

defns
Jwf_module :: '' ::=
      defn
      intrinsic_funs , system |- module :: :: wf_module :: ''
      {{ com [[module]] is well-formed w.r.t. [[system]] }} by

      list_product in system
      {{ genInsnUseDef [[:user_syntax__module:list_product]] = [[usedef_insn]] }}
      {{ genBlockUseDef [[:user_syntax__module:list_product]] = [[usedef_block]] }}
      intrinsic_funs , system , (list_product, usedef_insn, usedef_block) |- list_product
      ----------------------------------------------------- :: wf_module_intro
      intrinsic_funs , system |- list_product

defns
Jwf_list_module :: '' ::=
      defn
      intrinsic_funs , system |- list_module :: :: wf_list_module :: ''
      {{ com [[list_module]] is well-formed w.r.t. [[system]] }} by  

      ------------------------ :: wf_list_module_nil
      intrinsic_funs , system |- []

      intrinsic_funs , system |- module 
      intrinsic_funs , system |- list_module
      ---------------------------------- :: wf_list_module_cons
      intrinsic_funs, system |- list_module , module
 
defns
Jwf_system :: '' ::=
      defn
      intrinsic_funs |- system :: :: wf_system :: ''
      {{ com [[system]] is well-formed }} by

      intrinsic_funs , list_module |- list_module
      uniqSystem list_module
      ------------------------------ :: wf_system_intro
      intrinsic_funs |- list_module 
     

