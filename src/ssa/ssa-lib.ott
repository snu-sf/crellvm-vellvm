
% Supporting Defs of Static Single Assignment(SSA)


% isValidReturnType - Return true if the specified type is valid as a return type. 
% lib/VMCore/Type
defns
isNotValidReturnType_def :: '' ::=
      defn
      isNotValidReturnType typ :: :: isNotValidReturnType :: '' {{ com [[typ]] isnt a valid return type }} by  
      
      --------------------------------- :: isNotValidReturnType_label
      isNotValidReturnType label


      --------------------------------- :: isNotValidReturnType_metadata
      isNotValidReturnType metadata      

defns
isValidReturnType_def :: '' ::=
      defn
      isValidReturnType typ :: :: isValidReturnType :: '' {{ com [[typ]] is a valid return type }} by  

      not isNotValidReturnType typ
      --------------------------------- :: isValidReturnType_intro
      isValidReturnType typ

% isFirstClassType - Return true if the type is "first class", meaning it is a valid 
% type for a Value. lib/VMCore/Type 
defns
isNotFirstClassType_def :: '' ::=
      defn
      isNotFirstClassType typ :: :: isNotFirstClassType :: '' {{ com [[typ]] isnt a first class type }} by

      ---------------------------------- :: isNotFirstClassType_void
      isNotFirstClassType void

      ---------------------------------- :: isNotFirstClassType_opaque
      isNotFirstClassType opaque

      --------------------------------------------- :: isNotFirstClassType_function
      isNotFirstClassType typ ( </ typj // j /> )

defns
isFirstClassType_def :: '' ::=
      defn
      isFirstClassType typ :: :: isFirstClassType :: '' {{ com [[typ]] is a first class type }} by

      not isNotFirstClassType typ
      ----------------------------------- :: isFirstClassType_intro
      isFirstClassType typ

% isValidArgumentType - Return true if the specified type is valid as an
% argument type. lib/VMCore/Type.cpp
defns
isValidArgumentType_def :: '' ::=
      defn
      isValidArgumentType typ :: :: isValidArgumentType :: '' {{ com [[typ]] is a valid argument type }} by
 
      ----------------------------------- :: isValidArgumentType_opaque
      isValidArgumentType opaque

      isFirstClassType typ
      ----------------------------------- :: isValidArgumentType_firstclass
      isValidArgumentType typ

defns 
isNotValidElementType_def :: '' ::=
      defn
      isNotValidElementType typ :: :: isNotValidElementType :: '' {{ com [[typ]] isnt a valid elment type }} by

      ----------------------------------- :: isNotValidElementType_void
      isNotValidElementType void

      ----------------------------------- :: isNotValidElementType_label
      isNotValidElementType label
 
      ----------------------------------- :: isNotValidElementType_metadata
      isNotValidElementType metadata

      --------------------------------------------- :: isNotValidElementType_function
      isNotValidElementType typ ( </ typj // j /> )

defns 
isValidElementType_def :: '' ::=
      defn
      isValidElementType typ :: :: isValidElementType :: '' {{ com [[typ]] is a valid elment type }} by

      not isNotValidElementType typ
      ----------------------------------- :: isValidElementType_intro
      isValidElementType typ


defns
getReturnType_def :: '' ::=
      defn
      getReturnType fdef = typ :: :: getReturnType :: '' 
      {{ com [[fdef]]'s return type is [[typ]] }} by

      ----------------------------------------------------------------- :: def
      getReturnType (define (typ ident (argl)) { blockl }) = typ


defns
typeEq_def :: '' ::=
       defn
       typ == typ' :: :: typeEq :: ''
       {{ com check if [[typ]] equals to [[typ']] }} by

       N == N'
       ------------------------- :: typeEq_int
       int N == int N'

       ------------------------- :: typeEq_float
       float == float

       ------------------------- :: typeEq_double
       double == double

       ------------------------- :: typeEq_fp128
       fp128 == fp128

       ------------------------- :: typeEq_void       
       void == void

       ------------------------- :: typeEq_label
       label == label

       ------------------------- :: typeEq_metadata
       metadata == metadata

       ------------------------- :: typeEq_opaque
       opaque == opaque

       N == N'
       typ == typ'
       --------------------------------- :: typeEq_array
       [ N * typ ] == [ N' * typ' ] 

       N == N'
       typ == typ'
       --------------------------------- :: typeEq_vector
       < N * typ > == < N' * typ' > 

       typ == typ'
       --------------------------------- :: typeEq_pointer
       typ * == typ' *

       typ == typ'
       </ typj == typ'j // j />
       ----------------------------------------------------- :: typeEq_function
       typ ( </ typj // j /> ) == typ' ( </ typ'j // j /> )  

       </ typj == typ'j // j />
       ----------------------------------------------------- :: typeEq_structure
       { </ typj // j /> } == { </ typ'j // j /> }  

defns
isTerminatorInst_def :: '' ::=
      defn
      isTerminatorInst inst :: :: isTerminatorInst :: ''
      {{ com check is [[inst]] is a terminator inst }} by

      --------------------------------------- :: isTerminatorInst_return
      isTerminatorInst (ret typ value) 
      
      --------------------------------------- :: isTerminatorInst_return_void
      isTerminatorInst (ret void)

      --------------------------------------- :: isTerminatorInst_br
      isTerminatorInst (br value , ll1 , ll2)

      --------------------------------------- :: isTerminatorInst_br_uncond
      isTerminatorInst (br ll)

      ----------------------------------------------------------------- :: isTerminatorInst_switch
      isTerminatorInst (switch value , ll </ [ constj , llj ] // j />)

defns
instlEndsWithTerminatorInst_def :: '' ::=
      defn
      instlEndsWithTerminatorInst instl :: :: instlEndsWithTerminatorInst :: ''
      {{ com [[instl]] ends with terminator instruction }} by

      --------------------------------------- :: instlEndsWithTerminatorInst_nil
      instlEndsWithTerminatorInst nil

      isTerminatorInst inst
      ----------------------------------------------- :: instlEndsWithTerminatorInst_last
      instlEndsWithTerminatorInst nil , inst 
      
      instlEndsWithTerminatorInst instl
      ----------------------------------------------- :: instlEndsWithTerminatorInst_cons
      instlEndsWithTerminatorInst instl , inst

defns
instlDoesntContainTerminatorInst_def :: '' ::=
      defn
      instlDoesntContainTerminatorInst instl :: :: instlDoesntContainTerminatorInst :: ''
      {{ com [[instl]] doesnt contain terminator instruction }} by

      --------------------------------------- :: instlDoesntContainTerminatorInst_nil
      instlDoesntContainTerminatorInst nil

      instlDoesntContainTerminatorInst instl
      not isTerminatorInst inst
      ----------------------------------------------- :: instlDoesntContainTerminatorInst_cons
      instlDoesntContainTerminatorInst instl , inst

defns
instlRemovesLast_def :: '' ::=
      defn
      instlRemovesLast instl = instl' :: :: instlRemovesLast :: '' 
      {{ com [[inst']] is the list without the last element from [[instl]] }} by
 
      ----------------------------------------------- :: instlRemovesLast_nil
      instlRemovesLast nil = nil

      ----------------------------------------------- :: instlRemovesLast_remove
      instlRemovesLast (nil, inst) = nil

      instlRemovesLast (instl, inst1) = instl'
      ----------------------------------------------- :: instlRemovesLast_cons
      instlRemovesLast (instl, inst1, inst2) = (instl', inst2)

defns
instlChecksTerminatorInst_def :: '' ::=
      defn
      instlChecksTerminatorInst instl :: :: instlChecksTerminatorInst :: ''
      {{ com check if [[inst]] is well-formed }} by

      instlEndsWithTerminatorInst instl
      instlRemovesLast instl = instl'    
      instlDoesntContainTerminatorInst instl'
      ----------------------------------------------- :: instlChecksTerminatorInst_intro
      instlChecksTerminatorInst instl

defns
isPhiInst_def :: '' ::=
      defn
      isPhiInst inst :: :: isPhiInst :: ''
      {{ com check is [[inst]] is a phi inst }} by

      --------------------------------------- :: isPhiInst_intro
      isPhiInst (id = phi typ </ [ idj , llj ] // j />) 
      
defns
instlStartsWithPhiInst_def :: '' ::=
      defn
      instlStartsWithPhiInst instl :: :: instlStartsWithPhiInst :: ''
      {{ com [[instl]] starts with phi instruction }} by

      ----------------------------------------------- :: instlStartsWithPhiInst_nil
      instlStartsWithPhiInst nil

      instlStartsWithPhiInst instl      
      isPhiInst inst
      ---------------------------------------------------------------------- :: instlStartsWithPhiInst_cons_phi
      instlStartsWithPhiInst (instl, inst)
      
      instlDoesntContainPhiInst instl      
      not isPhiInst inst
      ---------------------------------------------------------------------- :: instlStartsWithPhiInst_cons_nophi
      instlStartsWithPhiInst (instl, inst)

      defn
      instlDoesntContainPhiInst instl :: :: instlDoesntContainPhiInst :: ''
      {{ com [[instl]] doesnt contain phi instruction }} by

      --------------------------------------- :: instlDoesntContainPhiInst_nil
      instlDoesntContainPhiInst nil

      instlDoesntContainPhiInst instl
      not isPhiInst inst 
      ----------------------------------------------------- :: instlDoesntContainPhiInst_cons
      instlDoesntContainPhiInst instl , inst
