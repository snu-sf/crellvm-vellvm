
% Supporting Defs of Static Single Assignment(SSA)


% isValidReturnType - Return true if the specified type is valid as a return type. 
% lib/VMCore/Type
defns
isNotValidReturnType_def :: '' ::=
      defn
      isNotValidReturnType typ :: :: isNotValidReturnType :: '' {{ com [[typ]] isnt a valid return type }} by  
      
      --------------------------------- :: isNotValidReturnType_label
      isNotValidReturnType label


      --------------------------------- :: isNotValidReturnType_metadata
      isNotValidReturnType metadata      

defns
isValidReturnType_def :: '' ::=
      defn
      isValidReturnType typ :: :: isValidReturnType :: '' {{ com [[typ]] is a valid return type }} by  

      not isNotValidReturnType typ
      --------------------------------- :: isValidReturnType_intro
      isValidReturnType typ

% isFirstClassType - Return true if the type is "first class", meaning it is a valid 
% type for a Value. lib/VMCore/Type 
defns
isNotFirstClassType_def :: '' ::=
      defn
      isNotFirstClassType typ :: :: isNotFirstClassType :: '' {{ com [[typ]] isnt a first class type }} by

      ---------------------------------- :: isNotFirstClassType_void
      isNotFirstClassType void

      ---------------------------------- :: isNotFirstClassType_opaque
      isNotFirstClassType opaque

      --------------------------------------------- :: isNotFirstClassType_function
      isNotFirstClassType typ ( </ typj // j /> )

defns
isFirstClassType_def :: '' ::=
      defn
      isFirstClassType typ :: :: isFirstClassType :: '' {{ com [[typ]] is a first class type }} by

      not isNotFirstClassType typ
      ----------------------------------- :: isFirstClassType_intro
      isFirstClassType typ

% isValidArgumentType - Return true if the specified type is valid as an
% argument type. lib/VMCore/Type.cpp
defns
isValidArgumentType_def :: '' ::=
      defn
      isValidArgumentType typ :: :: isValidArgumentType :: '' {{ com [[typ]] is a valid argument type }} by
 
      ----------------------------------- :: isValidArgumentType_opaque
      isValidArgumentType opaque

      isFirstClassType typ
      ----------------------------------- :: isValidArgumentType_firstclass
      isValidArgumentType typ

defns 
isNotValidElementType_def :: '' ::=
      defn
      isNotValidElementType typ :: :: isNotValidElementType :: '' {{ com [[typ]] isnt a valid elment type }} by

      ----------------------------------- :: isNotValidElementType_void
      isNotValidElementType void

      ----------------------------------- :: isNotValidElementType_label
      isNotValidElementType label
 
      ----------------------------------- :: isNotValidElementType_metadata
      isNotValidElementType metadata

      --------------------------------------------- :: isNotValidElementType_function
      isNotValidElementType typ ( </ typj // j /> )

defns 
isValidElementType_def :: '' ::=
      defn
      isValidElementType typ :: :: isValidElementType :: '' {{ com [[typ]] is a valid elment type }} by

      not isNotValidElementType typ
      ----------------------------------- :: isValidElementType_intro
      isValidElementType typ


defns
getReturnType_def :: '' ::=
      defn
      getReturnType fdef = typ :: :: getReturnType :: '' 
      {{ com [[fdef]]'s return type is [[typ]] }} by

      ----------------------------------------------------------------- :: getReturnType_intro
      getReturnType (define (typ ident (argl)) { blockl }) = typ


defns
typeEq_def :: '' ::=
       defn
       typ == typ' :: :: typeEq :: ''
       {{ com check if [[typ]] equals to [[typ']] }} by

       N == N'
       ------------------------- :: typeEq_int
       int N == int N'

       ------------------------- :: typeEq_float
       float == float

       ------------------------- :: typeEq_double
       double == double

       ------------------------- :: typeEq_fp128
       fp128 == fp128

       ------------------------- :: typeEq_void       
       void == void

       ------------------------- :: typeEq_label
       label == label

       ------------------------- :: typeEq_metadata
       metadata == metadata

       ------------------------- :: typeEq_opaque
       opaque == opaque

       N == N'
       typ == typ'
       --------------------------------- :: typeEq_array
       [ N * typ ] == [ N' * typ' ] 

       N == N'
       typ == typ'
       --------------------------------- :: typeEq_vector
       < N * typ > == < N' * typ' > 

       typ == typ'
       --------------------------------- :: typeEq_pointer
       typ * == typ' *

       typ == typ'
       </ typj == typ'j // j />
       ----------------------------------------------------- :: typeEq_function
       typ ( </ typj // j /> ) == typ' ( </ typ'j // j /> )  

       </ typj == typ'j // j />
       ----------------------------------------------------- :: typeEq_structure
       { </ typj // j /> } == { </ typ'j // j /> }  

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%       Check Terminator						 %
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

defns
isTerminatorInst_def :: '' ::=
      defn
      isTerminatorInst inst :: :: isTerminatorInst :: ''
      {{ com check is [[inst]] is a terminator inst }} by

      --------------------------------------- :: isTerminatorInst_return
      isTerminatorInst (ret typ value) 
      
      --------------------------------------- :: isTerminatorInst_return_void
      isTerminatorInst (ret void)

      --------------------------------------- :: isTerminatorInst_br
      isTerminatorInst (br value , ll1 , ll2)

      --------------------------------------- :: isTerminatorInst_br_uncond
      isTerminatorInst (br ll)

      ----------------------------------------------------------------- :: isTerminatorInst_switch
      isTerminatorInst (switch value , ll </ [ constj , llj ] // j />)

      ----------------------------------------------------------------- :: isTerminatorInst_invoke
      isTerminatorInst (id = invoke t id0 paraml to ll1 unwind ll2)

      ----------------------------------------------------------------- :: isTerminatorInst_unreachable
      isTerminatorInst unreachable

defns
instlGetLast_def :: '' ::=
      defn
      instlGetLast instl = inst_opt :: :: instlGetLast :: ''
      {{ com [[inst_opt]] is the last inst of [[instl]] }} by
      
      ----------------------------------- :: instlGetLast_nil
      instlGetLast [] = none 

      ----------------------------------- :: instlGetLast_true
      instlGetLast ([] , inst) = inst

      instlGetLast (instl, inst1) = inst_opt
      ----------------------------------------------- :: instlGetLast_rec
      instlGetLast (instl, inst1, inst2) = inst_opt      

defns
instlEndsWithTerminatorInst_def :: '' ::=
      defn
      instlEndsWithTerminatorInst instl :: :: instlEndsWithTerminatorInst :: ''
      {{ com [[instl]] ends with terminator instruction }} by
      
      instlGetLast instl = inst
      isTerminatorInst inst
      ----------------------------------------------- :: instlEndsWithTerminatorInst_intro
      instlEndsWithTerminatorInst instl 
    
defns
instlDoesntContainTerminatorInst_def :: '' ::=
      defn
      instlDoesntContainTerminatorInst instl :: :: instlDoesntContainTerminatorInst :: ''
      {{ com [[instl]] doesnt contain terminator instruction }} by

      --------------------------------------- :: instlDoesntContainTerminatorInst_nil
      instlDoesntContainTerminatorInst []

      instlDoesntContainTerminatorInst instl
      not isTerminatorInst inst
      ----------------------------------------------- :: instlDoesntContainTerminatorInst_cons
      instlDoesntContainTerminatorInst instl , inst

defns
instlRemovesLast_def :: '' ::=
      defn
      instlRemovesLast instl = instl' :: :: instlRemovesLast :: '' 
      {{ com [[inst']] is the list without the last element from [[instl]] }} by
 
      ----------------------------------------------- :: instlRemovesLast_nil
      instlRemovesLast [] = []

      ----------------------------------------------- :: instlRemovesLast_true
      instlRemovesLast ([], inst) = []

      instlRemovesLast (instl, inst1) = instl'
      ----------------------------------------------- :: instlRemovesLast_rec
      instlRemovesLast (instl, inst1, inst2) = (instl', inst2)

defns
instlChecksTerminatorInst_def :: '' ::=
      defn
      instlChecksTerminatorInst instl :: :: instlChecksTerminatorInst :: ''
      {{ com check if [[inst]] is well-formed }} by

      instlEndsWithTerminatorInst instl
      instlRemovesLast instl = instl'    
      instlDoesntContainTerminatorInst instl'
      ----------------------------------------------- :: instlChecksTerminatorInst_intro
      instlChecksTerminatorInst instl

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%        Check Phi							%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

defns
isPhiNode_def :: '' ::=
      defn
      isPhiNode inst :: :: isPhiNode :: ''
      {{ com check is [[inst]] is a phi node }} by

      --------------------------------------- :: isPhiNode_intro
      isPhiNode (id = phi typ </ [ idj , llj ] // j />) 
      
defns
instlStartsWithPhiNode_def :: '' ::=
      defn
      instlStartsWithPhiNode instl :: :: instlStartsWithPhiNode :: ''
      {{ com [[instl]] starts with phi instruction }} by

      ----------------------------------------------- :: instlStartsWithPhiNode_nil
      instlStartsWithPhiNode []

      instlStartsWithPhiNode instl      
      isPhiNode inst
      ---------------------------------------------------------------------- :: instlStartsWithPhiNode_cons_phi
      instlStartsWithPhiNode (instl, inst)
      
      instlDoesntContainPhiNode instl      
      not isPhiNode inst
      ---------------------------------------------------------------------- :: instlStartsWithPhiNode_cons_nophi
      instlStartsWithPhiNode (instl, inst)

      defn
      instlDoesntContainPhiNode instl :: :: instlDoesntContainPhiNode :: ''
      {{ com [[instl]] doesnt contain phi instruction }} by

      --------------------------------------- :: instlDoesntContainPhiNode_nil
      instlDoesntContainPhiNode []

      instlDoesntContainPhiNode instl
      not isPhiNode inst 
      ----------------------------------------------------- :: instlDoesntContainPhiNode_cons
      instlDoesntContainPhiNode instl , inst

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%             succ of blocks                                       %
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

defns
getTerminator_def :: '' ::=
      defn
      getTerminator block = inst_opt :: :: getTerminator :: ''
      {{ com [[inst]] is the terminator instruction of [[block]] }} by
 
      instlGetLast instl = inst_opt      
      -------------------------------- :: getTerminator_intro
      getTerminator (ll instl) = inst_opt

defns
getLabelsFromTerminator_def :: '' ::=
      defn
      getLabelsFromTerminator inst = lls :: :: getLabelsFromTerminator :: ''
      {{ com [[lls]] is the set of labels from terminator [[inst]] }} by

      --------------------------------------------------------------- :: getLabelsFromTerminator_br
      getLabelsFromTerminator (br value , ll1 , ll2) = empty , ll1 , ll2     


      --------------------------------------------------------------- :: getLabelsFromTerminator_br_uncond
      getLabelsFromTerminator (br ll) = empty , ll


      ---------------------------------------------------------------- :: getLabelsFromTerminator_switch
      getLabelsFromTerminator (switch value , ll </ [ constj , llj ] // j /> ) = empty


      ---------------------------------------------------------------- :: getLabelsFromTerminator_invoke
      getLabelsFromTerminator (id = invoke t id0 paraml to ll1 unwind ll2) = empty , ll1 , ll2  

defns
succOfBlock_def :: '' ::= 
     defn
     succOfBlock block = lls :: :: succOfBlock :: ''
     {{ com [[block]] has succesors [[lls]] }} by

     
     getTerminator block = none
     ------------------------------ :: succOfBlock_none
     succOfBlock block = empty

     getTerminator block = inst     
     getLabelsFromTerminator inst = lls
     ------------------------------------ :: succOfBlock_inst
     succOfBlock block = lls


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%         get block from label                                  %
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

defns
getBlockAtLableFromBlockl_def :: '' ::=
      defn 
      getBlockAtLableFromBlockl blockl ll = block_opt :: :: getBlockAtLableFromBlockl :: ''
      {{ com [[block_opt]] is of label [[ll]] in [[blockl]] }} by

      ---------------------------------------------------- :: getBlockAtLableFromBlockl_nil
      getBlockAtLableFromBlockl [] ll = none

      ll1 == ll2 
      -------------------------------------------------------------- :: getBlockAtLableFromBlockl_true
      getBlockAtLableFromBlockl (blockl, (ll1 instl1)) ll2 = ll1 instl1

      not ll1 == ll2
      getBlockAtLableFromBlockl blockl ll2 = block_opt
      -------------------------------------------------------------- :: getBlockAtLableFromBlockl_rec1
      getBlockAtLableFromBlockl (blockl, (ll1 instl1)) ll2 = block_opt
			      
    
defns
getBlockAtLableFromFdef_def :: '' ::=
      defn
      getBlockAtLableFromFdef fdef ll = block_opt :: :: getBlockAtLableFromFdef :: ''
      {{ com [[block_opt]] is of label [[ll]] in [[fdef]] }} by

      getBlockAtLableFromBlockl blockl ll = block_opt
      ---------------------------------------------------- :: getBlockAtLableFromFdef_intro
      getBlockAtLableFromFdef (define fheader { blockl }) ll = block_opt


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%         pred of blocks                                        %
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

defns
getPhiNodesFromInstl_def :: '' ::=
      defn
      getPhiNodesFromInstl instl = instl' :: :: getPhiNodesFromInstl :: ''
      {{ com [[instl']] are the Phi nodes in [[instl]] }} by
 
      -------------------------------- :: getPhiNodesFromInstl_nil
      getPhiNodesFromInstl [] = []

      getPhiNodesFromInstl instl = instl'
      isPhiNode inst       
      --------------------------------------------------- :: getPhiNodesFromInstl_rec_true
      getPhiNodesFromInstl (instl, inst) = instl',inst

      getPhiNodesFromInstl instl = instl'
      not isPhiNode inst       
      --------------------------------------------------- :: getPhiNodesFromInstl_rec_false
      getPhiNodesFromInstl (instl, inst) = instl'

defns
getPhiNodesFromBlock_def :: '' ::=
      defn
      getPhiNodesFromBlock block = instl :: :: getPhiNodesFromBlock :: ''
      {{ com [[instl]] are the Phi nodes in [[block]] }} by
 
      getPhiNodesFromInstl instl = instl'
      ---------------------------------------- :: getPhiNodesFromBlockInstl_intro
      getPhiNodesFromBlock (ll instl) = instl'


defns
getLabelsFromPhiNode_def :: '' ::=
      defn
      getLabelsFromPhiNode inst = lls :: :: getLabelsFromPhiNode :: ''
      {{ com [[lls]] is the set of labels from phi [[inst]] }} by

      -------------------------------------------------------------------------------- :: getLabelsFromPhiNode_intro
      getLabelsFromPhiNode (id = phi typ </ [ idj , llj ] // j />) = empty
 
defns
getLabelsFromPhiNodes_def :: '' ::=
      defn
      getLabelsFromPhiNodes instl = lls :: :: getLabelsFromPhiNodes :: ''
      {{ com [[lls]] is the set of labels from phis [[instl]] }} by

      -------------------------------------------------------------------------------- :: getLabelsFromPhiNodes_nil
      getLabelsFromPhiNodes [] = empty

      getLabelsFromPhiNodes instl = lls
      getLabelsFromPhiNode inst = lls'
      -------------------------------------------------------------------------------- :: getLabelsFromPhiNodes_cons
      getLabelsFromPhiNodes (instl, inst) = lls ; lls' 


defns
predOfBlock_def :: '' ::= 
      defn
      predOfBlock block = lls :: :: predOfBlock :: ''
      {{ com [[block]] has pred [[lls]] }} by
     
      getPhiNodesFromBlock block = instl     
      getLabelsFromPhiNodes instl = lls
      ------------------------------------ :: predOfBlock_intro
      predOfBlock block = lls


