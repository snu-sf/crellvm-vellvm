
% Syntax of Static Single Assignment(SSA)

embed 
{{ coq
Require Import ListSet.
Require Import List.
Require Import Logic_Type.
Require Import monad.

Section Lists.

  Variable A : Type.

  Fixpoint last_opt (l:list A) {struct l} : option A := 
  match l with 
    | nil => None 
    | a :: nil => Some a 
    | a :: l' => last_opt l'
  end.

End Lists. 
}}

metavar INT ::= {{ com a natural number }}
  {{ coq nat }} {{ lex numeral  }}
metavar id ::= {{ com identities }}
  {{ coq nat }} {{ lex numeral  }}
metavar l ::= {{ com labels }}
  {{ coq nat }} {{ lex numeral  }}
metavar align ::= {{ com align }}
  {{ coq nat }} {{ lex numeral }}
metavar sz ::= {{ com sz }}
  {{ coq nat }} {{ lex numeral }}
indexvar i, j, n ::= {{ com index }}
  {{ coq nat }}
 
grammar

opt_INT {{ tex \mathit{opt_{INT} } }} :: 'opt_INT_'	::=			{{ com option INT }} {{ coq option INT }}
  |  none 						:: M :: none		{{ com none }} {{ coq None }}
  |  INT						:: M :: some  		{{ com some }} {{ coq (Some [[INT]]) }}

opt_l {{ tex \mathit{opt_{l} } }} :: 'opt_l_'		::=			{{ com option l }} {{ coq option l }}
  |  none 						:: M :: none		{{ com none }} {{ coq None }}
  |  l							:: M :: some  		{{ com some }} {{ coq (Some [[l]]) }}

opt_id {{ tex \mathit{opt_{id} } }} :: 'opt_id_'	::=			{{ com option id }} {{ coq option id }}
  |  none 						:: M :: none		{{ com none }} {{ coq None }}
  |  id							:: M :: some  		{{ com some }} {{ coq (Some [[id]]) }}

ids {{ tex \mathit{\{id\} } }} :: 'ids_'		::=			{{ com id set }}
       	   			      	 					{{ coq (list id) }}
  | empty						::   :: empty		{{ coq (empty_set id) }}
  | id1 .. idn						::   :: set		{{ coq [[id1 .. idn]] }}
  | ids , id						::   :: cons		{{ coq (set_add eq_nat_dec [[id]] [[ids]]) }}
  | ids ; ids'						::   :: append		{{ coq (set_union eq_nat_dec [[ids]] [[ids']]) }}
  | ( ids )						:: S :: paren		{{ coq [[ ids ]] }}

layout :: 'layout_'					::=  			{{ com data layout }}
  | bigendian						::   :: be 		{{ com bigendian }}
  | littleendian					::   :: le	 	{{ com littleendian }}
  | ptr sz align0 align1				::   :: ptr		{{ com ptr }}
  | int sz align0 align1				::   :: int		{{ com int }}
  | aggr sz align0 align1			     	::   :: aggr		{{ com aggregate }}
  | stack sz align0 align1				::   :: stack		{{ com stack }}

list_layout {{ tex \mathit{\overline{layout} } }} :: 'list_layout_'	::=  	{{ com layout list }}
     	    			     	   					{{ coq (list layout) }}
  | []   		 				::   :: nil		{{ coq nil }}
  | list_layout , layout				::   :: cons		{{ coq ([[layout]]::[[list_layout]]) }}
  | list_layout ; list_layout'				::   :: append		{{ coq ([[list_layout]]++[[list_layout']]) }}
  | ( list_layout )					:: S :: paren           {{ coq [[ list_layout ]] }}

typ :: 'typ_'						::=			{{ com type }}
  | int sz                    				::   :: int         	{{ com integer }}
  %| float						::   :: float		{{ com float }}
  %| double						::   :: double          {{ com double }}
  %| fp128						::   :: fp128           {{ com fp128 }}
  | void                      				::   :: void        	{{ com void }}
  | label                                               ::   :: label           {{ com label }}
  | metadata                                            ::   :: metadata        {{ com metadata }}
  | [ sz * typ ]              				::   :: array       	{{ com array }}
  | typ ( </ typj // j /> )  				::   :: function    	{{ com function }}
  | { </ typj // j /> }       				::   :: struct      	{{ com structure }}
  | typ *                     				::   :: pointer     	{{ com pointer }}
  %| < sz * typ >             				::   :: vector       	{{ com vector }}
  %| opaque  						::   :: opaque          {{ com opaque }}
  % x86_fp80
  % ppc_fp128
  % union
  | ( typ )						:: S :: paren           {{ coq [[ typ ]] }}

opt_typ {{ tex \mathit{opt_{typ} } }} :: 'opt_typ_'	::=			{{ com option typ }} {{ coq option typ }}
  |  none 						:: M :: none		{{ com none }} {{ coq None }}
  |  typ						:: M :: some  		{{ com some }} {{ coq (Some [[typ]]) }}

list_typ {{ tex \mathit{\overline{typ} } }} :: 'list_typ_'	::=  		{{ com typ list }}
     	    			     	   					{{ coq (list typ) }}
  | []   		 				::   :: nil		{{ coq nil }}
  | list_typ , typ 					::   :: cons		{{ coq ([[typ]]::[[list_typ]]) }}
  | list_typ ; list_typ'				::   :: append		{{ coq ([[list_typ]]++[[list_typ']]) }}
  | ( list_typ )					:: S :: paren           {{ coq [[ list_typ ]] }}

const :: 'const_'					::=  			{{ com constant }}
  | ( int sz ) INT					::   :: int		{{ com int }}	
  | typ undef						::   :: undef		{{ com undef }}
  | ( typ * ) null					::   :: null		{{ com null }}
  | [ </ constj // j /> ]				::   :: arr             {{ com array }}
  | { </ constj // j /> }				::   :: struct          {{ com struct }}
  | ( const )						:: S :: paren           {{ coq [[ const ]] }}

list_const {{ tex \mathit{\overline{const} } }} :: 'list_const_'	::=  		{{ com const list }}
     	    			     	   					{{ coq (list (const)) }}
  | []   		 				::   :: nil		{{ coq nil }}
  | list_const , const 					::   :: cons		{{ coq ([[const]]::[[list_const]]) }}
  | list_const ; list_const'				::   :: append		{{ coq ([[list_const]]++[[list_const']]) }}
  | ( list_const )					:: S :: paren           {{ coq [[ list_const ]] }}

value :: 'value_'					::=  			{{ com values }}
  | id	 						::   :: id		{{ com id }}
  | const						::   :: const   	{{ com constant }}
  | ( value )						:: S :: paren           {{ coq [[ value ]] }}

arg :: 'arg_'  						::=  			{{ com argument }}
       										{{ coq (prod typ id) }}
  | typ id						::   :: def		{{ coq ([[typ]],[[id]]) }}
  | ( arg )						:: S :: paren		{{ coq [[ arg ]] }} 			

list_arg {{ tex \mathit{\overline{arg} } }} :: 'list_arg_'	::=  		{{ com argument list }}
     	    			     	   					{{ coq (list (typ*id)) }}
  | []   		 				::   :: nil		{{ coq nil }}
  | list_arg , arg 					::   :: cons		{{ coq ([[arg]]::[[list_arg]]) }}
  | list_arg ; list_arg'				::   :: append		{{ coq ([[list_arg]]++[[list_arg']]) }}
  | ( list_arg )					:: S :: paren           {{ coq [[ list_arg ]] }}

param :: 'param_'  					::=  			{{ com argument }}
       										{{ coq (prod typ value) }}
  | typ value						::   :: def		{{ coq ([[typ]],[[value]]) }}
  | ( param )						:: S :: paren		{{ coq [[ param ]] }} 			

list_param {{ tex \mathit{\overline{param} } }} :: 'list_param_'::=		{{ com parameter list }}
       	      			       	       					{{ coq (list (typ*value)) }}
  | []  						::   :: nil		{{ coq nil }}
  | list_param , param           			::   :: cons		{{ coq (([[param]])::[[list_param]]) }}
  | list_param ; list_param'				::   :: append		{{ coq ([[list_param]]++[[list_param']]) }}
  | ( list_param )					:: S :: paren           {{ coq [[ list_param ]] }}

ls {{ tex \mathit{\{l\} } }} :: 'ls_'			::=			{{ com label set }}
       	   			      	 					{{ coq (list l) }}
  | empty						::   :: empty		{{ coq (empty_set l) }}
  | l1 .. ln						::   :: set		{{ coq [[l1 .. ln]] }}
  | ls , l						::   :: cons		{{ coq (set_add eq_nat_dec [[l]] [[ls]]) }}
  | ls ; ls'						::   :: append		{{ coq (set_union eq_nat_dec [[ls]] [[ls']]) }}
  | ( ls )						:: S :: paren		{{ coq [[ ls ]] }}

%cond :: 'cond_'						::=			{{ com condition code }}
  %| eq							::   :: eq		{{ com eq }}
  %| ne							::   :: ne		{{ com ne }}
  %| ugt							::   :: ugt		{{ com ugt }}
  %| uge							::   :: uge		{{ com uge }}
  %| ult							::   :: ult		{{ com ult }}
  %| ule							::   :: ule		{{ com ule }}
  %| sgt							::   :: sgt		{{ com sgt }}
  %| sge							::   :: sge		{{ com sge }}
  %| slt							::   :: slt		{{ com slt }}
  %| sle							::   :: sle		{{ com sle }}

insn :: 'insn_'					    	::=			{{ com insnruction }}
  | ret typ value             			    	::   :: return      	{{ com return }}
  %| ret void                   		    	::   :: return_void  	{{ com return void }}
  | br value , l1 , l2		 			::   :: br              {{ com br }}        
  | br l        	    	  			::   :: br_uncond       {{ com unconditional br }}        
  %| switch typ value , l </ [ constj , lj ] // j />	::   :: switch		{{ com switch }}
  %| id = invoke typ0 id0 list_param to l1 unwind l2 	::   :: invoke		{{ com invoke }} 
  | id = call typ0 id0 list_param	       	 	::   :: call		{{ com call }} 
  | unreachable	     	   	     	 		::   :: unreachable	{{ com unreachable }}
  | id = add sz value1 value2				::   :: add		{{ com add }}
  %| id = fadd typ value1 value2				::   :: fadd		{{ com fadd }}
  %| id = udiv typ value1 value2				::   :: udiv		{{ com udiv }}
  %| id = fdiv typ value1 value2				::   :: fdiv		{{ com fdiv }}
  %| id = or typ value1 value2				::   :: or 		{{ com or }}
  %| id = and typ value1 value2				::   :: and 		{{ com and }}
  %| id = extractelement typ0 value0 , const1		::   :: extractelement  {{ com extractelement }}
  %| id = insertelement typ0 value0 , typ1 value1 , const2	::   :: insertelement   {{ com insertelement }}
  | id = extractvalue typ value , </ constj // j />       	 ::   :: extractvalue	        {{ com extractvalue }}
  | id = insertvalue typ value , typ' value' , </ constj // j /> ::   :: insertvalue	{{ com insertvalue }}
  | id = alloca typ sz align     	       	     	::   :: alloca		{{ com alloca }}
  | id = load ( typ * ) value1				::   :: load		{{ com load }}
  | store typ value1 , value2				::   :: store		{{ com store }}
  | id = getelementptr ( typ * ) value , </ valuej // j />    	      ::  :: gep        {{ com getelementptr }}
  | id = getelementptr inbounds ( typ * ) value , </ valuej // j />     ::  :: bgep       {{ com inboundsgetelementptr }}
  %| id = trunc typ1 value1 to typ2			::   :: trunc		{{ com trunc }}
  %| id = fptrunc typ1 value1 to typ2			::   :: fptrunc		{{ com fptrunc }}
  %| id = fptoui typ1 value1 to typ2			::   :: fptoui		{{ com fptoui }}
  %| id = fptosi typ1 value1 to typ2			::   :: fptosi		{{ com fptosi }}
  %| id = uitofp typ1 value1 to typ2			::   :: uitofp		{{ com uitofp }}
  %| id = sitofp typ1 value1 to typ2			::   :: sitofp		{{ com sitofp }}
  %| id = ptrtoint typ1 value1 to typ2			::   :: ptrtoint	{{ com ptrtoint }}
  %| id = inttoptr typ1 value1 to typ2			::   :: inttoptr	{{ com inttoptr }}
  %| id = bitcast typ1 value1 to typ2			::   :: bitcast		{{ com bitcast }}
  %| id = icmp cond typ value1 , value2			::   :: icmp		{{ com icmp }}
  %| id = fcmp cond typ value1 , value2			::   :: fcmp		{{ com fcmp }}
  | id = phi typ </ [ idj , lj ] // j />		::   :: phi  	    	{{ com phi }}
  | ( insn )						:: S :: paren           {{ coq [[ insn ]] }}

id_labels :: 'id_labels_'				::=  			{{ com id labels }}
	      									{{ coq list (id*l) }}
  | []	      						::   :: nil		{{ coq nil }}
  | id_labels , id l                                    ::   :: cons            {{ coq (([[id]],[[l]])::[[id_labels]]) }}
  | ( id_labels )                                       :: S :: paren           {{ coq [[ id_labels ]] }}

opt_insn {{ tex \mathit{opt_{insn} } }} :: 'opt_insn_'  ::=			{{ com option insn }} {{ coq option insn }}
  |  none 						:: M :: none		{{ com none }} {{ coq None }}
  |  insn						:: M :: some  		{{ com some }} {{ coq (Some [[insn]]) }}
		   
list_insn {{ tex \mathit{\overline{insn} } }} :: 'list_insn_'	::=			{{ com insnruction list }}
      	     			       	     					{{ coq (list insn) }}
  | []	                  				::   :: nil		{{ coq nil }}
  | list_insn , insn           				::   :: cons		{{ coq ([[insn]]::[[list_insn]]) }}
  | list_insn ; list_insn'				::   :: append		{{ coq ([[list_insn]]++[[list_insn']]) }}
  | ( list_insn )					:: S :: paren           {{ coq [[ list_insn ]] }}

block :: 'block_' 					::=			{{ com block }}
  | l list_insn						::   :: intro
  | ( block )						:: S :: paren           {{ coq [[ block ]] }}

opt_block {{ tex \mathit{opt_{block} } }} :: 'opt_block_' ::=			{{ com option block }} {{ coq option block }}
  |  none 						:: M :: none		{{ com none }} {{ coq None }}
  |  block						:: M :: some  		{{ com some }} {{ coq (Some [[block]]) }}
		   
list_block {{ tex \mathit{\overline{block} } }} :: 'list_block_'::=		{{ com block list }}
      	     			       	     					{{ coq (list block) }}
  | []  						::   :: nil		{{ coq nil }}
  | list_block , block					::   :: cons		{{ coq ([[block]]::[[list_block]]) }}
  | list_block ; list_block'				::   :: append		{{ coq ([[list_block]]++[[list_block']]) }}
  | ( list_block )					:: S :: paren           {{ coq [[ list_block ]] }}

fheader :: 'fheader_'    				::=			{{ com function header }}
  | typ id ( list_arg ) 				::   :: intro
  | ( fheader )						:: S :: paren           {{ coq [[ fheader ]] }}

fdec :: 'fdec_'       					::=			{{ com function declaration }}
  | declare fheader     				::   :: intro
  | ( fdec )						:: S :: paren           {{ coq [[ fdec ]] }}

fdef :: 'fdef_'          				::=			{{ com function definition }}
  | define fheader { list_block } 			::   :: intro
  | ( fdef )						:: S :: paren           {{ coq [[ fdef ]] }}

opt_fdec {{ tex \mathit{opt_{fdec} } }} :: 'opt_fdec_'	::=  			{{ com option fdec }} {{ coq option fdec }}
  | none 						::   :: none		{{ coq None }}
  | fdec						::   :: fdec		{{ coq (Some [[fdec]]) }}
  | ( opt_fdec )					:: S :: paren		{{ coq [[ opt_fdec ]] }}

opt_fdef {{ tex \mathit{opt_{fdef} } }} :: 'opt_fdef_'	::=  			{{ com option fdef }} {{ coq option fdef }}
  | none 						::   :: none		{{ coq None }}
  | fdef						::   :: fdec		{{ coq (Some [[fdef]]) }}
  | ( opt_fdef )					:: S :: paren		{{ coq [[ opt_fdef ]] }}

% namedt :: 'namedt_'         				::=			{{ com named type }}
%   | id = type typ   					::   :: intro 
%   | ( namedt )						:: S :: paren		{{ coq [[ namedt ]] }}

% global id is also taken as constant addresses
gvar :: 'gvar_'   	 				::=			{{ com global variables }}
  | id = global typ value				::   :: intro           
  | ( gvar )	    					:: S :: paren		{{ coq [[ gvar ]] }}

id_binding :: 'id_binding_'  				::=			{{ com id binding }} 
  |  none 						::  :: none		{{ com none }} 
  |  insn						::  :: insn  		{{ com insn }} 
  |  gvar						::  :: gvar             {{ com gvar }} 
  |  fdec						::  :: fdec		{{ com fdec }}
  |  arg 						::  :: arg		{{ com arg }}
		   
product  :: 'product_'					::=			{{ com prodoct }}
  | gvar						::   :: gvar     	{{ com global variable }}
  | fdec             					::   :: fdec   		{{ com function declaration }}
  | fdef             					::   :: fdef		{{ com function definition }}
%  | namedt           					::   :: namedtype     	{{ com named types }}

list_product {{ tex \mathit{\overline{product} } }} :: 'list_product_'::=	{{ com list product }}
	    				     	   				{{ coq (list product) }}	   
  | []   						::   :: nil        	{{ com nil }}
    							     			{{ coq nil }}
  | list_product , product				::   :: cons            {{ com cons }}
    	       						     			{{ coq ([[product]]::[[list_product]]) }}
  | ( list_product )					:: S :: paren		{{ coq [[ list_product ]] }}			

module :: 'module_'					::=  			{{ com module }}
  | list_layout list_product 				::   :: intro		{{ com prods }}
  | ( module )					        :: S :: paren           {{ coq [[ module ]] }}

list_module {{ tex \mathit{\overline{module} } }} :: 'list_module_'::=  	{{ com list module }}
      	     			       	     					{{ coq (list module) }}
  | []  						::   :: nil		{{ coq nil }}
  | list_module , module				::   :: cons		{{ coq ([[module]]::[[list_module]]) }}
  | list_module ; list_module'				::   :: append		{{ coq ([[list_module]]++[[list_module']]) }}
  | ( list_module )					:: S :: paren           {{ coq [[ list_module ]] }}

system :: 'system_'					::=  			{{ com system }}
       	  									{{ coq list_module }}
  | list_module						::   :: def		{{ com list of modules }}
    							     			{{ coq [[list_module]] }}

dt :: 'dt_'						::=  			{{ com dominator }}
       										{{ coq (l -> list l) }}

usedef_insn :: 'usedef_insn_'				::=			{{ com insn usedef }}
       	  									{{ coq (insn -> (list insn)) }} 

usedef_block :: 'usedef_block_'				::=			{{ com block usedef }}
       	  									{{ coq (block -> (list block)) }} 

module_info :: 'module_info_'				::=			{{ com module information }}
	       									{{ coq (prod module (prod usedef_insn usedef_block)) }}		
  | module , usedef_insn , usedef_block			::   ::	def		{{ com def }} 
   	     		  				     			{{ coq ([[module]], ([[usedef_insn]], [[usedef_block]])) }}	
  | ( module_info )					:: S :: paren           {{ coq [[ module_info ]] }}

fdef_info :: 'fdef_info_'				::=  			{{ com fdef information }}
	     									{{ coq (prod fdef dt) }}
  | fdef , dt						::   :: def		{{ com def }}
    	   						     			{{ coq ([[fdef]], [[dt]]) }}
  | ( fdef_info )					:: S :: paren		{{ coq [[ fdef_info ]] }}						

intrinsic_funs :: 'intrinsic_funs_'			::=  			{{ com intrinsic functions }}
	      	 								{{ coq ids }}

terminals :: 'terminals_' ::=
  | =                   ::   :: assignment      {{ tex = }}
  | <->                 ::   :: alias		{{ tex <-> }}
  | == 			::   :: eq		{{ tex == }}
  | |-			::   :: shows           {{ tex \vdash }}
  | |-i			::   :: ishows          {{ tex \vdash_{i} }}
  | |-t			::   :: tshows          {{ tex \vdash_{t} }}
  | |-f			::   :: fshows          {{ tex \vdash_{f} }}
  | in			::   :: in		{{ tex \in }}
  | ;			::   :: colon		{{ tex ; }}

formula :: 'formula_' ::=
  | judgement			::   :: judgement
  | formula1 ... formulan     	::   :: dots
  | True     	 		:: M :: true
    				{{ tex True }}
				{{ coq [[True]] }}
  | False     	 		:: M :: false
    				{{ tex False }}
				{{ coq [[False]] }}
  | not formula                 :: M :: not
      				{{ tex \neg [[formula]] }}
				{{ coq (not ([[formula]])) }}
  | notT formula                :: M :: notT
      				{{ tex \neg [[formula]] }}
				{{ coq (notT ([[formula]])) }}
  | ( formula )                 :: M :: brackets
      	      			{{ tex ([[formula]]\!) }} 
      				{{ coq ([[ formula ]]) }}
  | exists u . formula          ::   :: exists 
      	       			{{ tex \exists [[u]]. [[formula]] }}
      				{{ coq ( exists [[ u ]] , [[ formula ]] ) }}
  | formula /\ formula'         :: M :: and
               			{{ tex [[formula]] \wedge [[formula']] }}
	  			{{ coq [[formula]] /\ [[ formula' ]] }}
  | foreach C . formula         :: M :: forall 
              			{{ tex \forall [[C]]. [[ formula ]] }}
	  			{{ coq ( forall [[C]], [[ formula ]] ) }}
  | formula implies formula'    :: M :: implies
            	    		{{ tex [[formula]] \mathit{implies} [[formula']] }}
	  			{{ coq [[formula]] -> [[ formula' ]] }}
  | formula \/ formula'         :: M :: or
               			{{ tex [[formula]] \vee [[formula']] }}
	  			{{ coq [[formula]] \/ [[ formula' ]] }} 
  |  [multiline] formula        :: M :: multiline
                                {{ com allow \LaTeX{} output in multiple lines }}
                                {{ coq [[formula]] }}
                                {{ tex \begin{array}{l}[[formula]]\end{array} }}
  |  [newline] formula          :: M :: formula_n
                                {{ com add a newline to the \LaTeX{} output }}
                                {{ coq [[formula]] }} {{ tex \\[[formula]] }}
  |  [tab] formula              :: M :: formula_t
                                {{ com add a tab to the \LaTeX{} output }}
                                {{ coq [[formula]] }} {{ tex \qquad[[formula]] }}
  | if formula0 then formula1 else formula2 endif
       	       	    	    	:: M :: ifthenelse
				{{ tex if [[formula0]] then [[formula1]] else [[formula2]] }}
				{{ coq ([[formula0]] -> [[formula1]]) /\ ((~[[formula0]]) -> [[formula2]]) }}
  | formula ; formula'		:: M :: seq
    	      			{{ tex [[formula]] ; [[formula']] }}
				{{ coq [[formula]] -> [[formula']] }}
  | block1 = block2 		::   :: eqBlock
				{{ tex [[block1]] = [[block2]] }}
				{{ coq [[block1]] = [[block2]] }}
  | sz = 1			::   :: isOne
       	 			{{ coq [[sz]] = 1 }} 
  | sz = 32			::   :: isThirtyTwo
       	 			{{ coq [[sz]] = 32 }}
  | sz > 0			::   :: gtZero
       	 			{{ coq [[sz]] > 0 }}
  | sz1 = sz2 			::   :: eqSize
				{{ tex [[sz1]] = [[sz2]] }}
				{{ coq [[sz1]] = [[sz2]] }}
  | INT1 = INT2 		::   :: eqINT
				{{ tex [[INT1]] = [[INT2]] }}
				{{ coq [[INT1]] = [[INT2]] }}
  | l1 = l2 			::   :: eqLabel
				{{ tex [[l1]] = [[l2]] }}
				{{ coq [[l1]] = [[l2]] }}
  | id1 = id2			::   :: eqID
				{{ tex [[id1]] = [[id2]] }}
				{{ coq [[id1]] = [[id2]] }}
  | ls1 == ls2                  ::   :: eqLabels
				{{ tex [[ls1]] = [[ls2]] }}       
                                {{ coq lset_eq [[ls1]] [[ls2]] }}
  | l notin ls			::   :: l_notin_ls
      	    			{{ tex [[l]] \not\in [[ls]] }}
				{{ coq ( ~ set_In [[l]] [[ls]]) }}
  | l in ls			::   :: l_in_ls
      	    			{{ tex [[l]] \in [[ls]] }}
				{{ coq ( set_In [[l]] [[ls]]) }}
  | id in ids			::   :: id_in_ids
      	    			{{ tex [[id]] \in [[ids]] }}
				{{ coq ( set_In [[id]] [[ids]]) }}
  | id in intrinsic_funs	::   :: id_in_intrinsic_funs
      	    			{{ tex [[id]] \in [[intrinsic_funs]] }}
				{{ coq ( set_In [[id]] [[intrinsic_funs]]) }}
  | id notin intrinsic_funs	::   :: id_notin_intrinsic_funs
      	    			{{ tex [[id]] \notin [[intrinsic_funs]] }}
				{{ coq ( ~ set_In [[id]] [[intrinsic_funs]]) }}
  | module in system		::   :: module_in_system
    	       			{{ tex [[module]] \in [[system]] }}
				{{ coq In [[module]] [[system]] }}
  | product in list_product	::   :: product_in_products
    	       			{{ tex [[product]] \in [[list_product]] }}
				{{ coq In [[product]] [[list_product]] }}
  | block in list_block		::   :: block_in_blocks
    	       			{{ tex [[block]] \in [[list_block]] }}
				{{ coq In [[block]] [[list_block]] }}
  | insn in list_insn		::   :: insn_in_insns
    	       			{{ tex [[insn]] \in [[list_insn]] }}
				{{ coq In [[insn]] [[list_insn]] }}
  | arg in list_arg		::   :: arg_in_args
    	       			{{ tex [[arg]] \in [[list_arg]] }}
				{{ coq In [[arg]] [[list_arg]] }}
  | typ = typ'  		:: M :: typ_alias
    	     			{{ com typ alias }} 
				{{ coq [[typ]] = [[typ']] }}
  | insn = insn'  		:: M :: insn_alias
    	     			{{ com insn alias }} 
				{{ coq [[insn]] = [[insn']] }}
  | module = module'          :: M :: module_alias
    	     			{{ com module alias }} 
				{{ coq [[module]] = [[module']] }}
  | system = system'          :: M :: system_alias
    	     			{{ com system alias }} 
				{{ coq [[system]] = [[system']] }}
  | length </ constj // j /> = sz :: M :: length_of_consts_is_sz
                                {{ coq length [[ </ constj // j /> ]] = [[sz]] }}
  | ids <-> </ idj // j /> 	:: M :: ids_alias
    	      	   	        {{ com ids alias }}
				{{ coq [[ids]] = [[ </ idj // j /> ]] }}
  | ls <-> </ lj // j /> 	:: M :: ls_alias
    	      	   	        {{ com ls alias }}
				{{ coq [[ls]] = [[ </ lj // j /> ]] }}
  | list_const <-> </ constj // j /> :: M :: consts_alias
    	      	   	        {{ com consts alias }}
				{{ coq [[list_const]] = [[ </ constj // j /> ]] }}
  | list_arg <-> </ argj // j /> :: M :: args_alias
    	      	   	        {{ com args alias }}
				{{ coq [[list_arg]] = [[ </ argj // j /> ]] }}
  | list_typ <-> </ typj // j /> :: M :: typs_alias
    	      	   	        {{ com typs alias }}
				{{ coq [[list_typ]] = [[ </ typj // j /> ]] }}
  | list_insn <-> </ insnj // j /> :: M :: insns_alias
    	      	   	        {{ com insns alias }}
				{{ coq [[list_insn]] = [[ </ insnj // j /> ]] }}
  | list_block <-> </ blockj // j /> :: M :: blocks_alias
    	      	   	        {{ com blocks alias }}
				{{ coq [[list_block]] = [[ </ blockj // j /> ]] }}
  | list_product = </ productj // j /> :: M :: products_alias
    	      	   	        {{ com products alias }}
				{{ coq [[list_product]] = [[ </ productj // j /> ]] }}
  | list_module <-> </ modulej // j /> :: M :: modules_alias
    	      	   	        {{ com modules alias }}
				{{ coq [[list_module]] = [[ </ modulej // j /> ]] }}
  | id_labels <-> </ [ idj , lj ] // j /> :: M :: id_labels_alias
    	      	     	        {{ com id_labels alias }}
				{{ coq [[id_labels]] = [[ </ [ idj , lj ] // j /> ]] }}
  | list_param <-> </ paramj // j /> :: M :: list_param_alias
                                {{ com list_param_alias }}
                                {{ coq [[list_param]] = [[ </ paramj // j /> ]] }}
  | getNthTyp </ typj // j /> INT = opt_typ ::   :: getNthTyp
    	      	       	   	{{ com getNthTyp }}
				{{ coq nth_error [[ </ typj // j /> ]] [[INT]] = [[opt_typ]] }}  
  | insn =id= insn'        :: M :: getInsnID_eq
    	      	      	      	{{ tex [[insn]] =id= [[insn']] }}
				{{ coq getInsnID [[insn]] = getInsnID [[insn']] }}

parsing
formula_true left formula_not
formula_false left formula_not
formula_and left formula_and
formula_or left formula_or
formula_not left formula_or
formula_not left formula_and
formula_or left formula_seq
formula_seq left formula_seq
formula_or left formula_ifthenelse
formula_ifthenelse left formula_seq
formula_and left formula_and
formula_multiline <= formula_and
formula_multiline <= formula_or

 

