
% Static Semantics of Static Single Assignment(SSA)

embed
{{coq

(* Do not require this file directly! Instead, use typings.v, which
   reexports this one and defines the relevant induction
   principles. *)

Require Import Metatheory.
Require Import syntax.
Require Import infrastructure.
Require Import ListSet.
Require Import List.
Require Import dom_list.
Require Import analysis.
Require Import targetdata.
Require Import alist.

Module LLVMtyping_rules.
Import LLVMsyntax.
Import LLVMinfra.

}}

grammar

formula :: 'formula_' ::=
  | judgement			::   :: judgement
  | formula1 ... formulan     	::   :: dots
  | True     	 		:: M :: true
    				{{ tex True }}
				{{ coq [[True]] }}
  | False     	 		:: M :: false
    				{{ tex False }}
				{{ coq [[False]] }}
  | not formula                 :: M :: not
      				{{ tex \neg [[formula]] }}
				{{ coq (not ([[formula]])) }}
  | notT formula                :: M :: notT
      				{{ tex \neg [[formula]] }}
				{{ coq (notT ([[formula]])) }}
  | ( formula )                 :: M :: brackets
      	      			{{ tex ([[formula]]\!) }}
      				{{ coq ([[ formula ]]) }}
  | exists u . formula          ::   :: exists
      	       			{{ tex \exists [[u]]. [[formula]] }}
      				{{ coq ( exists [[ u ]] , [[ formula ]] ) }}
  | formula /\ formula'         :: M :: and
               			{{ tex [[formula]] \wedge [[formula']] }}
	  			{{ coq [[formula]] /\ [[ formula' ]] }}
  | foreach C . formula         :: M :: forall
              			{{ tex \forall [[C]]. [[ formula ]] }}
	  			{{ coq ( forall [[C]], [[ formula ]] ) }}
  | formula implies formula'    :: M :: implies
            	    		{{ tex [[formula]] \mathit{implies} [[formula']] }}
	  			{{ coq ([[formula]] -> [[ formula' ]]) }}
  | formula iff formula'        :: M :: iff
            	    		{{ tex [[formula]] \mathit{iff} [[formula']] }}
	  			{{ coq ([[formula]] <-> [[ formula' ]]) }}
  | formula \/ formula'         :: M :: or
               			{{ tex [[formula]] \vee [[formula']] }}
	  			{{ coq [[formula]] \/ [[ formula' ]] }}
  |  [multiline] formula        :: M :: multiline
                                {{ com allow \LaTeX{} output in multiple lines }}
                                {{ coq [[formula]] }}
                                {{ tex \begin{array}{l}[[formula]]\end{array} }}
  |  [newline] formula          :: M :: formula_n
                                {{ com add a newline to the \LaTeX{} output }}
                                {{ coq [[formula]] }} {{ tex \\[[formula]] }}
  |  [tab] formula              :: M :: formula_t
                                {{ com add a tab to the \LaTeX{} output }}
                                {{ coq [[formula]] }} {{ tex \qquad[[formula]] }}
  | if formula0 then formula1 else formula2 endif
       	       	    	    	:: M :: ifthenelse
				{{ tex if [[formula0]] then [[formula1]] else [[formula2]] }}
				{{ coq ([[formula0]] -> [[formula1]]) /\ ((~[[formula0]]) -> [[formula2]]) }}
  | formula ; formula'		:: M :: seq
    	      			{{ tex [[formula]] ; [[formula']] }}
				{{ coq [[formula]] -> [[formula']] }}
  | block1 = block2 		::   :: eqBlock
				{{ tex [[block1]] = [[block2]] }}
				{{ coq [[block1]] = [[block2]] }}
  | int1			::   :: intone
       	 			{{ coq (typ_int Size.One) }}
  | sz = 1			::   :: isOne
       	 			{{ coq [[sz]] = Size.One }}
  | typ = i32	        	::   :: thirtyTwoInt
       	 			{{ coq [[typ]] = typ_int Size.ThirtyTwo }}
  | sz = 32			::   :: isThirtyTwo
       	 			{{ coq [[sz]] = Size.ThirtyTwo }}
  | sz > 0			::   :: gtZero
       	 			{{ coq (Size.gt [[sz]] Size.Zero) }}
  | sz1 = sz2 			::   :: eqSize
				{{ tex [[sz1]] = [[sz2]] }}
				{{ coq [[sz1]] = [[sz2]] }}
  | sz1 < sz2 			::   :: ltSize
				{{ tex ([[sz1]] < [[sz2]]) }}
				{{ coq (Size.lt [[sz1]] [[sz2]]) }}
  | INT1 = INT2 		::   :: eqINT
				{{ tex [[INT1]] = [[INT2]] }}
				{{ coq [[INT1]] = [[INT2]] }}
  | l1 = l2 			::   :: eqLabel
				{{ tex [[l1]] = [[l2]] }}
				{{ coq [[l1]] = [[l2]] }}
  | id1 == id2			::   :: eqID
				{{ tex [[id1]] = [[id2]] }}
				{{ coq [[id1]] = [[id2]] }}
  | ls1 == ls2                  ::   :: eqLabels
				{{ tex [[ls1]] = [[ls2]] }}
                                {{ coq lset_eq [[ls1]] [[ls2]] }}
  | l notin ls			::   :: l_notin_ls
      	    			{{ tex [[l]] \not\in [[ls]] }}
				{{ coq ( ~ set_In [[l]] [[ls]]) }}
  | l in ls			::   :: l_in_ls
      	    			{{ tex [[l]] \in [[ls]] }}
				{{ coq ( set_In [[l]] [[ls]]) }}
  | id in ids			::   :: id_in_ids
      	    			{{ tex [[id]] \in [[ids]] }}
				{{ coq ( set_In [[id]] [[ids]]) }}
  | module in system		::   :: module_in_system
    	       			{{ tex [[module]] \in [[system]] }}
				{{ coq In [[module]] [[system]] }}
  | product in products		::   :: product_in_products
    	       			{{ tex [[product]] \in [[products]] }}
				{{ coq In [[product]] [[products]] }}
  | block in blocks		::   :: block_in_blocks
    	       			{{ tex [[block]] \in [[blocks]] }}
				{{ coq In [[block]] [[blocks]] }}
  | insn in insns		::   :: insn_in_insns
    	       			{{ tex [[insn]] \in [[insns]] }}
				{{ coq In [[insn]] [[insns]] }}
  | arg in args			::   :: arg_in_args
    	       			{{ tex [[arg]] \in [[args]] }}
				{{ coq In [[arg]] [[args]] }}
  | noret = yes  		:: M :: noret_alias
    	     			{{ com noret alias }}
				{{ coq [[noret]] = true }}
  | typ = typ'  		:: M :: typ_alias
    	     			{{ com typ alias }}
				{{ coq [[typ]] = [[typ']] }}
  | targetdata = targetdata'    :: M :: targetdata_alias
    	     			{{ com targetdata alias }}
				{{ coq [[targetdata]] = [[targetdata']] }}
  | insn = insn'  		:: M :: insn_alias
    	     			{{ com insn alias }}
				{{ coq [[insn]] = [[insn']] }}
  | module = module'            :: M :: module_alias
    	     			{{ com module alias }}
				{{ coq [[module]] = [[module']] }}
  | system = system'            :: M :: system_alias
    	     			{{ com system alias }}
				{{ coq [[system]] = [[system']] }}
  | opt_id <-> opt_id' 		:: M :: opt_id_alias
    	     			{{ com opt_id alias }}
				{{ coq [[opt_id]] = [[opt_id']] }}
  | length </ constj // j /> = sz :: M :: length_of_consts_is_sz
                                {{ coq length [[ </ constj // j /> ]] = Size.to_nat[[sz]] }}
  | ids <-> </ idj // j /> 	:: M :: ids_alias
    	      	   	        {{ com ids alias }}
				{{ coq [[ids]] = [[ </ idj // j /> ]] }}
  | ls <-> </ lj // j /> 	:: M :: ls_alias
    	      	   	        {{ com ls alias }}
				{{ coq [[ls]] = [[ </ lj // j /> ]] }}
  | args <-> </ argj // j /> :: M :: args_alias
    	      	   	        {{ com args alias }}
				{{ coq [[args]] = [[ </ argj // j /> ]] }}
  | insns <-> </ insnj // j /> :: M :: insns_alias
    	      	   	        {{ com insns alias }}
				{{ coq [[insns]] = [[ </ insnj // j /> ]] }}
  | phinodes <-> </ phinodej // j /> :: M :: phis_alias
    	      	   	        {{ com phinodes alias }}
				{{ coq [[phinodes]] = [[ </ phinodej // j /> ]] }}
  | blocks <-> </ blockj // j /> :: M :: blocks_alias
    	      	   	        {{ com blocks alias }}
				{{ coq [[blocks]] = [[ </ blockj // j /> ]] }}
  | products = </ productj // j /> :: M :: products_alias
    	      	   	        {{ com products alias }}
				{{ coq [[products]] = [[ </ productj // j /> ]] }}
  | modules <-> </ modulej // j /> :: M :: modules_alias
    	      	   	        {{ com modules alias }}
				{{ coq [[modules]] = [[ </ modulej // j /> ]] }}
  | params <-> </ paramj // j /> :: M :: params_alias
                                {{ com params_alias }}
                                {{ coq [[params]] = [[ </ paramj // j /> ]] }}
  | insn =id= insn'        :: M :: getInsnID_eq
    	      	      	      	{{ tex [[insn]] =id= [[insn']] }}
				{{ coq getInsnID [[insn]] = getInsnID [[insn']] }}
  | insnsRemovesLast insns = insns'
    		     	        ::   :: insnsRemovesLast
    		     		{{ coq
                                    removelast [[insns]] = [[insns']]
                                }}
  | blockDominates fdef block1 block2
    		       	        ::   :: blockDominates
				{{ coq blockDominates [[fdef]] [[block1]] [[block2]] }}
  | blockStrictDominates fdef block1 block2
    		       	        ::   :: blockStrictDominates
				{{ coq blockStrictDominates [[fdef]] [[block1]] [[block2]] }}
  | insnDominates id1 insn2 block
    		       	        ::   :: insnDominates
				{{ coq insnDominates [[id1]] [[insn2]] [[block]] }}
  | genInsnUseDef module = usedef_insn		::   :: genInsnUseDef
    		  		{{ coq genInsnUseDef [[module]] = [[usedef_insn]] }}
  | genBlockUseDef_fdef fdef = usedef_block	::   :: genBlockUseDefFdef
    		  		{{ coq genBlockUseDef_fdef [[fdef]] = [[usedef_block]] }}
  | genBlockUseDef module = usedef_block	::   :: genBlockUseDef
    		  		{{ coq genBlockUseDef [[module]] = [[usedef_block]] }}
  | getIdUseDef usedef_id id = ids		::   :: getInsnUseDef
    		  		{{ coq getIdUseDef [[usedef_id]] [[id]] = [[ids]] }}
  | getBlockUseDef usedef_block	block = blocks      ::   :: getBlockUseDef
    		  		{{ coq getBlockUseDef [[usedef_block]] [[block]] = [[blocks]] }}
  | succOfBlock block module = blocks	::   :: succOfBlock
    		      		{{ coq succOfBlock [[block]] [[module]] = [[blocks]] }}
  | isReachableFromEntry fdef block  ::   :: isReachableFromEntry
                                {{ coq isReachableFromEntry [[fdef]] [[block]] }}
  | getInsnID insn = id		       ::   :: getInsnID
    	      	     		{{ coq getInsnID [[insn]] = [[id]] }}
  | getValueID value = opt_id	::   :: getValueID
    	      	     		{{ coq getValueID [[value]] = [[opt_id]] }}
  | getEntryBlock fdef = opt_block	        :: :: getEntryBlock
    	      	     		{{ coq getEntryBlock [[fdef]] = [[opt_block]] }}
  | predOfBlock block usedef_block = ls :: :: prefOfBlock
                                {{ coq predOfBlock [[block]] [[usedef_block]] = [[ls]] }}
  | getLabelsFromBlocks blocks = ls         :: :: getLabelsFromBlocks
                                {{ coq getLabelsFromBlocks [[blocks]] = [[ls]] }}
  | checkIdenticalIncomingValues phinode           :: :: checkIdenticalIncomingValues
                                {{ coq checkIdenticalIncomingValues [[phinode]] }}
  | lookupTypViaIDFromFdef fdef id = opt_typ :: :: lookupTypViaIDFromFdef
                                {{ coq lookupTypViaIDFromFdef [[fdef]] [[id]] = [[opt_typ]] }}
  | lookupTypViaTIDFromSystem system id = opt_typ :: :: lookupTypViaTIDFromSystem
                                {{ coq lookupTypViaTIDFromSystem [[system]] [[id]] = [[opt_typ]] }}
  | lookupTypViaGIDFromSystem system id = opt_typ :: :: lookupTypViaGIDFromSystem
                                {{ coq lookupTypViaGIDFromSystem [[system]] [[id]] = [[opt_typ]] }}
  | BinaryOperator.getFirstOperandType fdef insn = opt_typ  :: :: BinaryOperatorGetFirstOperandType
                                {{ coq BinaryOperator.getFirstOperandType [[fdef]] [[insn]] = [[opt_typ]] }}
  | BinaryOperator.getSecondOperandType fdef insn = opt_typ  :: :: BinaryOperatorGetSecondOperandType
                                {{ coq BinaryOperator.getSecondOperandType [[fdef]] [[insn]] = [[opt_typ]] }}
  | Typ.isIntOrIntVector typ :: :: TypIsIntOrIntVector
                                {{ coq Typ.isIntOrIntVector [[typ]] }}
  | CallSite.getCalledFunction insn system = opt_fdef :: :: CallSiteGetCalledFunction
                                {{ coq CallSite.getCalledFunction [[insn]] [[system]] = [[opt_fdef]] }}
  | CallSite.getFdefTyp fdef = typ      :: ::  CallSiteGetFdefTy
                                {{ coq CallSite.getFdefTyp [[fdef]] = [[typ]] }}
  | FunctionType.getNumParams typ = opt_INT :: :: FunctionTypeGetNumParams
                                {{ coq FunctionType.getNumParams [[typ]] = [[opt_INT]] }}
  | CallSite.arg_size fdef = INT :: :: CallSiteArgSize
                                {{ coq CallSite.arg_size [[fdef]] = [[INT]] }}
  | Function.getDefReturnType fdef = typ :: :: FunctionGetDefReturnType
                                {{ coq Function.getDefReturnType [[fdef]] = [[typ]] }}
  | getInsnTyp insn = opt_typ :: :: getInsnTyp
                                {{ coq getInsnTyp [[insn]] = [[opt_typ]] }}
  | getInsnOperands insn = ids :: :: getInsnOperands
                                {{ coq getInsnOperands [[insn]] = [[ids]] }}
  | getInsnLabels insn = ls :: :: getInsnLabels
                                {{ coq getInsnLabels [[insn]] = [[ls]] }}
  | checkIndexes targetdata typ </ constj // j /> = typ' :: :: checkIndexes
      {{ coq (exists idxs, exists o, intConsts2Nats [[targetdata]] [[ </ constj // j /> ]] = Some idxs /\ mgetoffset [[targetdata]] [[typ]] idxs = Some (o, [[typ']])) }}
  | getSubTypFromConstIdxs </ constj // j /> typ = opt_typ :: :: getSubTypFromConstIdxs
                                {{ coq getSubTypFromConstIdxs [[ </ constj // j /> ]] [[typ]] = [[opt_typ]] }}
  | getConstGEPTyp </ constj // j /> typ = opt_typ :: :: getConstGEPTyp
                                {{ coq getConstGEPTyp [[ </ constj // j /> ]] [[typ]] = [[opt_typ]] }}
  | getGEPTyp </ szj , valuej // j /> typ = opt_typ :: :: getGEPTyp
                                {{ coq getGEPTyp [[ </ szj , valuej // j /> ]] [[typ]] = [[opt_typ]] }}
  | Typ.isSized typ :: :: TypIsSized
                                {{ coq Typ.isSized [[typ]] = true }}
  | lookupBlockViaLabelFromFdef fdef l = opt_stmts :: :: lookupBlockViaLabelFromFdef
                                {{ coq lookupBlockViaLabelFromFdef [[fdef]] [[l]] = [[opt_stmts]] }}
  | Typ.getPrimitiveSizeInBits typ = sz :: :: TypgetPrimitiveSizeInBits
                                {{ coq Typ.getPrimitiveSizeInBits [[typ]] = [[sz]] }}
  | isPhiNode insn :: :: isPhiNode
                                {{ coq isPhiNode [[insn]] }}
  | insn in fdef , block :: :: insnInFdef
    	    	     		{{ coq insnInFdefBlockB [[insn]] [[fdef]] [[block]] = true }}
  | insn in system , module , fdef , block :: :: insnInSystem
    	    	     		{{ coq insnInSystemModuleFdefBlockB [[insn]] [[system]] [[module]] [[fdef]] [[block]] = true }}
  | lookupBlockViaIDFromFdef fdef id = opt_block :: :: lookupBlockViaIDFromFdef
                                {{ coq lookupBlockViaIDFromFdef [[fdef]] [[id]] = [[opt_block]] }}
  | getLabelViaIDFromPhiNode phinode id = opt_l :: :: getLabelViaIDFromPhiNode
                                {{ coq getLabelViaIDFromPhiNode [[phinode]] [[id]] = [[opt_l]] }}
%  | lookupBindingViaIDFromFdef fdef id = id_binding :: :: lookupBindingViaIDFromFdef
%                                {{ coq lookupBindingViaIDFromFdef [[fdef]] [[id]] = [[id_binding]] }}
%  | lookupBindingViaIDFromSystem system id = id_binding :: :: lookupBindingViaIDFromSystem
%                                {{ coq lookupBindingViaIDFromSystem [[system]] [[id]] = [[id_binding]] }}
  | getBindingTyp id_binding = opt_typ :: :: getBindingTyp
                                {{ coq getBindingTyp [[id_binding]] = [[opt_typ]] }}
  | getPointerEltTyp typ1 = opt_typ2 :: :: getPointerEltTyp
                                {{ coq getPointerEltTyp [[typ1]] = [[opt_typ2]] }}
  | getFdecID fdec = id             :: :: getFdecID
    	      	     		{{ coq getFdecID [[fdec]] = [[id]] }}
  | argInFdef arg fdef           :: :: argInFdef
                                {{ coq argInFdefB [[arg]] [[fdef]] = true }}
  | floating_point1 < floating_point2  :: :: floating_point_order
    			        {{ coq floating_point_order [[floating_point1]] [[floating_point2]] = true }}
  | getLabelViaIDPhiNode insn id = opt_l :: :: getLabelViaIDPhiNode
                                {{ coq getLabelViaIDPhiNode [[insn]] [[id]] = [[opt_l]] }}
  | getCalledValue insn = opt_value    :: :: getCalledValue
                                {{ coq getCalledValue [[insn]] = [[opt_value]] }}
  | getCalledValueID insn = opt_id    :: :: getCalledValueID
                                {{ coq getCalledValueID [[insn]] = [[opt_id]] }}
  | blockInFdef block fdef       :: :: blockInFdef
                                {{ coq blockInFdefB [[block]] [[fdef]] = true }}
  | block in system , module , fdef :: :: blockInSystem
                                {{ coq blockInSystemModuleFdefB [[block]] [[system]] [[module]] [[fdef]] = true }}
  | product in system , module :: :: productInSystem
                                {{ coq productInSystemModuleB [[product]] [[system]] [[module]] = true }}
  | uniqSystem system               :: :: uniqSystem
                                {{ coq uniqSystem [[system]] }}
  | typ =t= typ'                     :: :: typEq
                                {{ coq typEqB [[typ]] [[typ']] = true }}
  | isCallInsn insn                 :: :: isCallInsn
                                {{ coq isCallInsnB [[insn]] = true }}
  | getPhiNodeOperands phinode = ids :: :: getPhiNodeOperands
                                {{ coq getPhiNodeOperands [[phinode]] = [[ids]] }}
  | getLabelsFromPhiNode phinode = ls :: :: getLabelsFromPhiNode
                                {{ coq getLabelsFromPhiNode [[phinode]] = [[ls]] }}
  | lookupFdefViaIDFromSystem system id = opt_fdef :: :: lookupFdefViaIDFromSystem
                                {{ coq lookupFdefViaIDFromSystem [[system]] [[id]] = [[opt_fdef]] }}
  | isPointerTyp typ    :: :: isPointerTyp
    		     	        {{ coq isPointerTyp [[typ]] }}
  | isFunctionPointerTyp typ    :: :: isFunctionPointerTyp
    		     	        {{ coq isFunctionPointerTyp [[typ]] }}
  | isAggregateTyp typ    :: :: isAggregateTyp
    		     	        {{ coq isAggregateTyp [[typ]] }}
  | isValidReturnTyp typ    :: :: isValidReturnTyp
    		     	        {{ coq isValidReturnTyp [[typ]] }}
  | isValidArgumentTyp typ    :: :: isValidArgumentTyp
    		     	        {{ coq isValidArgumentTyp [[typ]] }}
  | isValidElementTyp typ    :: :: isValidElementTyp
    		     	        {{ coq isValidElementTyp [[typ]] }}
  | isFirstClassTyp typ    :: :: isFirstClassTyp
    		     	        {{ coq isFirstClassTyp [[typ]] }}
  | isBindingFdec id_binding = fdec  :: :: isBindingFdec
    		     	        {{ coq isBindingFdec [[id_binding]] = Some [[fdec]] }}
  | isBindingArg id_binding = arg   :: :: isBindingArg
    		     	        {{ coq isBindingArg [[id_binding]] = Some [[arg]] }}
  | isBindingGvar id_binding = gvar   :: :: isBindingGvar
    		     	        {{ coq isBindingGvar [[id_binding]] = Some [[gvar]] }}
  | isBindingInsn id_binding = insn   :: :: isBindingInsn
    		     	        {{ coq isBindingInsn [[id_binding]] = Some [[insn]] }}
  | v in sv                           ::   :: vinsv
  | ( gl , lc ) ( value ) = opt_sv    ::   :: value2sv
  | ( module , ft ) ( v ) = opt_fdef  ::   :: lookupfdef
  | ( gl , lc ) ( params ) = opt_svs  ::   :: params2svs
  | init_locals gl lc fdef = lc'      ::   :: initlocals
  | typ_eq_list_typ namedts typ </ typj // j /> :: :: typ_eq_list_typ
      {{ coq typ_eq_list_typ [[namedts]] [[typ]] [[ </ typj // j /> ]] = true }}
  | check_operand fdef block insn id' ::   :: checkoperand
      {{ coq (((exists block', lookupBlockViaIDFromFdef [[fdef]] [[id']] = Some block' /\ (insnDominates [[id']] [[insn]] [[block]] \/ blockStrictDominates [[fdef]] block' [[block]])) \/ not (isReachableFromEntry [[fdef]] [[block]])) \/ In [[id']] (getArgsIDsOfFdef [[fdef]])) }}

parsing
formula_true left formula_not
formula_false left formula_not
formula_and left formula_and
formula_or left formula_or
formula_not left formula_or
formula_not left formula_and
formula_or left formula_seq
formula_seq left formula_seq
formula_or left formula_ifthenelse
formula_ifthenelse left formula_seq
formula_and left formula_and
formula_multiline <= formula_and
formula_multiline <= formula_or

defns
Jwf_styp :: '' ::=
      defn
      system , targetdata |-i typ :: :: wf_styp :: 'wf_styp_' {{ com }} by

      sz > 0
      {{ (LLVMtd.getIntAlignmentInfo [[layouts]] (Size.to_nat [[sz]]) true > 0)%nat }}
      -------------------------------------------------------------- :: int
      system , (layouts namedts) |-i int sz

      {{ (LLVMtd.getFloatAlignmentInfo [[layouts]] 32%nat true > 0)%nat }}
      -------------------------------------------------------------- :: float
      system , (layouts namedts) |-i float

      {{ (LLVMtd.getFloatAlignmentInfo [[layouts]] 64%nat true > 0)%nat }}
      -------------------------------------------------------------- :: double
      system , (layouts namedts) |-i double

      %-------------------- :: wf_typ_void
      %system |- void

      %-------------------- :: wf_typ_label
      %system |- label

      %-------------------- :: wf_typ_metadate
      %system |- metadata

      isValidReturnTyp typ
      system , (layouts namedts) |-i typ
      </ isValidArgumentTyp typj // j />
      </ system , (layouts namedts) |-i typj // j />
      {{ (LLVMtd.getPointerAlignmentInfo [[layouts]] true > 0)%nat }}
      -------------------------------------------------- :: function
      system , (layouts namedts) |-i typ ( </ typj // j /> varg ) *

      </ isValidElementTyp typj // j />
      </ system , targetdata |-i typj // j />
      -------------------------------------------------- :: structure
      system , targetdata |-i { </ typj // j /> }

      system , targetdata |-i typ
      isValidElementTyp typ
      -------------------------------------------------- :: array
      system , targetdata |-i [ sz * typ ]

      system , (layouts namedts) |-i typ
      isValidElementTyp typ
      {{ (LLVMtd.getPointerAlignmentInfo [[layouts]] true > 0)%nat }}
      -------------------------------------------------- :: pointer
      system , (layouts namedts) |-i typ *

      % |- typ
      % isValidElementTyp typ
      % ------------------- :: wf_typ_vector
      % |- < Int * typ >

      {{ lookupAL _ [[namedts]] [[id]] <> None }}
      -------------------------------------------------- :: namedt
      system , (layouts namedts) |-i id

defns
Jnoncycled :: '' ::=
      defn
      system , layouts |- namedts :: :: noncycled :: 'noncycled_' {{ com }} by

      -------------------------------------------------------------- :: nil
      system , layouts |- []

      system , layouts |- namedts
      system , (layouts namedts) |-i { </ typj // j /> }
      -------------------------------------------------------------- :: cons
      system, layouts |- id = { </ typj // j /> } , namedts


defns
Jwf_typ :: '' ::=
      defn
      system , targetdata |- typ :: :: wf_typ :: '' {{ com [[typ]] is well-formed }} by

      system , layouts |- namedts
      system , (layouts namedts) |-i typ
      {{ uniq [[namedts]] }}
      -------------------------------------------------------------- :: wf_typ_intro
      system , (layouts namedts) |- typ


defns
Jwf_const :: '' ::=
      defn
      system , targetdata |-c const : typ :: :: wf_const :: ''
      {{ com [[const]] has [[typ]] }} by

      system , targetdata |- typ
      ---------------------------------------------------------- :: wf_const_zeroinitializer
      system , targetdata |-c typ zeroinitializer : typ


      system , targetdata |- int sz
      ------------------------------------------ :: wf_const_int
      system , targetdata |-c (int sz) Int : int sz

      system , targetdata |- floating_point
      --------------------------------------------------------- :: wf_const_floatpoint
      system , targetdata |-c floating_point Float : floating_point

      system , targetdata |- typ
      --------------------------- :: wf_const_undef
      system , targetdata |-c typ undef : typ

      system , targetdata |- typ*
      --------------------------------------- :: wf_const_null
      system , targetdata |-c (typ*) null : typ*

      </ system , targetdata |-c constj : typ // j />
      length </ constj // j /> = sz
      system , targetdata |- [sz * typ]
      ----------------------------------------------------------- :: wf_const_arr
      system , targetdata |-c typ [ </ constj // j /> ] : [sz * typ]

      </ system , targetdata |-c constj : typj // j />
      </ system , targetdata |- typj // j />
      typ_eq_list_typ namedts typ </ typj // j />
      targetdata = ( layouts namedts )
      system , targetdata |- typ
      -------------------------------------------------------------------------------------- :: wf_const_struct
      system , ( layouts namedts ) |-c typ { </ constj // j /> } : typ


      system , targetdata |- typ*
      lookupTypViaGIDFromSystem system id = typ*
      {{ Constant.unifiable_typ [[targetdata]] [[:user_syntax__typ:typ]] }}
      -------------------------------------------------------------------- :: wf_const_gid
      system , targetdata |-c typ * id : typ*

      system , targetdata |-c const : int sz1
      system , targetdata |- int sz2
      sz2 < sz1
      system , targetdata |- int sz1
      ----------------------------------------------------------- :: wf_const_trunc_int
      system , targetdata |-c trunc_int const to (int sz2) : int sz2

      system , targetdata |-c const : floating_point1
      floating_point2 < floating_point1
      system , targetdata |- floating_point1
      system , targetdata |- floating_point2
      ------------------------------------------------------------------------ :: wf_const_trunc_fp
      system , targetdata |-c trunc_int const to floating_point2 : floating_point2

      system , targetdata |-c const : int sz1
      system , targetdata |- int sz1
      system , targetdata |- int sz2
      sz1 < sz2
      --------------------------------------------------------- :: wf_const_zext
      system , targetdata |-c zext const to (int sz2) : int sz2

      system , targetdata |-c const : int sz1
      system , targetdata |- int sz1
      system , targetdata |- int sz2
      sz1 < sz2
      --------------------------------------------------------- :: wf_const_sext
      system , targetdata |-c sext const to (int sz2) : int sz2

      system , targetdata |-c const : floating_point1
      floating_point1 < floating_point2
      system , targetdata |- floating_point1
      system , targetdata |- floating_point2
      -------------------------------------------------------------------------- :: wf_const_fpext
      system , targetdata |-c fpext const to floating_point2 : floating_point2

      % system , targetdata |-c const : floating_point
      % targetdata |- floating_point
      % system |- int sz
      % ---------------------------------------------------------- :: wf_const_fptoui
      % system , targetdata |-c fptoui const to (int sz) : int sz

      % system , targetdata |-c const : floating_point
      % targetdata |- floating_point
      % system |- int sz
      % --------------------------------------------------------- :: wf_const_fptosi
      % system , targetdata |-c fptosi const to (int sz) : int sz

      % system , targetdata |-c const : int sz
      % targetdata |- int sz
      % system |- floating_point
      % ------------------------------------------------------------------------ :: wf_const_uitofp
      % system , targetdata |-c uitofp const to floating_point : floating_point

      % system , targetdata |-c const : int sz
      % targetdata |- int sz
      % system |- floating_point
      % ------------------------------------------------------------------------ :: wf_const_sitofp
      % system , targetdata |-c sitofp const to floating_point : floating_point

      system , targetdata |-c const : typ*
      system , targetdata |- typ*
      system , targetdata |- int sz
      ------------------------------------------------------------- :: wf_const_ptrtoint
      system , targetdata |-c ptrtoint const to (int sz) : int sz

      system , targetdata |-c const : int sz
      system , targetdata |- int sz
      system , targetdata |- typ*
      --------------------------------------------------------- :: wf_const_inttoptr
      system , targetdata |-c inttoptr const to (typ*) : typ*

      % Check typs
      system , targetdata |-c const : typ1*
      system , targetdata |- typ1*
      system , targetdata |- typ2*
      % BitCast implies a no-op cast of type only. No bits change.
      % However, you can't cast pointers to anything but pointers.
      %typ1 = int sz1 /\ typ2 = int sz2 /\ sz1 = sz2
      % Bitcast requires types of same width.
      %isPointerTyp typ1 iff isPointerTyp typ2
      % Disallow aggregates.
      %(not isAggregateTyp typ1) /\ (not isAggregateTyp typ2)
      ------------------------------------------------------- :: wf_const_bitcast
      system , targetdata |-c bitcast const to typ2* : typ2*

      % Check typs
      system , targetdata |-c const : typ*
      system , targetdata |- typ*
      </ system , targetdata |-c constj : typ'' // j />
      typ'' = i32
      % Check indexs
      getConstGEPTyp </ constj // j /> (typ*) = typ'
      system , targetdata |- typ'
      ------------------------------------------------------------------------- :: wf_const_gep
      system , targetdata |-c getelementptr inbounds const </ constj // j /> : typ'

      % Check typs
      system , targetdata |-c const0 : int sz
      sz = 1
      system , targetdata |-c const1 : typ
      system , targetdata |-c const2 : typ
      system , targetdata |- int sz
      system , targetdata |- typ
      ----------------------------------------------------- :: wf_const_select
      system , targetdata |-c select const0 const1 const2 : typ

      % Check typs
      system , targetdata |-c const1 : typ
      system , targetdata |-c const2 : typ
      system , targetdata |- typ
      % types can only be int, vector or ptr
      Typ.isIntOrIntVector typ \/ isPointerTyp typ
      system , targetdata |- int sz
      sz = 1
      --------------------------------------------------------- :: wf_const_icmp
      system , targetdata |-c icmp cond const1 const2 : int sz

      {{ wf_fcond [[fcond]] = true }}
      % Check typs
      system , targetdata |-c const1 : floating_point
      system , targetdata |-c const2 : floating_point
      system , targetdata |- floating_point
      system , targetdata |- int sz
      sz = 1
      ------------------------------------------------------------- :: wf_const_fcmp
      system , targetdata |-c fcmp fcond const1 const2 : int sz


      % Check typs
      system , targetdata |-c const : typ
      system , targetdata |- typ
      </ system , targetdata |-c constj : typ'' // j />
      typ'' = i32
      system , targetdata |- typ''
      % Check indexs
      checkIndexes targetdata typ </ constj // j /> = typ'
      system , targetdata |- typ'
      --------------------------------------------------------------------- :: wf_const_extractvalue
      system , targetdata |-c extractvalue const </ constj // j /> : typ'

      % Check typs
      system , targetdata |-c const : typ
      system , targetdata |-c const' : typ'
      system , targetdata |- typ'
      </ system , targetdata |-c constj : typ'' // j />
      typ'' = i32
      system , targetdata |- typ''
      % Check indexs
      checkIndexes targetdata typ </ constj // j /> = typ'
      system , targetdata |- typ
      ------------------------------------------------------------------------- :: wf_const_insertvalue
      system , targetdata |-c insertvalue const const' </ constj // j /> : typ

      % Check typs
      system , targetdata |-c const1 : int sz
      system , targetdata |-c const2 : int sz
      system , targetdata |- int sz
      ----------------------------------------------- :: wf_const_bop
      system , targetdata |-c bop const1 const2 : int sz

      % Check typs
      system , targetdata |-c const1 : floating_point
      system , targetdata |-c const2 : floating_point
      system , targetdata |- floating_point
      -------------------------------------------------------- :: wf_const_fbop
      system , targetdata |-c fbop const1 const2 : floating_point

defns
Jwf_value :: '' ::=
      defn
      system , module , fdef |- value : typ :: :: wf_value :: ''
      {{ com [[value]] has [[typ]] wrt [[system]] and [fdef] }} by

      system , (layouts namedts) |-c const : typ
      system , (layouts namedts) |- typ
      --------------------------------------------------------- :: wf_value_const
      system , (layouts namedts products) , fdef |- const : typ

      system , (layouts namedts) |- typ
      lookupTypViaIDFromFdef fdef id = typ
      ------------------------------------------ :: wf_value_id
      system , (layouts namedts products) , fdef |- id : typ

defns
Jwf_operand :: '' ::=
      defn
      fdef , block , insn |- id' :: :: wf_operand :: ''
      {{ com [[id']] is well-formed w.r.t [[insn]] [[block]] in [[fdef]] }} by

      insn in fdef , block
      getInsnOperands insn = ids
      id' in ids
      notT isPhiNode insn
      check_operand fdef block insn id'
      -------------------------------------------------------- :: wf_operand_intro
      fdef , block , insn |- id'

defns
Jwf_insn_base :: '' ::=
      defn
      fdef , block |-i insn :: :: wf_insn_base :: ''
      {{ com [[insn]] is well-formed w.r.t [[block]] in [[fdef]] }} by
      % Verifier::visitInstruction

      % Instruction must be embedded in basic block!
      insn in fdef , block
      % Check that non-phi nodes are not self referential in wf_insn_base::PhiNode
      %
      % Verify that if this is a terminator that it is at the end of the block in wf_block
      %
      % Check that void typed values don't have names
      % We dont need to check this in Ott
      %
      % Check that the return value of the instruction is either void or a legal value type.
      %  getInsnTyp insn = typ
      %  typ =t= void \/ isFirstClassTyp typ
      % Check that the instruction doesn't produce metadata or metadata*. Calls
      % all already checked against the callee type.
      %   (not typ =t= metadata) \/ isCallInsn insn
      % Instructions may not produce pointer to metadata.
      %   (isPointerTyp typ) implies (getPointerEltTyp typ = typ' /\ (not typ' =t= metadata))
      % Check that all uses of the instruction, if they are instructions
      % themselves, actually have parent basic blocks.  If the use is not an
      % instruction, it is an error!
      % We should prove a lemma for this later.
      %
      % Check operands
      getInsnOperands insn = ids
      ids <-> </ idj // j />
      </ fdef , block , insn |- idj // j />
      -------------------------------------------------------------------------------------- :: wf_insn_base_intro
      fdef , block |-i insn

defns
Jwf_cast :: '' ::=
      defn
      system , module , fdef , block |-cast insn :: :: wf_cast :: ''
      {{ com cast [[insn]] is well-formed w.r.t [[block]] in [[fdef]] in [[module]] [[system]] }} by

      % Check typs
      system , (layouts namedts products) , fdef |- value1 : typ *
      system , (layouts namedts) |- int sz
      % Check invariance for instructions
      fdef , block |-i id = ptrtoint ( typ * ) value1 to ( int sz )
      ------------------------------------------------------------------------------------------------------- :: wf_cast_ptrtoint
      system , (layouts namedts products) , fdef , block |-cast id = ptrtoint ( typ * ) value1 to ( int sz )


      % Check typs
      system , (layouts namedts products) , fdef |- value1 : int sz
      system , (layouts namedts) |- typ *
      % Check invariance for instructions
      fdef , block |-i id = inttoptr ( int sz ) value1 to ( typ * )
      ------------------------------------------------------------------------------------------------------------ :: wf_cast_inttoptr
      system , (layouts namedts products) , fdef , block |-cast id = inttoptr ( int sz ) value1 to ( typ * )


      % Check typs
      system , (layouts namedts products) , fdef |- value1 : typ1*
      system , (layouts namedts) |- typ2 *
      % BitCast implies a no-op cast of type only. No bits change.
      % However, you can't cast pointers to anything but pointers.
      %Typ.getPrimitiveSizeInBits typ1 = sz1 /\ Typ.getPrimitiveSizeInBits typ2 = sz2 /\ sz1 = sz2
      % Bitcast requires types of same width.
      %isPointerTyp typ1 iff isPointerTyp typ2
      % Disallow aggregates.
      %(not isAggregateTyp typ1) /\ (not isAggregateTyp typ2)
      % Check invariance for instructions
      fdef , block |-i id = bitcast typ1* value1 to typ2*
      system , (layouts namedts) |- typ2*
      --------------------------------------------------------------------------------------------- :: wf_cast_bitcast
      system , (layouts namedts products) , fdef , block |-cast id = bitcast typ1* value1 to typ2*

defns
Jwf_trunc :: '' ::=
      defn
      system , module , fdef , block |-trunc insn :: :: wf_trunc :: ''
      {{ com trunc [[insn]] is well-formed w.r.t [[block]] in [[fdef]] in [[module]] [[system]] }} by

      % Check typs
      system , (layouts namedts products) , fdef |- value1 : int sz1
      system , (layouts namedts) |- int sz2
      % bitwidth of dest typ is less then src typ
      sz2 < sz1
      % Check invariance for instructions
      fdef , block |-i id = trunc_int ( int sz1 ) value1 to ( int sz2 )
      ----------------------------------------------------------------------------------------------- :: wf_trunc_int
      system , (layouts namedts products) , fdef , block |-trunc id = trunc_int ( int sz1 ) value1 to ( int sz2 )

      % Check typs
      system , (layouts namedts products) , fdef |- value1 : floating_point1
      system , (layouts namedts) |- floating_point1
      % bitwidth of dest typ is less then src typ
      floating_point2 < floating_point1
      % Check invariance for instructions
      fdef , block |-i id = trunc_fp floating_point1 value1 to floating_point2
      system , (layouts namedts) |- floating_point2
      ----------------------------------------------------------------------------------------------- :: wf_trunc_fp
      system , (layouts namedts products) , fdef , block |-trunc id = trunc_fp floating_point1 value1 to floating_point2

defns
Jwf_ext :: '' ::=
      defn
      system , module , fdef , block |-ext insn :: :: wf_ext :: ''
      {{ com ext [[insn]] is well-formed w.r.t [[block]] in [[fdef]] in [[module]] [[system]] }} by

      % Check typs
      system , (layouts namedts products) , fdef |- value1 : int sz1
      system , (layouts namedts) |- int sz2
      % bitwidth of src typ is less then dest typ
      sz1 < sz2
      % Check invariance for instructions
      fdef , block |-i id = zext ( int sz1 ) value1 to ( int sz2 )
      ------------------------------------------------------------------------------------------------------- :: wf_ext_z
      system , (layouts namedts products) , fdef , block |-ext id = zext ( int sz1 ) value1 to ( int sz2 )

      % Check typs
      system , (layouts namedts products) , fdef |- value1 : int sz1
      system , (layouts namedts) |- int sz2
      % bitwidth of src typ is less then dest typ
      sz1 < sz2
      % Check invariance for instructions
      fdef , block |-i id = sext ( int sz1 ) value1 to ( int sz2 )
      ------------------------------------------------------------------------------------------------------- :: wf_ext_s
      system , (layouts namedts products) , fdef , block |-ext id = sext ( int sz1 ) value1 to ( int sz2 )

      % Check typs
      system , (layouts namedts products) , fdef |- value1 : floating_point1
      system , (layouts namedts) |- floating_point1
      % bitwidth of src typ is less then dest typ
      floating_point1 < floating_point2
      % Check invariance for instructions
      fdef , block |-i id = fpext floating_point1 value1 to floating_point2
      system , (layouts namedts) |- floating_point2
      ------------------------------------------------------------------------------------------------------- :: wf_ext_fp
      system , (layouts namedts products) , fdef , block |-ext id = fpext floating_point1 value1 to floating_point2

defns
Jwf_insn :: '' ::=
      defn
      system , module , fdef , block |- insn :: :: wf_insn :: ''
      {{ com [[insn]] is well-formed w.r.t [[block]] in [[fdef]] in [[module]] [[system]] }} by

      % Check typs
      system , module , fdef |- value : typ
      % Exactly one return value and it matches the return type. Good.
      Function.getDefReturnType fdef = typ
      % Check invariance for instructions
      fdef , block |-i id = ret typ value
      ------------------------------------------------------ :: wf_insn_return
      system , module , fdef , block |- id = ret typ value

      % return instr that returns void in Function can be of void return type!
      Function.getDefReturnType fdef = void
      % Check invariance for instructions
      fdef , block |-i id = ret void
      ------------------------------------------------------- :: wf_insn_return_void
      system , module , fdef , block |- id = ret void

      % Check typs
      system , module , fdef |- value : int sz
      sz = 1
      % Check labels
      lookupBlockViaLabelFromFdef fdef l1 = stmts1
      lookupBlockViaLabelFromFdef fdef l2 = stmts2
      not (l1 = l2)
      % Check invariance for instructions
      fdef , block |-i id = br value l1 l2
      -------------------------------------------------------------------------------------- :: wf_insn_br
      system , module , fdef , block |- id = br value l1 l2

      % Check typs
      system , module , fdef |- value : typ
      typ = int sz
      % Check labels
      </ lookupBlockViaLabelFromFdef fdef lj = stmtsj // j />
      lookupBlockViaLabelFromFdef fdef l = stmts
      % Uniqueness, needed for typings_props#successors_codom__uniq
      % {{ NoDup ([[l]] :: List.map (compose snd fst) [[ls]]) }} --> it creates a new label list, not from const_l_stmts_list
      {{ NoDup ([[l]] :: (List.map (compose snd fst) const_l_stmts_list)) }}
      fdef , block |-i id = switch typ value l </ [ constj , lj ] // j />
      -------------------------------------------------------------------------------------- :: wf_insn_switch
      system , module , fdef , block |- id = switch typ value l </ [ constj , lj ] // j />

      % Check labels
      lookupBlockViaLabelFromFdef fdef l0 = stmts0
      % Check invariance for instructions
      fdef , block |-i id = br l0
      -------------------------------------------------------------------------------------- :: wf_insn_br_uncond
      system , module, fdef , block |- id = br l0

      % fdef , block |-i id = invoke typ0 id0 params to l1 unwind l2
      % -------------------------------------------------------------------------------------- :: wf_insn_invoke
      % system , module, fdef , block |- id = invoke typ0 id0 params to l1 unwind l2

      % Check invariance for instructions
      fdef , block |-i id = unreachable
      -------------------------------------------------------------------------------------- :: wf_insn_unreachable
      system , module, fdef , block |- id = unreachable

      % Check typs
      system , module , fdef |- value1 : int sz
      system , module , fdef |- value2 : int sz
      % Check that integer arithmetic operators are only used with integral operands.
      % Integer arithmetic operators only work with integral types
      % Typ.isIntOrIntVector typ
      % Check invariance for instructions
      fdef , block |-i id = bop (int sz) value1 value2
      -------------------------------------------------------------------------------------- :: wf_insn_bop
      system , module, fdef , block |- id = bop (int sz) value1 value2

      % Check typs
      system , module , fdef |- value1 : floating_point
      system , module , fdef |- value2 : floating_point
      % Check that integer arithmetic operators are only used with integral operands.
      % Integer arithmetic operators only work with integral types
      % Typ.isIntOrIntVector typ
      % Check invariance for instructions
      fdef , block |-i id = fbop floating_point value1 value2
      ----------------------------------------------------------------------------------------------------- :: wf_insn_fbop
      system , module, fdef , block |- id = fbop floating_point value1 value2

      % Check typs
      system , (layouts namedts products) , fdef |- value : typ
      </ system , targetdata |-c constj : typ'' // j />
      typ'' = i32
      % Check indexs
      checkIndexes targetdata typ </ constj // j /> = typ'
      system , targetdata |- typ'
      targetdata = (layouts namedts)
      % Check invariance for instructions
      fdef , block |-i id = extractvalue typ value </ constj // j /> typ'
      -------------------------------------------------------------------------------------- :: wf_insn_extractvalue
      system , (layouts namedts products) , fdef , block |- id = extractvalue typ value </ constj // j /> typ'

      % Check typs
      system , (layouts namedts products) , fdef |- value : typ
      system , (layouts namedts products) , fdef |- value' : typ'
      </ system , targetdata |-c constj : typ'' // j />
      typ'' = i32
      % Check indexs
      checkIndexes targetdata typ </ constj // j /> = typ'
      targetdata = (layouts namedts)
      % Check invariance for instructions
      fdef , block |-i id = insertvalue typ value typ' value' </ constj // j />
      -------------------------------------------------------------------------------------- :: wf_insn_insertvalue
      system , (layouts namedts products) , fdef , block |- id = insertvalue typ value typ' value' </ constj // j />

      % Allocation instruction pointer not in the generic address space!
      %
      % Alloca array size must be i32
      system , (layouts namedts products) , fdef |- value : int sz
      sz = 32
      %
      % Cannot allocate unsized type"
      system , (layouts namedts) |- typ
      {{ Constant.unifiable_typ [[(layouts namedts)]] [[:user_syntax__typ:typ]] }}
      % Check invariance for instructions
      fdef , block |-i id = malloc typ value align
      --------------------------------------------------------------------------------------------------- :: wf_insn_malloc
      system , (layouts namedts products) , fdef , block |- id = malloc typ value align

      % Check typs
      system , module , fdef |- value : typ*
      % Check invariance for instructions
      fdef , block |-i id = free (typ*) value
      -------------------------------------------------------------------------------------- :: wf_insn_free
      system , module , fdef , block |- id = free (typ*) value

      % Allocation instruction pointer not in the generic address space!
      %
      % Alloca array size must be i32
      system , (layouts namedts products) , fdef |- value : int sz
      sz = 32
      %
      % Cannot allocate unsized type"
      system , (layouts namedts) |- typ
      {{ Constant.unifiable_typ [[(layouts namedts)]] [[:user_syntax__typ:typ]] }}
      % Check invariance for instructions
      fdef , block |-i id = alloca typ value align
      -------------------------------------------------------------------------------------------------- :: wf_insn_alloca
      system , (layouts namedts products) , fdef , block |- id = alloca typ value align

      % Load operand must be a pointer.
      system , (layouts namedts products) , fdef |- value1 : typ1*
      system , (layouts namedts) |- typ1
      % Check invariance for instructions
      fdef , block |-i id = load (typ1*) value1 align
      ------------------------------------------------------------------------------------------------------- :: wf_insn_load
      system , (layouts namedts products) , fdef , block |- id = load (typ1*) value1 align

      % Store operand must be a pointer.
      system , (layouts namedts products) , fdef |- value1 : typ
      system , (layouts namedts products) , fdef |- value2 : typ*
      system , (layouts namedts) |- typ
      % Check invariance for instructions
      fdef , block |-i id = store typ value1 value2 align
      --------------------------------------------------------------------------------------------------------- :: wf_insn_store
      system , (layouts namedts products) , fdef , block |- id = store typ value1 value2 align

      % Check typs
      system , (layouts namedts products) , fdef |- value : typ*
      module = (layouts namedts products)
      </ system , module , fdef |- valuej : typ'' // j />
      typ'' = i32
      % Check indexs
      getGEPTyp </ szj , valuej // j /> typ = typ'*
      system , (layouts namedts) |- typ'*
      % Check invariance for instructions
      fdef , block |-i id = getelementptr inbounds (typ*) value </ szj , valuej // j /> (typ'*)
      ---------------------------------------------------------------------------------------- :: wf_insn_gep
      system , (layouts namedts products) , fdef , block |- id = getelementptr inbounds (typ*) value </ szj , valuej // j /> (typ'*)


      system , module , fdef , block |-trunc id = truncop typ1 value1 to typ2
      ---------------------------------------------------------------------------------------------------- :: wf_insn_trunc
      system , module , fdef , block |- id = truncop typ1 value1 to typ2

      system , module , fdef , block |-ext id = extop typ1 value1 to typ2
      ---------------------------------------------------------------------------------------------------- :: wf_insn_ext
      system , module , fdef , block |- id = extop typ1 value1 to typ2


      system , module , fdef , block |-cast id = castop typ1 value1 to typ2
      ---------------------------------------------------------------------------------------------------- :: wf_insn_cast
      system , module , fdef , block |- id = castop typ1 value1 to typ2


      % Check typs
      system , (layouts namedts products) , fdef |- value1 : typ
      system , (layouts namedts products) , fdef |- value2 : typ
      % types can only be int, vector or ptr
      Typ.isIntOrIntVector typ \/ isPointerTyp typ
      system , (layouts namedts) |- int sz
      sz = 1
      % Check invariance for instructions
      fdef , block |-i id = icmp cond typ value1 value2
      --------------------------------------------------------------------------------------------------- :: wf_insn_icmp
      system , (layouts namedts products) , fdef , block |- id = icmp cond typ value1 value2


      {{ wf_fcond [[fcond]] = true }}
      % Check typs
      system , (layouts namedts products) , fdef |- value1 : floating_point
      system , (layouts namedts products) , fdef |- value2 : floating_point
      system , (layouts namedts) |- int sz
      sz = 1
      % Check invariance for instructions
      fdef , block |-i id = fcmp fcond floating_point value1 value2
      ------------------------------------------------------------------------------------------------------- :: wf_insn_fcmp
      system , (layouts namedts products) , fdef , block |- id = fcmp fcond floating_point value1 value2

      % Check typs
      </ system , module , fdef |- valuej : typ // j />
      %   typ =t= void \/ isFirstClassTyp typ
      % Check that the instruction doesn't produce metadata or metadata*. Calls
      % all already checked against the callee type.
      %   not typ =t= metadata
      % Instructions may not produce pointer to metadata.
      %   (isPointerTyp typ) implies (getPointerEltTyp typ = typ' /\ (not typ' =t= metadata))
      % Check invariance for instructions
      {{ insnInFdefBlockB [[:user_syntax__insn:id = phi typ </ [ valuej , lj ] // j />]] [[:user_syntax__fdef:fdef]] [[:user_syntax__block:block]] = true }}
      %
      {{ wf_phinode [[:user_syntax__fdef:fdef]] [[:user_syntax__block:block]] [[:user_syntax__phinode:id = phi typ </ [ valuej , lj ] // j />]] }}
      --------------------------------------------------------------------------------------------------------------------------------------------- :: wf_insn_phi
      system , module , fdef , block |- id = phi typ </ [ valuej , lj ] // j />

      % Check typs
      system , module , fdef |- value0 : int sz
      sz = 1
      system , module , fdef |- value1 : typ
      system , module , fdef |- value2 : typ
      % Check invariance for instructions
      fdef , block |-i id = select value0 typ value1 value2
      ------------------------------------------------------------------------------------------------------- :: wf_insn_select
      system , module , fdef , block |- id = select value0 typ value1 value2

      % LLVM checks that
      %   "Called function must be a pointer!"
      %   "Called function has to be a pointer to function type!"
      module = (layouts namedts products)
      system , module , fdef |- value0 : typ0*
      % Verify that the correct number of arguments are being passed
      % Correct number of arguments passed to called function!
      {{ FunctionType.getNumParams [[:user_syntax__typ:typ1]] = Some (length [[params]]) }}
      % Verify that all arguments to the call match the function type...
      params <-> </ (typj' attributesj' valuej'') // j />
      system , (layouts namedts) |- typ1
      </ system , module , fdef |- valuej'' : typj' // j />
      % instructions returning void cannot have a name
      typ1 =t= void implies noret = yes
      % Will Verify call attributes later...
      %
      % Verify that there's no metadata unless it's a direct call to an intrinsic.
      %   Open soooon...
      %
      % Check invariance for instructions
      fdef , block |-i id = noret clattrs call typ1 varg value0 params
      ------------------------------------------------------------------------------------------------------------------- :: wf_insn_call
      system , module , fdef , block |- id = noret clattrs call typ1 varg value0 params

defns
Jwf_cmds :: '' ::=
      defn
      system , module , fdef , block |- cmds :: :: wf_cmds :: ''
      {{ com [[cmds]] is well-formed w.r.t. [[block]] [[fdef]] in [[module]] [[system]] }} by

      --------------------------------------- :: wf_cmds_nil
      system , module , fdef , block |- []

      system , module , fdef , block |- cmd
      system , module , fdef , block |- cmds
      ------------------------------------------------------------------------------ :: wf_cmds_cons
      system , module , fdef , block |- cmd , cmds

defns
Jwf_phinodes :: '' ::=
      defn
      system , module , fdef , block |- phinodes :: :: wf_phinodes :: ''
      {{ com [[phinodes]] is well-formed w.r.t. [[block]] [[fdef]] in [[module]] [[system]] }} by

      --------------------------------------- :: wf_phinodes_nil
      system , module , fdef , block |- []

      system , module , fdef , block |- phinode
      system , module , fdef , block |- phinodes
      ------------------------------------------------------------------------------ :: wf_phinodes_cons
      system , module , fdef , block |- phinode , phinodes

defns
Jwf_block :: '' ::=
      defn
      system , module , fdef |- block :: :: wf_block :: ''
      {{ com [[block]] is well-formed w.r.t. [[fdef]] in [[module]] [[system]] }} by

      % Inclusion
      (l phinodes cmds terminator) in system , module , fdef
      % Ensure that the PHI nodes are all grouped together at the top of the block.
      % This can be tested by checking whether the instruction before this is
      % either nonexistent (because this is begin()) or is a PHI node.  If not,
      % then there is some other instruction before a PHI.
      % LLVM checks this only in visitPHINode, we pull it up to block checking.
      % It is easier than the one in LLVM::visitPHINode.
      %
      % Ensure that basic blocks have terminators!
      %
      % We moved some assertions to visitPhiNode
      %
      % Check instruction
      system , module , fdef , (l phinodes cmds terminator) |- phinodes
      system , module , fdef , (l phinodes cmds terminator) |- cmds
      system , module , fdef , (l phinodes cmds terminator) |- terminator
      ------------------------------------------------------------------------------------ :: wf_block_intro
      system , module , fdef |- l phinodes cmds terminator

defns
Jwf_blocks :: '' ::=
      defn
      system , module , fdef |- blocks :: :: wf_blocks :: ''
      {{ com [[blocks]] is well-formed w.r.t. [[fdef]] in [[module]] [[system]] }} by

      --------------------------------------- :: wf_blocks_nil
      system , module , fdef |- []

      system , module , fdef |- block
      system , module , fdef |- blocks
      ------------------------------------------------------------------------ :: wf_blocks_cons
      system , module , fdef |- block , blocks

defns
Jwf_fheader :: '' ::=
      defn
      system , targetdata |- fheader :: :: wf_fheader :: ''
      {{ com [[fheader]] is well-formed w.r.t. [[system]] [[targetdata]] }} by

      % Check function arguments.
      args <-> </ (typj attributesj idj) // j />
      </ system , targetdata |- typj // j />
      % Functions may not have common linkage
      %
      % Formal arguments must match # of arguments for function type!
      %
      % Functions cannot return aggregate values
      isFirstClassTyp typ \/ typ =t= void
      % "Invalid struct return type!"
      %
      % Attributes after last parameter!
      %
      % Check function attributes.
      %
      % Check that this function meets the restrictions on this calling convention.
      %
      % Function may not return metadata unless it's an intrinsic.
      %
      % Check that the argument values match the function type for this function...
        % Argument value does not match function argument type!
        % Function arguments must have first-class types!
        % Function takes metadata but isn't an intrinsic
      %
      % Verify that this function (which has a body) is not named "llvm.*".  It
      % is not legal to define intrinsics.
      ------------------------------------------------------------------------------------------ :: wf_fheader_intro
      system , targetdata |- fnattrs typ id ( args varg )


defns
Jwf_fdec :: '' ::=
      defn
      system , module |-f fdec :: :: wf_fdec :: ''
      {{ com [[fdec]] is well-formed w.r.t. [[module]] [[system]] }} by

      % inclusion
      (declare fheader deckind) in system , (layouts namedts products)
      % header
      system , (layouts namedts) |- fheader
      {{ wf_deckind [[ fheader ]] [[deckind]] }}
      %
      % Check invalid linkage type for function declaration
      ------------------------------------------------------------------------------------------ :: wf_fdec_intro
      system , (layouts namedts products) |-f declare fheader deckind

defns
Jwf_fdef :: '' ::=
      defn
      system , module |-f fdef :: :: wf_fdef :: ''
      {{ com [[fdef]] is well-formed w.r.t. [[module]] [[system]] }} by

      % inclusion
      (define fheader { blocks } ) in system , (layouts namedts products)
      % header
      system , (layouts namedts) |- fheader
      % Check the entry node
      % Entry block to function must not have predecessors!
      getEntryBlock (define fheader { blocks }) = block
      {{ has_no_predecessors [[:user_syntax__fdef:define fheader { blocks }]] [[:user_syntax__block:block]] = true }}
      % Checking function body
      system , (layouts namedts products) , define fheader { blocks } |- blocks
      ------------------------------------------------------------------------------------------------------------------- :: wf_fdef_intro
      system , (layouts namedts products) |-f define fheader { blocks }

defns
Jwf_g :: '' ::=     % visitGlobalValue
      defn
      system , module |-g product :: :: wf_g :: ''
      {{ com common cases that [[product]] is well-formed w.r.t. [[module]] [[system]]}} by

      -------------------------------------------------- :: wf_g_intro
      system , module |-g product

defns
Jwf_gvar :: '' ::=  % visitGlobalVariable
      defn
      system , module |-v gvar :: :: wf_gvar :: ''
      {{ com [[gvar]] is well-formed w.r.t. [[module]] [[system]]}} by

      system , (layouts namedts) |-c const : typ
      ----------------------------------------------------------------------------- :: wf_gv_intro
      system , (layouts namedts products) |-v id = linkage gvar_spec typ const align

defns
Jwf_prod :: '' ::=
      defn
      system , module |- product :: :: wf_prod :: ''
      {{ com [[product]] is well-formed w.r.t. [[module]] [[system]]}} by

      system , module |-g gvar
      system , module |-v gvar
      ------------------------------------------------ :: wf_prod_global_var
      system , module |- gvar

      system , module |-g fdec
      system , module |-f fdec
      ---------------------------------------------- :: wf_prod_function_dec
      system , module |- fdec

      system , module |-g fdef
      system , module |-f fdef
      ---------------------------------------------- :: wf_prod_function_def
      system , module |- fdef

      % -------------------------------------- :: wf_prod_namedtype
      % system , module |- namedt

defns
Jwf_prods :: '' ::=
      defn
      system , module |- products :: :: wf_prods :: ''
      {{ com [[products]] is well-formed w.r.t. [[module]] [[system]]}} by

      ------------------------------------------- :: wf_prods_nil
      system , module |- []

      system , module |- products
      system , module |- product
      ---------------------------------------------------------------- :: wf_prods_cons
      system , module |- product , products

defns
Jwf_namedts :: '' ::=
      defn
      system |- targetdata :: :: wf_namedts :: '' {{ com }} by

      %% Check circularity
      system , layouts |- namedts
      {{ uniq [[namedts]] }}
      {{ LLVMtd.wf_layouts [[layouts]] }}
      --------------------------------------------- :: wf_namedts_intro
      system |- layouts namedts

defns
Jwf_module :: '' ::=
      defn
      system |- module :: :: wf_module :: ''
      {{ com [[module]] is well-formed w.r.t. [[system]] }} by

      %%
      system |- layouts namedts
      %%
      (layouts namedts products) in system
      system , (layouts namedts products) |- products
      -------------------------------------------------- :: wf_module_intro
      system |- (layouts namedts products)

defns
Jwf_modules :: '' ::=
      defn
      system |- modules :: :: wf_modules :: ''
      {{ com [[modules]] is well-formed w.r.t. [[system]] }} by

      ----------------------------- :: wf_modules_nil
      system |- []

      system |- module
      system |- modules
      ----------------------------------------------- :: wf_modules_cons
      system |- module , modules

defns
Jwf_system :: '' ::=
      defn
      |- system :: :: wf_system :: ''
      {{ com [[system]] is well-formed }} by

      modules |- modules
      uniqSystem modules
      ------------------------------ :: wf_system_intro
      |- modules

embed
{{coq

End LLVMtyping_rules.

}}



