Require Import Ensembles.
Require Import syntax.
Require Import infrastructure.
Require Import List.
Require Import Arith.
Require Import monad.
Require Import Metatheory.
Require Import genericvalues.
Require Import alist.
Require Import Values.
Require Import Memory.
Require Import Integers.
Require Import events.
Require Import Integers.
Require Import Coqlib.
Require Import targetdata.
Require Import infrastructure_props.
Require Import typings.
Require Import genericvalues_inject.
Require Import vellvm_tactics.

Import LLVMsyntax.
Import LLVMtd.
Import LLVMinfra.
Import LLVMgv.
Import LLVMtypings.

Definition find_symbol TD (ge:list (id * GenericValue)) (gid:id) 
  : option Values.block :=
match lookupAL _ ge gid with 
| Some gv =>
    match GV2ptr TD (getPointerSize TD) gv with
    | Some (Vptr b _) => Some b
    | _ => None
    end
| None => None
end.

Definition find_var_info TD (ge:list (id * GenericValue)) (b:Values.block) 
  : option GenericValue :=
List.fold_left 
  (fun acc elt =>
   let '(_, gv) := elt in
   match acc with
   | Some _ => acc
   | None =>
       match GV2ptr TD (getPointerSize TD) gv with
       | Some (Vptr b' _) =>
           if zeq b b' then Some gv else None
       | _ => None
       end
   end
  ) ge None.

Lemma GV2ptr_inv: forall TD sz gv v,
  GV2ptr TD sz gv = Some v ->
  exists b, exists ofs, exists m, v = Vptr b ofs /\ gv = (v,m)::nil.
Proof.
  unfold GV2ptr.
  intros.
  destruct gv as [|[[]]]; tinv H.
  destruct gv as [|]; inv H.
  eauto.
Qed.

Axiom vars_inj: (* FIXME: This should be a property of genGlobalAndInitMem *)
  forall TD (ge:list (atom * GenericValue)) id1 id2 b, 
    find_symbol TD ge id1 = Some b -> find_symbol TD ge id2 = Some b -> 
    id1 = id2.

Definition globals2Genv TD (gl:list (id * GenericValue)) : Genv.t GenericValue :=
Genv.mkgenv gl (find_symbol TD gl) (find_var_info TD gl) (vars_inj TD gl).

(* Originally Copied from CompCert Events.v 1.9.1 START *)

(** * Semantics of external functions *)

(** For each external function, its behavior is defined by a predicate relating:
- the global environment
- the values of the arguments passed to this function
- the memory state before the call
- the result value of the call
- the memory state after the call
- the trace generated by the call (can be empty).
*)

Definition extcall_sem : Type :=
  Genv.t GenericValue -> list GenericValue -> mem -> trace -> option GenericValue
    -> mem -> Prop.

(** We now specify the expected properties of this predicate. *)

Definition mem_unchanged_on 
  (P: Values.block -> Z -> Prop) (m_before m_after: mem): Prop :=
  (forall b ofs p,
   P b ofs -> Mem.perm m_before b ofs p -> Mem.perm m_after b ofs p)
/\(forall chunk b ofs v,
   (forall i, ofs <= i < ofs + size_chunk chunk -> P b i) ->
   Mem.load chunk m_before b ofs = Some v ->
   Mem.load chunk m_after b ofs = Some v).

Definition loc_out_of_bounds (m: mem) (b: Values.block) (ofs: Z) : Prop :=
  ofs < Mem.low_bound m b \/ ofs > Mem.high_bound m b.

Definition loc_unmapped (f: meminj) (b: Values.block) (ofs: Z): Prop :=
  f b = None.

Definition loc_out_of_reach 
  (f: meminj) (m: mem) (b: Values.block) (ofs: Z): Prop :=
  forall b0 delta,
  f b0 = Some(b, delta) ->
  ofs < Mem.low_bound m b0 + delta \/ ofs >= Mem.high_bound m b0 + delta.

Definition inject_separated (f f': meminj) (m1 m2: mem): Prop :=
  forall b1 b2 delta,
  f b1 = None -> f' b1 = Some(b2, delta) ->
  ~Mem.valid_block m1 b1 /\ ~Mem.valid_block m2 b2.

(* Vellvm does not support volatile
Definition block_is_volatile (F V: Type) (ge: Genv.t F V) (b: block) : bool :=
  match Genv.find_var_info ge b with
  | None => false
  | Some gv => gv.(gvar_volatile)
  end.
*)

Set Implicit Arguments.

Inductive option_f1t (A:Type) (f: A -> typ -> Prop)
  : option A -> typ -> Prop :=
| option_f1t_nonvoid: forall a b, 
    f a b -> b <> typ_void -> option_f1t f (Some a) b
| option_f1t_void: option_f1t f None typ_void.

Inductive option_f2 (A B:Type) (f: A -> B -> Prop)
  : option A -> option B -> Prop :=
| option_f2_Some: forall a b, f a b -> option_f2 f (Some a) (Some b)
| option_f2_None: option_f2 f None None.

Inductive option_f3 (A B C:Type) (f: A -> B -> C -> Prop)
  : option A -> option B -> option C -> Prop :=
| option_f3_Some: forall a b c, 
    f a b c -> option_f3 f (Some a) (Some b) (Some c)
| option_f3_None: option_f3 f None None None.

Inductive option_f2t (A C:Type) (f: A -> typ -> C -> Prop)
  : option A -> typ -> option C -> Prop :=
| option_f2t_nonvoid: forall a b c, 
    f a b c -> b <> typ_void -> option_f2t f (Some a) b (Some c)
| option_f2t_void: option_f2t f None typ_void None.

Record extcall_properties (TD:TargetData) (sem: extcall_sem) (tret: typ) 
                          (targs: list typ) : Prop := mk_extcall_properties {

(** The return value of an external call must agree with its signature. *)
  ec_well_typed:
    forall ge vargs m1 t vres m2,
    sem ge vargs m1 t vres m2 ->
    option_f1t (gv_has_type TD) vres tret;

(** The number of arguments of an external call must agree with its signature. *)
  ec_arity:
    forall ge vargs m1 t vres m2,
    sem ge vargs m1 t vres m2 ->
    List.length vargs = List.length targs;

(** The semantics is invariant under change of global environment that preserves symbols. *)
  ec_symbols_preserved:
    forall ge1 ge2 vargs m1 t vres m2,
    (forall id, Genv.find_symbol ge2 id = Genv.find_symbol ge1 id) ->
    (*(forall b, block_is_volatile ge2 b = block_is_volatile ge1 b) ->*)
    sem ge1 vargs m1 t vres m2 ->
    sem ge2 vargs m1 t vres m2;

(** External calls cannot invalidate memory blocks.  (Remember that
  freeing a block does not invalidate its block identifier.) *)
  ec_valid_block:
    forall ge vargs m1 t vres m2 b,
    sem ge vargs m1 t vres m2 ->
    Mem.valid_block m1 b -> Mem.valid_block m2 b;

(** External calls preserve the bounds of valid blocks. *)
  ec_bounds:
    forall ge vargs m1 t vres m2 b,
    sem ge vargs m1 t vres m2 ->
    Mem.valid_block m1 b -> Mem.bounds m2 b = Mem.bounds m1 b;

(** External calls must commute with memory extensions, in the
  following sense. *)
  ec_mem_extends:
    forall ge vargs m1 t vres m2 m1' vargs',
    sem ge vargs m1 t vres m2 ->
    Mem.extends m1 m1' ->
    gv_lessdef_list vargs vargs' ->
    exists vres', exists m2',
       sem ge vargs' m1' t vres' m2'
    /\ option_f2 gv_lessdef vres vres'
    /\ Mem.extends m2 m2'
    /\ mem_unchanged_on (loc_out_of_bounds m1) m1' m2';

(** External calls must commute with memory injections,
  in the following sense. *)
  ec_mem_inject:
    forall ge vargs m1 t vres m2 f m1' vargs',
    meminj_preserves_globals ge f ->
    sem ge vargs m1 t vres m2 ->
    Mem.inject f m1 m1' ->
    gv_list_inject f vargs vargs' ->
    exists f', exists vres', exists m2',
       sem ge vargs' m1' t vres' m2'
    /\ option_f2 (gv_inject f') vres vres'
    /\ Mem.inject f' m2 m2'
    /\ mem_unchanged_on (loc_unmapped f) m1 m2
    /\ mem_unchanged_on (loc_out_of_reach f m1) m1' m2'
    /\ inject_incr f f'
    /\ inject_separated f f' m1 m1';

(** External calls produce at most one event. *)
  ec_trace_length:
    forall ge vargs m t vres m',
    sem ge vargs m t vres m' -> (length t <= 1)%nat;

(** External calls must be receptive to changes of traces by another, matching trace. *)
  ec_receptive:
    forall ge vargs m t1 vres1 m1 t2,
    sem ge vargs m t1 vres1 m1 -> match_traces ge t1 t2 ->
    exists vres2, exists m2, sem ge vargs m t2 vres2 m2;

(** External calls must be deterministic up to matching between traces. *)
  ec_determ:
    forall ge vargs m t1 vres1 m1 t2 vres2 m2,
    sem ge vargs m t1 vres1 m1 -> sem ge vargs m t2 vres2 m2 ->
    match_traces ge t1 t2 /\ (t1 = t2 -> vres1 = vres2 /\ m1 = m2)
}.

(* Vellvm does not support Volatile accesses.

(** ** Semantics of volatile loads *)

Inductive volatile_load_sem (chunk: memory_chunk) (F V: Type) (ge: Genv.t F V):
              list val -> mem -> trace -> val -> mem -> Prop :=
  | volatile_load_sem_vol: forall b ofs m id ev v,
      Genv.find_symbol ge id = Some b -> block_is_volatile ge b = true ->
      eventval_match ge ev (type_of_chunk chunk) v ->
      volatile_load_sem chunk ge
          (Vptr b ofs :: nil) m
          (Event_vload chunk id ofs ev :: nil)
          (Val.load_result chunk v) m
  | volatile_load_sem_nonvol: forall b ofs m v,
      block_is_volatile ge b = false ->
      Mem.load chunk m b (Int.unsigned ofs) = Some v ->
      volatile_load_sem chunk ge
          (Vptr b ofs :: nil) m
          E0
          v m.

Remark meminj_preserves_block_is_volatile:
  forall F V (ge: Genv.t F V) f b1 b2 delta,
  meminj_preserves_globals ge f ->
  f b1 = Some (b2, delta) ->
  block_is_volatile ge b2 = block_is_volatile ge b1.
Proof.
  intros. destruct H as [A [B C]]. unfold block_is_volatile. 
  case_eq (Genv.find_var_info ge b1); intros.
  exploit B; eauto. intro EQ; rewrite H0 in EQ; inv EQ. rewrite H; auto.
  case_eq (Genv.find_var_info ge b2); intros.
  exploit C; eauto. intro EQ. congruence.
  auto.
Qed.

Lemma volatile_load_ok:
  forall chunk,
  extcall_properties (volatile_load_sem chunk) 
                     (mksignature (Tint :: nil) (Some (type_of_chunk chunk))).
Proof.
  intros; constructor; intros.
(* well typed *)
  unfold proj_sig_res; simpl. destruct H.
  destruct chunk; destruct v; simpl; constructor.
  eapply Mem.load_type; eauto. 
(* arity *)
  destruct H; simpl; auto.
(* symbols *)
  destruct H1. 
  econstructor; eauto. rewrite H; auto. eapply eventval_match_preserved; eauto. 
  econstructor; eauto.
(* valid blocks *)
  destruct H; auto.
(* bounds *)
  destruct H; auto.
(* mem extends *)
  destruct H. 
  inv H1. inv H8. inv H6. 
  exists (Val.load_result chunk v); exists m1'; intuition.
  constructor; auto.
  red; auto.
  inv H1. inv H7. inv H5. 
  exploit Mem.load_extends; eauto. intros [v' [A B]]. 
  exists v'; exists m1'; intuition.
  econstructor; eauto.
  red; auto.
(* mem injects *)
  destruct H0.
  inv H2. inv H9. inv H7.
  generalize H; intros [P [Q R]].
  exploit P; eauto. intro EQ; rewrite H6 in EQ; inv EQ.
  exists f; exists (Val.load_result chunk v); exists m1'; intuition.
  rewrite Int.add_zero. constructor; auto.
  apply val_load_result_inject. eapply eventval_match_inject_2; eauto.
  red; auto.
  red; auto.
  red; intros. congruence.
  inv H2. inv H8.
  exploit Mem.loadv_inject; eauto. simpl. eauto. intros [v1 [A B]].
  inv H6; simpl in *.
  exists f; exists v1; exists m1'; intuition.
  econstructor; eauto.
  rewrite <- H0. eapply meminj_preserves_block_is_volatile; eauto.
  red; auto.
  red; auto.
  red; intros. congruence.
(* trace length *)
  inv H; simpl; omega.
(* receptive *)
  inv H; inv H0.
  exploit eventval_match_valid; eauto. intros [A B]. 
  exploit eventval_valid_match. eexact H9. rewrite <- H10; eauto. 
  intros [v' EVM]. exists (Val.load_result chunk v'); exists m1.
  eapply volatile_load_sem_vol; eauto. 
  exists vres1; exists m1; eapply volatile_load_sem_nonvol; eauto.
(* determ *)
  inv H; inv H0; try congruence.
  assert (id = id0) by (eapply Genv.genv_vars_inj; eauto). subst id0.
  exploit eventval_match_valid. eexact H3. intros [V1 T1].
  exploit eventval_match_valid. eexact H11. intros [V2 T2].
  split. constructor; auto. congruence.
  intros EQ; inv EQ. 
  assert (v = v0) by (eapply eventval_match_determ_1; eauto). subst v0.
  auto.
  split. constructor. intuition congruence.
Qed.

(** ** Semantics of volatile stores *)

Inductive volatile_store_sem (chunk: memory_chunk) (F V: Type) (ge: Genv.t F V):
              list val -> mem -> trace -> val -> mem -> Prop :=
  | volatile_store_sem_vol: forall b ofs m id ev v,
      Genv.find_symbol ge id = Some b -> block_is_volatile ge b = true ->
      eventval_match ge ev (type_of_chunk chunk) v ->
      volatile_store_sem chunk ge
          (Vptr b ofs :: v :: nil) m
          (Event_vstore chunk id ofs ev :: nil)
          Vundef m
  | volatile_store_sem_nonvol: forall b ofs m v m',
      block_is_volatile ge b = false ->
      Mem.store chunk m b (Int.unsigned ofs) v = Some m' ->
      volatile_store_sem chunk ge
          (Vptr b ofs :: v :: nil) m
          E0
          Vundef m'.

Lemma volatile_store_ok:
  forall chunk,
  extcall_properties (volatile_store_sem chunk) 
                     (mksignature (Tint :: type_of_chunk chunk :: nil) None).
Proof.
  intros; constructor; intros.
(* well typed *)
  unfold proj_sig_res; simpl. inv H; constructor.
(* arity *)
  inv H; simpl; auto.
(* symbols preserved *)
  inv H1. 
  constructor. rewrite H; auto. rewrite H0; auto. eapply eventval_match_preserved; eauto.
  constructor; auto. rewrite H0; auto.
(* valid block *)
  inv H. auto. eauto with mem.
(* bounds *)
  inv H. auto. eapply Mem.bounds_store; eauto.
(* mem extends*)
  inv H.
  inv H1. inv H6. inv H8. inv H7.
  exists Vundef; exists m1'; intuition.
  constructor; auto. eapply eventval_match_lessdef; eauto.
  red; auto.
  inv H1. inv H5. inv H7. inv H6.
  exploit Mem.store_within_extends; eauto. intros [m' [A B]].
  exists Vundef; exists m'; intuition.
  constructor; auto.
  red; split; intros.
  eapply Mem.perm_store_1; eauto.
  rewrite <- H1. eapply Mem.load_store_other; eauto.
  destruct (eq_block b0 b); auto. subst b0; right. 
  exploit Mem.valid_access_in_bounds. 
  eapply Mem.store_valid_access_3. eexact H3.
  intros [C D].
  generalize (size_chunk_pos chunk0). intro E.
  generalize (size_chunk_pos chunk). intro G.
  apply (Intv.range_disjoint' (ofs0, ofs0 + size_chunk chunk0)
                              (Int.unsigned ofs, Int.unsigned ofs + size_chunk chunk)).
  red; intros. generalize (H x H5). unfold loc_out_of_bounds, Intv.In; simpl. omega.
  simpl; omega. simpl; omega.
(* mem injects *)
  inv H0.
  inv H2. inv H7. inv H9. inv H10.
  generalize H; intros [P [Q R]].
  exploit P; eauto. intro EQ; rewrite H6 in EQ; inv EQ.
  exists f; exists Vundef; exists m1'; intuition.
  rewrite Int.add_zero. constructor; auto. 
  eapply eventval_match_inject; eauto. 
  red; auto.
  red; auto.
  red; intros; congruence.
  inv H2. inv H8. inv H9. inv H6.
  assert (Mem.storev chunk m1 (Vptr b ofs) v = Some m2). simpl; auto.
  exploit Mem.storev_mapped_inject; eauto. intros [m2' [A B]].
  inv H4. 
  exists f; exists Vundef; exists m2'; intuition.
  constructor; auto. rewrite <- H3. eapply meminj_preserves_block_is_volatile; eauto.  
  split; intros. eapply Mem.perm_store_1; eauto.
  rewrite <- H4. eapply Mem.load_store_other; eauto. 
  left. exploit (H2 ofs0). generalize (size_chunk_pos chunk0). omega. 
  unfold loc_unmapped. congruence.
  split; intros. eapply Mem.perm_store_1; eauto.
  rewrite <- H4. eapply Mem.load_store_other; eauto.
  destruct (eq_block b0 b2); auto. subst b0; right.
  assert (EQ: Int.unsigned (Int.add ofs (Int.repr delta)) = Int.unsigned ofs + delta).
    eapply Mem.address_inject; eauto with mem.
  unfold Mem.storev in A. rewrite EQ in A. rewrite EQ.
  exploit Mem.valid_access_in_bounds. 
  eapply Mem.store_valid_access_3. eexact H0.
  intros [C D].
  generalize (size_chunk_pos chunk0). intro E.
  generalize (size_chunk_pos chunk). intro G.
  apply (Intv.range_disjoint' (ofs0, ofs0 + size_chunk chunk0)
                              (Int.unsigned ofs + delta, Int.unsigned ofs + delta + size_chunk chunk)).
  red; intros. exploit (H2 x H8). eauto. unfold Intv.In; simpl. omega.
  simpl; omega. simpl; omega.
  red; intros; congruence.
(* trace length *)
  inv H; simpl; omega.
(* receptive *)
  assert (t1 = t2). inv H; inv H0; auto. 
  exists vres1; exists m1; congruence.
(* determ *)
  inv H; inv H0; try congruence.
  assert (id = id0) by (eapply Genv.genv_vars_inj; eauto). subst id0.
  assert (ev = ev0) by (eapply eventval_match_determ_2; eauto). subst ev0.
  split. constructor. auto.
  split. constructor. intuition congruence.
Qed.

(** ** Semantics of dynamic memory allocation (malloc) *)

Inductive extcall_malloc_sem (ge: Genv.t GenericValue):
              list val -> mem -> trace -> val -> mem -> Prop :=
  | extcall_malloc_sem_intro: forall wz n m m' b m'',
      Mem.alloc m (-4) (Int.unsigned wz n) = (m', b) ->
      Mem.store Mint32 m' b (-4) (Vint wz n) = Some m'' ->
      extcall_malloc_sem ge (Vint wz n :: nil) m E0 (Vptr b (Int.zero 31)) m''.

Lemma extcall_malloc_ok:
  extcall_properties extcall_malloc_sem 
                     (mksignature (Tint :: nil) (Some Tint)).
Proof.
  assert (UNCHANGED:
    forall (P: block -> Z -> Prop) m n m' b m'',
    Mem.alloc m (-4) (Int.unsigned n) = (m', b) ->
    Mem.store Mint32 m' b (-4) (Vint n) = Some m'' ->
    mem_unchanged_on P m m'').
  intros; split; intros.
  eauto with mem.
  transitivity (Mem.load chunk m' b0 ofs). 
  eapply Mem.load_store_other; eauto. left. 
  apply Mem.valid_not_valid_diff with m; eauto with mem.
  eapply Mem.load_alloc_other; eauto. 

  constructor; intros.
(* well typed *)
  inv H. unfold proj_sig_res; simpl. auto.
(* arity *)
  inv H. auto.
(* symbols preserved *)
  inv H1; econstructor; eauto.
(* valid block *)
  inv H. eauto with mem.
(* bounds *)
  inv H. transitivity (Mem.bounds m' b).
  eapply Mem.bounds_store; eauto.
  eapply Mem.bounds_alloc_other; eauto.
  apply Mem.valid_not_valid_diff with m1; eauto with mem.
(* mem extends *)
  inv H. inv H1. inv H5. inv H7. 
  exploit Mem.alloc_extends; eauto. apply Zle_refl. apply Zle_refl.
  intros [m3' [A B]].
  exploit Mem.store_within_extends. eexact B. eauto. 
  instantiate (1 := Vint n). auto. 
  intros [m2' [C D]].
  exists (Vptr b Int.zero); exists m2'; intuition.
  econstructor; eauto.
  eapply UNCHANGED; eauto.
(* mem injects *)
  inv H0. inv H2. inv H6. inv H8.
  exploit Mem.alloc_parallel_inject; eauto. apply Zle_refl. apply Zle_refl. 
  intros [f' [m3' [b' [ALLOC [A [B [C D]]]]]]].
  exploit Mem.store_mapped_inject. eexact A. eauto. eauto. 
  instantiate (1 := Vint n). auto. 
  intros [m2' [E G]].
  exists f'; exists (Vptr b' Int.zero); exists m2'; intuition.
  econstructor; eauto.
  econstructor. eauto. auto.
  eapply UNCHANGED; eauto.
  eapply UNCHANGED; eauto.
  red; intros. destruct (eq_block b1 b). 
  subst b1. rewrite C in H2. inv H2. eauto with mem. 
  rewrite D in H2. congruence. auto. 
(* trace length *)
  inv H; simpl; omega.
(* receptive *)
  assert (t1 = t2). inv H; inv H0; auto. subst t2.
  exists vres1; exists m1; auto.
(* determ *)
  inv H; inv H0. split. constructor. intuition congruence. 
Qed.

(** ** Semantics of dynamic memory deallocation (free) *)

Inductive extcall_free_sem  (F V: Type) (ge: Genv.t F V):
              list val -> mem -> trace -> val -> mem -> Prop :=
  | extcall_free_sem_intro: forall b lo sz m m',
      Mem.load Mint32 m b (Int.unsigned lo - 4) = Some (Vint sz) ->
      Int.unsigned sz > 0 ->
      Mem.free m b (Int.unsigned lo - 4) (Int.unsigned lo + Int.unsigned sz) = Some m' ->
      extcall_free_sem ge (Vptr b lo :: nil) m E0 Vundef m'.

Lemma extcall_free_ok:
  extcall_properties extcall_free_sem 
                     (mksignature (Tint :: nil) None).
Proof.
  assert (UNCHANGED:
    forall (P: block -> Z -> Prop) m b lo hi m',
    Mem.free m b lo hi = Some m' ->
    lo < hi ->
    (forall b' ofs, P b' ofs -> b' <> b \/ ofs < lo \/ hi <= ofs) ->
    mem_unchanged_on P m m').
  intros; split; intros.
  eapply Mem.perm_free_1; eauto.
  rewrite <- H3. eapply Mem.load_free; eauto. 
  destruct (eq_block b0 b); auto. right. right. 
  apply (Intv.range_disjoint' (ofs, ofs + size_chunk chunk) (lo, hi)).
  red; intros. apply Intv.notin_range. simpl. exploit H1; eauto. intuition. 
  simpl; generalize (size_chunk_pos chunk); omega.
  simpl; omega.

  constructor; intros.
(* well typed *)
  inv H. unfold proj_sig_res. simpl. auto.
(* arity *)
  inv H. auto.
(* symbols preserved *)
  inv H1; econstructor; eauto.
(* valid block *)
  inv H. eauto with mem.
(* bounds *)
  inv H. eapply Mem.bounds_free; eauto.
(* mem extends *)
  inv H. inv H1. inv H8. inv H6. 
  exploit Mem.load_extends; eauto. intros [vsz [A B]]. inv B. 
  exploit Mem.free_parallel_extends; eauto. intros [m2' [C D]].
  exists Vundef; exists m2'; intuition.
  econstructor; eauto.
  eapply UNCHANGED; eauto. omega. 
  intros. destruct (eq_block b' b); auto. subst b; right.
  red in H.
  exploit Mem.range_perm_in_bounds. 
  eapply Mem.free_range_perm. eexact H4. omega. omega.
(* mem inject *)
  inv H0. inv H2. inv H7. inv H9.
  exploit Mem.load_inject; eauto. intros [vsz [A B]]. inv B. 
  assert (Mem.range_perm m1 b (Int.unsigned lo - 4) (Int.unsigned lo + Int.unsigned sz) Freeable).
    eapply Mem.free_range_perm; eauto.
  exploit Mem.address_inject; eauto. 
    apply Mem.perm_implies with Freeable; auto with mem.
    apply H0. instantiate (1 := lo). omega. 
  intro EQ.
  assert (Mem.range_perm m1' b2 (Int.unsigned lo + delta - 4) (Int.unsigned lo + delta + Int.unsigned sz) Freeable).
    red; intros. 
    replace ofs with ((ofs - delta) + delta) by omega.
    eapply Mem.perm_inject; eauto. apply H0. omega. 
  destruct (Mem.range_perm_free _ _ _ _ H2) as [m2' FREE].
  exists f; exists Vundef; exists m2'; intuition.

  econstructor.
  rewrite EQ. replace (Int.unsigned lo + delta - 4) with (Int.unsigned lo - 4 + delta) by omega.
  eauto. auto. 
  rewrite EQ. auto.
  
  assert (Mem.free_list m1 ((b, Int.unsigned lo - 4, Int.unsigned lo + Int.unsigned sz) :: nil) = Some m2).
    simpl. rewrite H5. auto.
  eapply Mem.free_inject; eauto. 
  intros. destruct (eq_block b b1).
  subst b. assert (delta0 = delta) by congruence. subst delta0. 
  exists (Int.unsigned lo - 4); exists (Int.unsigned lo + Int.unsigned sz); split.
  simpl; auto. omega.
  elimtype False.
  exploit Mem.inject_no_overlap. eauto. eauto. eauto. eauto. 
  instantiate (1 := ofs + delta0 - delta). 
  apply Mem.perm_implies with Freeable; auto with mem.
  apply H0. omega. eauto with mem.
  unfold block; omega.

  eapply UNCHANGED; eauto. omega. intros.  
  red in H7. left. congruence. 

  eapply UNCHANGED; eauto. omega. intros.
  destruct (eq_block b' b2); auto. subst b'. right. 
  red in H7. generalize (H7 _ _ H6). intros. 
  exploit Mem.range_perm_in_bounds. eexact H0. omega. intros. omega.

  red; intros. congruence.
(* trace length *)
  inv H; simpl; omega.
(* receptive *)
  assert (t1 = t2). inv H; inv H0; auto. subst t2.
  exists vres1; exists m1; auto.
(* determ *)
  inv H; inv H0. split. constructor. intuition congruence.
Qed.

(** ** Semantics of [memcpy] operations. *)

Inductive extcall_memcpy_sem (sz al: Z) (F V: Type) (ge: Genv.t F V): list val -> mem -> trace -> val -> mem -> Prop :=
  | extcall_memcpy_sem_intro: forall bdst odst bsrc osrc m bytes m',
      al = 1 \/ al = 2 \/ al = 4 -> sz > 0 ->
      (al | sz) -> (al | Int.unsigned osrc) -> (al | Int.unsigned odst) ->
      bsrc <> bdst \/ Int.unsigned osrc = Int.unsigned odst
                   \/ Int.unsigned osrc + sz <= Int.unsigned odst
                   \/ Int.unsigned odst + sz <= Int.unsigned osrc ->
      Mem.loadbytes m bsrc (Int.unsigned osrc) sz = Some bytes ->
      Mem.storebytes m bdst (Int.unsigned odst) bytes = Some m' ->
      extcall_memcpy_sem sz al ge (Vptr bdst odst :: Vptr bsrc osrc :: nil) m E0 Vundef m'.

Lemma extcall_memcpy_ok:
  forall sz al,
  extcall_properties (extcall_memcpy_sem sz al) (mksignature (Tint :: Tint :: nil) None).
Proof.
  intros. constructor.
(* return type *)
  intros. inv H. constructor. 
(* arity *)
  intros. inv H. auto.
(* change of globalenv *)
  intros. inv H1. econstructor; eauto.
(* valid blocks *)
  intros. inv H. eauto with mem. 
(* bounds *)
  intros. inv H. eapply Mem.bounds_storebytes; eauto. 
(* extensions *)
  intros. inv H. 
  inv H1. inv H13. inv H14. inv H10. inv H11.
  exploit Mem.loadbytes_length; eauto. intros LEN.
  exploit Mem.loadbytes_extends; eauto. intros [bytes2 [A B]].
  exploit Mem.storebytes_within_extends; eauto. intros [m2' [C D]].
  exists Vundef; exists m2'.
  split. econstructor; eauto.
  split. constructor.
  split. auto.
  red; split; intros.
  eauto with mem.  
  exploit Mem.loadbytes_length. eexact H8. intros.
  rewrite <- H1. eapply Mem.load_storebytes_other; eauto. 
  destruct (eq_block b bdst); auto. subst b; right.
  exploit Mem.range_perm_in_bounds. eapply Mem.storebytes_range_perm. eexact H9.
  rewrite H10. rewrite nat_of_Z_eq. omega. omega.
  intros [P Q].
  exploit list_forall2_length; eauto. intros R. rewrite R in Q.
  apply (Intv.range_disjoint' (ofs, ofs + size_chunk chunk)
                              (Int.unsigned odst, Int.unsigned odst + Z_of_nat (length bytes2))); simpl.
  red; intros. generalize (H x H11). unfold loc_out_of_bounds, Intv.In; simpl. omega.
  generalize (size_chunk_pos chunk); omega.
  rewrite <- R; rewrite H10. rewrite nat_of_Z_eq. omega. omega.
(* injections *)
  intros. inv H0. inv H2. inv H14. inv H15. inv H11. inv H12.
  exploit Mem.loadbytes_length; eauto. intros LEN.
  assert (RPSRC: Mem.range_perm m1 bsrc (Int.unsigned osrc) (Int.unsigned osrc + sz) Nonempty).
    eapply Mem.range_perm_implies. eapply Mem.loadbytes_range_perm; eauto. auto with mem.
  assert (RPDST: Mem.range_perm m1 bdst (Int.unsigned odst) (Int.unsigned odst + sz) Nonempty).
    replace sz with (Z_of_nat (length bytes)).
    eapply Mem.range_perm_implies. eapply Mem.storebytes_range_perm; eauto. auto with mem.
    rewrite LEN. apply nat_of_Z_eq. omega.
  assert (PSRC: Mem.perm m1 bsrc (Int.unsigned osrc) Nonempty).
    apply RPSRC. omega.
  assert (PDST: Mem.perm m1 bdst (Int.unsigned odst) Nonempty).
    apply RPDST. omega.
  exploit Mem.address_inject.  eauto. eexact PSRC. eauto. intros EQ1.
  exploit Mem.address_inject.  eauto. eexact PDST. eauto. intros EQ2.
  exploit Mem.loadbytes_inject; eauto. intros [bytes2 [A B]].
  exploit Mem.storebytes_mapped_inject; eauto. intros [m2' [C D]].
  exists f; exists Vundef; exists m2'.
  split. econstructor; try rewrite EQ1; try rewrite EQ2; eauto. 
  eapply Mem.aligned_area_inject with (m := m1); eauto.
  eapply Mem.aligned_area_inject with (m := m1); eauto.
  eapply Mem.disjoint_or_equal_inject with (m := m1); eauto.
  split. constructor.
  split. auto.
  split. red; split; intros. eauto with mem. 
  rewrite <- H2. eapply Mem.load_storebytes_other; eauto. 
  destruct (eq_block b bdst); auto. subst b. 
  assert (loc_unmapped f bdst ofs). apply H0. generalize (size_chunk_pos chunk); omega. 
  red in H12. congruence.
  split. red; split; intros. eauto with mem.
  rewrite <- H2. eapply Mem.load_storebytes_other; eauto. 
  destruct (eq_block b b0); auto. subst b0; right.
  rewrite <- (list_forall2_length B). rewrite LEN. rewrite nat_of_Z_eq; try omega.
  apply (Intv.range_disjoint' (ofs, ofs + size_chunk chunk)
                              (Int.unsigned odst + delta0, Int.unsigned odst + delta0 + sz)); simpl.
  red; intros. generalize (H0 x H12). unfold loc_out_of_reach, Intv.In; simpl. 
  intros. exploit H14; eauto. 
  exploit Mem.range_perm_in_bounds. eexact RPDST. omega. 
  omega.
  generalize (size_chunk_pos chunk); omega.
  omega.
  split. apply inject_incr_refl.
  red; intros; congruence.
(* trace length *)
  intros; inv H. simpl; omega.
(* receptive *)
  intros. 
  assert (t1 = t2). inv H; inv H0; auto. subst t2.
  exists vres1; exists m1; auto.
(* determ *)
  intros; inv H; inv H0. split. constructor. intros; split; congruence.
Qed.

*)

(** ** Semantics of IO system calls. *)

Inductive extcall_io_sem (TD:TargetData) name (tret: typ) 
    (targs: list typ) (ge: Genv.t GenericValue):
      list GenericValue -> mem -> trace -> option GenericValue -> mem -> Prop :=
  | extcall_io_sem_intro: forall vargs m args res vres,
      eventgv_list_match TD ge args targs vargs ->
      option_f2t (eventgv_match TD ge) res tret vres ->
      extcall_io_sem TD name tret targs ge vargs m (Event_syscall name args res :: E0) vres m.

Lemma extcall_io_ok:
  forall TD name tret targs,
  extcall_properties TD (extcall_io_sem TD name tret targs) tret targs.
Proof.
  intros; constructor; intros.
(* well typed *)
  inv H. 
  inv H1; constructor; auto.
    eapply eventgv_match_type; eauto.
(* arity *)
  inv H. eapply eventgv_list_match_length; eauto.
(* symbols preserved *)
  inv H0. econstructor; eauto. 
    eapply eventgv_list_match_preserved; eauto.
    inv H2; constructor; auto.
      eapply eventgv_match_preserved; eauto. 
(* valid block *)
  inv H; auto.
(* bounds *)
  inv H; auto.
(* mem extends *)
  inv H.
  exists vres; exists m1'; intuition.
    econstructor; eauto.
      eapply eventgv_list_match_lessdef; eauto.
    inv H3; constructor; auto.
      apply gv_lessdef_ref.
    red; auto.
(* mem injects *)
  inv H0.
  exists f; exists vres; exists m1'; intuition.
    econstructor; eauto.
      eapply eventgv_list_match_inject; eauto.
    inv H4; constructor; auto.
      eapply eventgv_match_inject_2; eauto.
    red; auto.
    red; auto.
    red; intros; congruence.
(* trace length *)
  inv H; simpl; omega.
(* receptive *)
  inv H; inv H0; inv H2.
    apply eventgv_match_valid in H0; auto.
    destruct H0 as [ms [G1 [G2 G3]]].
    rewrite H8 in G3.
    eapply eventgv_valid_match in H7; eauto.
    destruct H7 as [vs H7].
    exists (Some vs). exists m1.
    apply extcall_io_sem_intro; auto.
       constructor; auto.

    exists None. exists m1.
    apply extcall_io_sem_intro; auto.
       constructor; auto.
(* determ *)
  inv H; inv H0.
  assert (args0 = args1). 
    eapply eventgv_list_match_determ_2; eauto.
  subst args1.
  inv H2; inv H3; try congruence.
    assert (W1:=H0). assert (W2:=H2).
    apply eventgv_match_valid in H0; auto.
    destruct H0 as [ms1 [G1 [G2 G3]]].
    apply eventgv_match_valid in H2; auto.
    destruct H2 as [ms2 [G4 [G5 G6]]].
    split.
      constructor; auto. congruence.

      intros.
      split; auto.
        inv H0. f_equal.
        eapply eventgv_match_determ_1; eauto.

    split; auto.
      constructor.
Qed.

(** ** Semantics of other system calls. *)

Inductive extcall_other_sem (TD:TargetData) (tret: typ) 
    (targs: list typ) (ge: Genv.t GenericValue):
      list GenericValue -> mem -> trace -> option GenericValue -> mem -> Prop :=
  | extcall_other_sem_intro: forall vargs m args res vres,
      eventgv_list_match TD ge args targs vargs ->
      option_f2t (eventgv_match TD ge) res tret vres ->
      extcall_other_sem TD tret targs ge vargs m E0 vres m.

Axiom extcall_other_ok: forall TD tret targs,
  extcall_properties TD (extcall_other_sem TD tret targs) tret targs.

(*
(** ** Semantics of annotation. *)

Inductive extcall_annot_sem (text: ident) (targs: list typ) (F V: Type) (ge: Genv.t F V):
              list val -> mem -> trace -> val -> mem -> Prop :=
  | extcall_annot_sem_intro: forall vargs m args,
      eventval_list_match ge args targs vargs ->
      extcall_annot_sem text targs ge vargs m (Event_annot text args :: E0) Vundef m.

Lemma extcall_annot_ok:
  forall text targs,
  extcall_properties (extcall_annot_sem text targs) (mksignature targs None).
Proof.
  intros; constructor; intros.
(* well typed *)
  inv H. simpl. auto.
(* arity *)
  inv H. eapply eventval_list_match_length; eauto.
(* symbols *)
  inv H1. econstructor; eauto. 
  eapply eventval_list_match_preserved; eauto.
(* valid blocks *)
  inv H; auto.
(* bounds *)
  inv H; auto.
(* mem extends *)
  inv H.
  exists Vundef; exists m1'; intuition.
  econstructor; eauto.
  eapply eventval_list_match_lessdef; eauto.
  red; auto.
(* mem injects *)
  inv H0.
  exists f; exists Vundef; exists m1'; intuition.
  econstructor; eauto.
  eapply eventval_list_match_inject; eauto.
  red; auto.
  red; auto.
  red; intros; congruence.
(* trace length *)
  inv H; simpl; omega.
(* receptive *)
  assert (t1 = t2). inv H; inv H0; auto. 
  exists vres1; exists m1; congruence.
(* determ *)
  inv H; inv H0.
  assert (args = args0). eapply eventval_list_match_determ_2; eauto. subst args0.
  split. constructor. auto.
Qed.

Inductive extcall_annot_val_sem (text: ident) (targ: typ) (F V: Type) (ge: Genv.t F V):
              list val -> mem -> trace -> val -> mem -> Prop :=
  | extcall_annot_val_sem_intro: forall varg m arg,
      eventval_match ge arg targ varg ->
      extcall_annot_val_sem text targ ge (varg :: nil) m (Event_annot text (arg :: nil) :: E0) varg m.

Lemma extcall_annot_val_ok:
  forall text targ,
  extcall_properties (extcall_annot_val_sem text targ) (mksignature (targ :: nil) (Some targ)).
Proof.
  intros; constructor; intros.

  inv H. unfold proj_sig_res; simpl. eapply eventval_match_type; eauto.

  inv H. auto.

  inv H1. econstructor; eauto. 
  eapply eventval_match_preserved; eauto.

  inv H; auto.

  inv H; auto.

  inv H. inv H1. inv H6. 
  exists v2; exists m1'; intuition.
  econstructor; eauto.
  eapply eventval_match_lessdef; eauto.
  red; auto.

  inv H0. inv H2. inv H7.
  exists f; exists v'; exists m1'; intuition.
  econstructor; eauto.
  eapply eventval_match_inject; eauto.
  red; auto.
  red; auto.
  red; intros; congruence.

  inv H; simpl; omega.

  assert (t1 = t2). inv H; inv H0; auto. subst t2.
  exists vres1; exists m1; auto.

  inv H; inv H0.
  assert (arg = arg0). eapply eventval_match_determ_2; eauto. subst arg0.
  split. constructor. auto.
Qed.
*)

(*
(** ** Combined semantics of external calls *)

(** Combining the semantics given above for the various kinds of external calls,
  we define the predicate [external_call] that relates:
- the external function being invoked
- the values of the arguments passed to this function
- the memory state before the call
- the result value of the call
- the memory state after the call
- the trace generated by the call (can be empty).

This predicate is used in the semantics of all CompCert languages. *)

Definition external_call (ef: external_function): extcall_sem :=
  match ef with
  | EF_external name sg  => extcall_io_sem name sg
  | EF_builtin name sg   => extcall_io_sem name sg
  | EF_vload chunk       => volatile_load_sem chunk
  | EF_vstore chunk      => volatile_store_sem chunk
  | EF_malloc            => extcall_malloc_sem 
  | EF_free              => extcall_free_sem
  | EF_memcpy sz al      => extcall_memcpy_sem sz al
  | EF_annot txt targs   => extcall_annot_sem txt targs
  | EF_annot_val txt targ=> extcall_annot_val_sem txt targ
  end.

Theorem external_call_spec:
  forall ef, 
  extcall_properties (external_call ef) (ef_sig ef).
Proof.
  intros. unfold external_call, ef_sig. destruct ef.
  apply extcall_io_ok.
  apply extcall_io_ok.
  apply volatile_load_ok.
  apply volatile_store_ok.
  apply extcall_malloc_ok.
  apply extcall_free_ok.
  apply extcall_memcpy_ok.
  apply extcall_annot_ok.
  apply extcall_annot_val_ok.
Qed.

Definition external_call_well_typed ef := ec_well_typed (external_call_spec ef).
Definition external_call_arity ef := ec_arity (external_call_spec ef).
Definition external_call_symbols_preserved_gen ef := ec_symbols_preserved (external_call_spec ef).
Definition external_call_valid_block ef := ec_valid_block (external_call_spec ef).
Definition external_call_bounds ef := ec_bounds (external_call_spec ef).
Definition external_call_mem_extends ef := ec_mem_extends (external_call_spec ef).
Definition external_call_mem_inject ef := ec_mem_inject (external_call_spec ef).
Definition external_call_trace_length ef := ec_trace_length (external_call_spec ef).
Definition external_call_receptive ef := ec_receptive (external_call_spec ef).
Definition external_call_determ ef := ec_determ (external_call_spec ef).

(** Special cases of [external_call_symbols_preserved_gen]. *)

Lemma external_call_symbols_preserved:
  forall ef F1 F2 V (ge1: Genv.t F1 V) (ge2: Genv.t F2 V) vargs m1 t vres m2,
  external_call ef ge1 vargs m1 t vres m2 ->
  (forall id, Genv.find_symbol ge2 id = Genv.find_symbol ge1 id) ->
  (forall b, Genv.find_var_info ge2 b = Genv.find_var_info ge1 b) ->
  external_call ef ge2 vargs m1 t vres m2.
Proof.
  intros. eapply external_call_symbols_preserved_gen; eauto.
  intros. unfold block_is_volatile. rewrite H1. auto.
Qed.

Require Import Errors.

Lemma external_call_symbols_preserved_2:
  forall ef F1 V1 F2 V2 (tvar: V1 -> res V2)
         (ge1: Genv.t F1 V1) (ge2: Genv.t F2 V2) vargs m1 t vres m2,
  external_call ef ge1 vargs m1 t vres m2 ->
  (forall id, Genv.find_symbol ge2 id = Genv.find_symbol ge1 id) ->
  (forall b gv1, Genv.find_var_info ge1 b = Some gv1 ->
     exists gv2, Genv.find_var_info ge2 b = Some gv2 /\ transf_globvar tvar gv1 = OK gv2) ->
  (forall b gv2, Genv.find_var_info ge2 b = Some gv2 ->
     exists gv1, Genv.find_var_info ge1 b = Some gv1 /\ transf_globvar tvar gv1 = OK gv2) ->
  external_call ef ge2 vargs m1 t vres m2.
Proof.
  intros. eapply external_call_symbols_preserved_gen; eauto.
  intros. unfold block_is_volatile.
  case_eq (Genv.find_var_info ge1 b); intros.
  exploit H1; eauto. intros [g2 [A B]]. rewrite A. monadInv B. destruct g; auto.
  case_eq (Genv.find_var_info ge2 b); intros.
  exploit H2; eauto. intros [g1 [A B]]. congruence.
  auto.
Qed.

(** Corollary of [external_call_valid_block]. *)

Lemma external_call_nextblock:
  forall ef (F V : Type) (ge : Genv.t F V) vargs m1 t vres m2,
  external_call ef ge vargs m1 t vres m2 ->
  Mem.nextblock m1 <= Mem.nextblock m2.
Proof.
  intros. 
  exploit external_call_valid_block; eauto. 
  instantiate (1 := Mem.nextblock m1 - 1). red; omega.
  unfold Mem.valid_block. omega.
Qed.

(** Corollaries of [external_call_determ]. *)

Lemma external_call_match_traces:
  forall ef (F V : Type) (ge : Genv.t F V) vargs m t1 vres1 m1 t2 vres2 m2,
  external_call ef ge vargs m t1 vres1 m1 ->
  external_call ef ge vargs m t2 vres2 m2 ->
  match_traces ge t1 t2.
Proof.
  intros. exploit external_call_determ. eexact H. eexact H0. tauto.
Qed.

Lemma external_call_deterministic:
  forall ef (F V : Type) (ge : Genv.t F V) vargs m t vres1 m1 vres2 m2,
  external_call ef ge vargs m t vres1 m1 ->
  external_call ef ge vargs m t vres2 m2 ->
  vres1 = vres2 /\ m1 = m2.
Proof.
  intros. exploit external_call_determ. eexact H. eexact H0. intuition.
Qed.
*)

(* Originally Copied from CompCert Events.v 1.9.1 END *)

(* FIXME: Because memory only stores concrete values, the semantics branches when
   storing data. However, at rule malloc/free/load/store/call/..., the rules also 
   branch. Thoses rules should do what bop/fop/trunc do by lifting det-rules to 
   non-det rules!!! *)

Parameter callIOFunction : TargetData -> list (atom*GenericValue) -> mem -> 
  id -> typ -> list typ -> list GenericValue -> 
  option ((option GenericValue)*trace*mem).

Axiom callIOFunction__extcall_io_sem: forall TD gl m1 name tret targs args m2
  oret tr,
  callIOFunction TD gl m1 name tret targs args = Some (oret, tr, m2) ->
  extcall_io_sem TD name tret targs (globals2Genv TD gl) args m1 tr oret m2.

Parameter callExternalFunction : TargetData -> list (atom*GenericValue) -> 
  mem -> id -> typ -> list typ -> list GenericValue -> 
  option ((option GenericValue)*mem).

Axiom callExternalFunction__extcall_other_sem: forall TD gl m1 name tret targs 
  args m2 oret,
  callExternalFunction TD gl m1 name tret targs args = Some (oret, m2) ->
  extcall_other_sem TD tret targs (globals2Genv TD gl) args m1 E0 oret m2.

Parameter callIntrinsics : TargetData -> list (atom*GenericValue) -> mem -> 
  intrinsic_id -> typ -> list typ -> list GenericValue -> 
  option ((option GenericValue)*mem).

Axiom callIntrinsics__extcall_properties: forall TD gl m1 name tret targs 
  args m2 oret,
  callIntrinsics TD gl m1 name tret targs args = Some (oret, m2) ->
  extcall_other_sem TD tret targs (globals2Genv TD gl) args m1 E0 oret m2.

Definition callMalloc (TD:TargetData) (M:mem) (parameters: list GenericValue) 
  : option ((option GenericValue)*mem) :=
match parameters with
| gn::_ => 
    match malloc TD M Size.One gn Align.Four with
    | Some (M', mb) => Some (Some (blk2GV TD mb), M')
    | _ => None
    end
| _ => 
   (* We should prove that given a well-formed program, this case won't happen
      because malloc must have one parameters *)
   None
end.

Axiom callMalloc__extcall_properties: forall TD ge m1 args m2 oret targs,
  callMalloc TD m1 args = Some (oret, m2) ->
  targs = [(typ_int Size.ThirtyTwo)] \/ targs = [(typ_int Size.SixtyFour)] ->
  extcall_other_sem TD (typ_pointer (typ_int Size.Eight)) 
    targs ge args m1 E0 oret m2.

Definition callFree (TD:TargetData) (M:mem) (parameters: list GenericValue) 
  : option ((option GenericValue)*mem) :=
match parameters with
| ptr::_ => 
    match free TD M ptr with
    | Some M' => Some (None, M')
    | _ => None
    end
| _ => 
   (* We should prove that given a well-formed program, this case won't happen
      because free must have one parameters *)
   None
end.

Axiom callFree__extcall_properties: forall TD ge m1 args m2 oret,
  callFree TD m1 args = Some (oret, m2) ->
  extcall_other_sem TD typ_void [(typ_pointer (typ_int Size.Eight))] 
    ge args m1 E0 oret m2.

Definition add_empty_trace (input: option ((option GenericValue)*mem)):
  option ((option GenericValue)*trace*mem) :=
match input with
| None => None
| Some (or, M') => Some (or, E0, M')
end.

Definition callExternalOrIntrinsics (TD:TargetData) 
  (gl:list (atom*GenericValue)) (M:mem) (fid:id) 
  (tret: typ) (targs: list typ) (dck:deckind) 
  (parameters: list GenericValue) : option ((option GenericValue)*trace*mem) :=
let targs' := targs in
match dck with
| deckind_intrinsic iid => 
    add_empty_trace (callIntrinsics TD gl M iid tret targs' parameters)
| deckind_external eid_malloc => add_empty_trace (callMalloc TD M parameters)
| deckind_external eid_free => add_empty_trace (callFree TD M parameters)
| deckind_external eid_io => callIOFunction TD gl M fid tret targs' parameters
| deckind_external eid_other => 
    add_empty_trace (callExternalFunction TD gl M fid tret targs' parameters)
end.

